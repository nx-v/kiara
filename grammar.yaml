name: Kiara
scopeName: source.spwn # will change to Kiara once the language is out
fileTypes: [kiara, spwn]
patterns: [include: "#core"]

informationForContributors: |
  This is the grammar for Kiara, a personal programming language project
  for building applications for the web, and introducing new paradigms
  and sugar to an already familiar JS and Rust-inspired syntax.

  The grammar is still being revamped but will need to be heavily refactored
  and reorganized, along with some major bugs that need to be ironed out. 

  Feel free to fork or make an issue in this repository if there are any 
  questions to be raised or changes to be made or implemented in the future.

changelog: |
  A major rewrite is underway. This language's syntax would be terser 
  and thus inspired by Rust, Zig and D.

  New changes:

  - Most keywords should have a max of 6 characters, though some, like
    "continue", "default" and "foreach", will be kept as is.
  - Range keywords to, till and by have been removed in favor of range operators.
  - Syntax now closely resembles Rust's. This includes keywords, comments,
    literals, strings etc. Many parts of this document have been changed.
  - Generics now capture properly before and after function names
    For example, T.<x>, T?.<x>, T!.<x>, T::<x>, T?:<x>, T!:<x>.
    They can even be curried: x<T><U>(y).
  - Numbers and escape sequences have been reworked, and will no longer accept
    integers bigger than decimal 1114111 which now are highlighted as an error.
  - Base 12 (0z, \z in strings and character classes) is added back,
    with A, X, T, or turned 2 for digit 10, and B, E or turned 3 for digit 11.
  - Bases 4 and 6 have been removed, though a multi-base (up to base 64)
    numeric literal is still in the works.
  - Interpolation and formatting syntax have been reworked and fixed, and can now
    span multiple lines and beyond 20 nested layers thanks to applyEndPatternLast.
    Because of this, spacing around most of the patterns here have also been removed;
    a separate 'space' scope is added to join everything together.
  - Function call syntax is heavily standardized and would need a later fix in
    the long run. This is if a more terser variant of Kiara is in the need,
    and if so would be inspired by Haskell.
  - Fixed some bugs with regular expressions:
    - Added and expanded quantifiers and range highlighting
    - Add support for fuzzy matching (edits, insertions, deletions, etc.)
    - Improved highlighting for regexes with flags
  - Added prefixes to strings.
  - Switched around regular expressions: / triggers a regex when it begins an
    expression. ` is now used to begin unquoted strings.
  - Two (or more) regular expressions in a row on the same line without a comma
    triggers a replacement string instead of a normal regular expression literal.
  - Changed up syntax highlighting of switch and match statements to be more
    consistent with JavaScript.
  - Function calls now trigger beside ( and {.
  - Added Perl/Ruby's unless and until keywords.
  - Fixed module syntax to be more consistent with JavaScript.
  - Dashes will no longer allowed in identifiers.
  - Fixed JSX highlighting and attributes, inspired by Svelte, Angular (TS), HAML
    - @directive
    - #id and .class
    - :event and |pipe (both from Svelte)
    - %directive
    - &reference and *spread
    - ?boolean and @property (from Lit)
  - Added script blocks for injection of raw JavaScript.
  - Fixed keys in literal objects
  - Fixed modifier keywords beside function literals
  - Fixed default values in function arguments, thus no longer requiring trailing
    commas. 'from' and 'where' statements, the string `\| and the operator | have to
    be bracketed.
  - Slightly changed attribute selectors to allow for regexp matches.
  - Added Scala's 'given'/'using' syntax to function arguments

  Fixes:

  - Large regexps scattered through this document also have been
    fixed up to be more readable to any editors out there. It once was presented
    in a rather unpretty format.
    - [x] Markdown syntax
    - [x] function parameters
    - [x] function calls
    - [x] identifiers and variables
    - [x] operators
    - [x] object literals
    - [x] object labels
    - [x] pipeline functions
    - [x] modifier keywords
    - [x] function assignments
    - [x] anonymous functions
    - [x] embedded content
    - [x] rounded and square brackets
    - [x] LINQ, inline SQL and constraint syntax (more to come later)
  - Fix syntax of type annotations inside generics to avoid being parsed as custom operators.
  - Fix syntax of generic type parameters and constraints.
  - Match unquoted globs in routes
  - Fix syntax for JavaScript ES5 module import and export statements
  - Reimplement Markdown syntax with these extensions:
    - [ ] Citations
    - [ ] Strike-through
    - [ ] Deleted and inserted text
    - [ ] Superscript
    - [ ] Subscript
    - [ ] Spans
    - [ ] Selectors and anchors
    - [ ] Code blocks
    - [ ] Definition blocks
    - [ ] Tables
    - [ ] Headings and subheadings
  - Rework inline "Markdown" syntax. Refer to Texy, Textile, AsciiDoc and cousins.
  - Plan and implement all the built-in objects, constants and
    functions for Kiara's standard library.
    This would all be done in a separate PR and once the grammar is completely
    finished.
    - A handful of built-in properties and constants are part of this grammar
      and are used to highlight CSS properties, constants and HTML tags. Other
      than that, nothing else is present...
      at least not in the moment
    - This features would include:
      - Type, interface, module/namespace and class names
      - Functions and methods
      - Constants and properties
      - Special variables
      - Various UI elements and color names
      - Character names (LaTeX/HTML/AGLFN)
  - Add new parameter binding/destructuring syntax for:
    - [ ] Strings
    - [ ] Regular expressions
    - [ ] Arrays
    - [ ] Sets
    - [ ] Maps and objects
    - [ ] Tuples
    - [ ] Function arguments
    - [ ] Variables

define:
  entity-name: &entity-name |
    (?x) \s*\b

    (?!
      (?<!(?:(?<!\.)\.|[?!:]:)=?)\b
      (?: # keywords
        in|of|as|is|new|delete
        |unset|ref|and|x?or|not
        |var|val|let|const|func
        |proc|method|type|class|crate
        |impl|enum|module|struct|field
        |union|iter|macro|query|elem
        |object|realm|trait|style|script
        |go|defer|do|with|from|where
        |if|unless|else|then|declare|ref
        |for|foreach|repeat|while|until
        |try|throw|catch|finally|switch
        |match|case|pass|default|goto|move
        |break|continue|redo|retry
        |return|yield|await|scope
        # |import|export|intern|extern
        |debug|assert|check
      )
      \b
    )

    # identifier
    ([\p{Pc}\p{L}]\w*)
    \b

  keywords: |
    (?x) \s* \b

    (?<!(?:(?<!\.)\.|[?!:]:)=?)\b
      (?: # keywords
        in|of|as|is|new|delete
        |unset|ref|and|x?or|not
        |var|val|let|const|func
        |proc|method|type|class|crate
        |impl|enum|module|struct|field
        |union|iter|macro|query|elem
        |object|realm|trait|style|script
        |go|defer|do|with|from|where
        |if|unless|else|then|declare|ref
        |for|foreach|repeat|while|until
        |try|throw|catch|finally|switch
        |match|case|pass|default|goto|move
        |break|continue|redo|retry
        |return|yield|await|scope
        # |import|export|intern|extern
        |debug|assert|check
      )
    \b

  html-tag-names: &html-tag-names
    - match: (?x)([?!:]:|[?!]?\.)
      captures:
        1: {name: punctuation.separator.namespace.kiara}
    - match: \b([\p{Pc}\p{L}]\w*)\b(?=[:.])
      name: entity.name.tag.namespace.kiara
    - match: \b((?:[\p{Pc}\p{L}&&\P{Ll}][\w&&\P{Lu}]*)+)\b
      name: support.class.component.kiara
    - include: "#clauses"
    - include: "#declarations"
    - include: "#keywords"
    - include: "#html-tag-names"

repository:
  core:
    patterns:
      - include: "#ignore-long-lines"
      - include: "#clauses"
      - include: "#declarations"
      - include: "#keywords"
      - include: "#comments"
      - include: "#argument-list"
      - include: "#function-clause"
      - include: "#symbols"
      - include: "#decorators"
      - include: "#type-signature"
      - include: "#illegal-identifier"
      - include: "#jsx"
      - include: "#generics"
      - include: "#literals"
      - include: "#accessor-operators"
      - include: "#brackets"
      - include: "#punctuation"
      - include: "#operators"
      - include: "#function-calls"
      - include: "#variables"
      - include: "#illegal"
      - include: "#space"

  ignore-long-lines:
    comment: avoid parsing files with long lines of code
    match: ^.{4097,}$

  space:
    match: \s+
    name: meta.var.expr.kiara

  # Illegal Syntax

  illegal:
    patterns:
      - match: \p{N}[\w.+-/\\]*?
        name: invalid.illegal.numeric.kiara
      - match: '[\w]+?'
        name: invalid.illegal.variable.kiara
      - match: '[({\[)}\]]+?'
        name: invalid.illegal.missing-bracket.kiara
      - match: '[\p{S}\p{P}&&[^,;''"`({\[)}\]\p{Pc}]]+'
        name: invalid.illegal.operator.kiara
      - match: \S+?
        name: invalid.illegal.uncaught.kiara

  illegal-identifier:
    applyEndPatternLast: true
    name: meta.type.kiara
    begin: (?<=\w+\b)\s*(?=\b\w+)
    end: (?=)|$
    patterns:
      - match: \s*\w+\s*
        name: invalid.illegal.identifier.kiara

  # Types

  types:
    patterns:
      - include: "#comments"
      - include: "#embedded-expression"
      - include: "#angle-brackets"
      - include: "#modifiers"
      - include: "#type-keywords"
      - include: "#type-names"
      - include: "#literals"
      - include: "#type-variables"
      - include: "#type-operators"
      - include: "#type-brackets"
      - include: "#space"

  type-variables:
    comment: |
      Four types of variables:
      - _lead_underscore
      - UPPERCASE
      - PascalCase
      - camelCase
    match: |
      (?x) \s* \b

      (?!
        (?<!(?:(?<!\.)\.|[?!:]:)=?)\b
        (?: # keywords
          in|of|as|is|new|delete
          |unset|ref|and|x?or|not
          |var|val|let|const|func
          |proc|method|type|class|crate
          |impl|enum|module|struct|field
          |union|iter|macro|query|elem
          |object|realm|trait|style|script
          |go|defer|do|with|from|where
          |if|unless|else|then|declare|ref
          |for|foreach|repeat|while|until
          |try|throw|catch|finally|switch
          |match|case|pass|default|goto|move
          |break|continue|redo|retry
          |return|yield|await|scope
          # |import|export|intern|extern
          |debug|assert|check
        )
        \b
      )

      (?:
        (?<=(?:^|[,;'"`(){}\[\]\w\s]|\\.)(?:[!?]?\.=?|[?!:]:=?))
        (?: # Properties
            # Leading underscore
            (\p{Pc}+\w*\b(?!\p{Pc}+))
          | # Train case
            ([\p{L}&&\P{Ll}][\w&&\P{Ll}]*)
          | # Pascal case
            ((?:[\p{Pc}\p{L}&&\P{Ll}][\w&&\P{Lu}]*)+)
          | # Camel or kebab case
            ([\p{Pc}\p{L}]\w*)
        )
        |
        (?: # Objects
            # Leading underscore
            (\p{Pc}+\w*\b(?!\p{Pc}+))
          | # Train case
            ([\p{L}&&\P{Ll}][\w&&\P{Ll}]*)
          | # Pascal case
            ((?:[\p{Pc}\p{L}&&\P{Ll}][\w&&\P{Lu}]*)+)
          | # Camel or kebab case
            ([\p{Pc}\p{L}]\w*)
        )
        (?=(?:[!?]?\.=?|[?!:]:=?|<)(?:[,;'"`(){}\[\]\w\s]|$))
        |
        (?: # Regular variables
            # Leading underscore
            (\p{Pc}+\w*\b(?!\p{Pc}+))
          | # Train case
            ([\p{L}&&\P{Ll}][\w&&\P{Ll}]*)
          | # Pascal case
            ((?:[\p{Pc}\p{L}&&\P{Ll}][\w&&\P{Lu}]*)+)
          | # Camel or kebab case
            ([\p{Pc}\p{L}]\w*)
        )
      )\b

      \s*
    captures:
      1: {name: entity.name.trait.kiara}
      2: {name: entity.name.interface.kiara}
      3: {name: entity.name.interface.kiara}
      4: {name: entity.name.trait.kiara}
      5: {name: entity.name.module.kiara}
      6: {name: entity.name.namespace.kiara}
      7: {name: entity.name.namespace.kiara}
      8: {name: entity.name.module.kiara}
      9: {name: entity.name.type.kiara}
      10: {name: entity.name.class.kiara}
      11: {name: entity.name.class.kiara}
      12: {name: entity.name.type.kiara}

  type-signature:
    applyEndPatternLast: true
    name: meta.type.kiara
    begin: (?<=(?:[)}\]\w\s'"`]|\\.)\|?|^\|?)(:)(?=$|[\w\s'"`({\[])
    end: (?=)|$
    beginCaptures:
      1: {name: punctuation.definition.annotation.kiara}
    patterns:
      - include: "#types"

  type-brackets:
    patterns:
      - include: "#type-curly-brackets"
      - include: "#type-square-brackets"
      - include: "#type-round-brackets"

  type-curly-brackets:
    repository:
      punctuation:
        patterns:
          - match: ","
            name: punctuation.separator.mapping.kiara
          - match: (?<=(?:['"`)}\]\w]|\\.)[\p{S}\p{P}&&[^,;'"`({\[)}\]\p{Pc}]]*):(?=['"`({\[\w\s]|$)
            name: punctuation.separator.key-value.kiara

    patterns:
      - begin: |
          (?x)
          (?<=
            (?:^|[,;'"({\[)}\]\s]) # beside a delimiter or space
            \b
              (?: # destructuring keywords
                var|val|let|const|case
              )
            \b
            (?:$|[,;'"({\[)}\]\s]) # beside a delimiter or space
            \s*
          )
          (\#?\{)\s*
        end: \s*(\})
        name: meta.brace.curly.kiara
        captures:
          1:
            name: punctuation.definition.binding-pattern.object.kiara
        patterns:
          - include: "#labels"
          - include: "#punctuation"
          - include: "#as-keyword"
          - include: "#types"
          - include: $self
      - begin: |
          (?x)
          (?<=
            (?:^|[,;'"({\[)}\]\s]) # beside a delimiter or space
            \b
              (?: # expression keywords
                in|of|as|is|new|delete
                |unset|ref|and|x?or|not
              )
            \b
            (?:$|[,;'"({\[)}\]\s]) # beside a delimiter or space
            \s*
          )
          (\#\{)\s*
        end: \s*(\})
        name: meta.brace.curly.kiara
        captures:
          1: {name: punctuation.definition.mapping.kiara}
        patterns:
          - include: "#labels"
          - include: "#punctuation"
          - include: "#types"
          - include: $self
      - begin: |
          (?x)
          (?<=
            (?:^|[,;'"({\[)}\]\s]) # beside a delimiter or space
            \b
              (?: # expression keywords
                in|of|as|is|new|delete
                |unset|ref|and|x?or|not
              )
            \b
            (?:$|[,;'"({\[)}\]\s]) # beside a delimiter or space
            \s*
          )
          (\{)\s*
        end: \s*(\})
        name: meta.brace.curly.kiara
        captures:
          1: {name: punctuation.definition.dictionary.kiara}
        patterns:
          - include: "#labels"
          - include: "#punctuation"
          - include: "#types"
          - include: $self
      - begin: |
          (?x)
          (?<=
            (?:
                ^
              | [,;({\[]
              | (?:^|[,;({\[)}\]\w'"`]|\\.):\s*
              | [\p{S}\p{P}&&[^,;'"`({\[)}\]\p{Pc}]]+
            )
            \s*
          )
          (\#\{)\s*
        end: \s*(\})
        name: meta.brace.curly.kiara
        captures:
          1: {name: punctuation.definition.mapping.kiara}
        patterns:
          - include: "#labels"
          - include: "#punctuation"
          - include: "#types"
          - include: $self
      - begin: |
          (?x)
          (?<=
            (?:
                ^
              | [,;({\[]
              | (?:^|[,;({\[)}\]\w'"`]|\\.):\s*
              | [\p{S}\p{P}&&[^,;'"`({\[)}\]\p{Pc}]]+
            )
            \s*
          )
          (\{)\s*
        end: \s*(\})
        name: meta.brace.curly.kiara
        captures:
          1: {name: punctuation.definition.dictionary.kiara}
        patterns:
          - include: "#labels"
          - include: "#punctuation"
          - include: "#types"
          - include: $self

  type-round-brackets:
    repository:
      punctuation:
        patterns:
          - match: ","
            name: punctuation.separator.arguments.kiara
          - match: \s*(?<!(?:(?<!\.)\.|[?!:]:)=?)\b(as)\b\s*
            name: keyword.operator.expression.as.kiara
          - match: (?<=[\w\s][(|])\.
            name: punctuation.definition.metadata.kiara
    patterns:
      - begin: |
          (?x)
          (?<= # literal
              (?: [\w'"`)}\]] | \\.) >* \s*
            | [^.]\.=?|[?!:]:=?
          )
          (\#?\()\s*
        end: \s*(\))
        name: meta.brace.round.kiara
        captures:
          1: {name: punctuation.definition.parameters.kiara}
        patterns:
          - include: "#types"
          - include: $self
      - begin: |
          (?x)
          (?<=
            (?:^|[,;'"({\[)}\]\s]) # beside a delimiter or space
            \b
              (?: # destructuring keywords
                var|val|let|const|case
              )
            \b
            (?:$|[,;'"({\[)}\]\s]) # beside a delimiter or space
            \s*
          )
          (\#?\()\s*
        end: \s*(\))
        name: meta.brace.round.kiara
        captures:
          1: {name: punctuation.definition.binding-pattern.tuple.kiara}
        patterns:
          - include: "#punctuation"
          - include: "#types"
          - include: $self
      - begin: (\#\()\s*
        end: \s*(\))
        name: meta.brace.round.kiara
        captures:
          1: {name: punctuation.definition.tuple.kiara}
        patterns:
          - include: "#types"
          - include: $self
      - begin: (\()\s*
        end: \s*(\))
        name: meta.brace.round.kiara
        captures:
          1: {name: punctuation.definition.expression.kiara}
        patterns:
          - include: "#types"
          - include: $self

  type-square-brackets:
    repository:
      punctuation:
        patterns:
          - match: ","
            name: punctuation.separator.sequence.kiara
    patterns:
      - begin: |
          (?x)
          (?<= # literal
              (?: [\w'"`)}\]] | \\.) \s*
            | [^.]\.=?|[?!:]:=?
          )
          (\#?\[)\s*
        end: \s*(\])
        name: meta.brace.square.kiara
        captures:
          1: {name: punctuation.definition.attribute-selector.kiara}
        patterns:
          - include: "#types"
          - include: $self
      - begin: |
          (?x)
          (?<=
            (?:^|[,;'"({\[)}\]\s]) # beside a delimiter or space
            \b
              (?: # destructuring keywords
                var|val|let|const|case
              )
            \b
            (?:$|[,;'"({\[)}\]\s]) # beside a delimiter or space
            \s*
          )
          (\#?\[)\s*
        end: \s*(\])
        name: meta.brace.square.kiara
        captures:
          1: {name: punctuation.definition.binding-pattern.array.kiara}
        patterns:
          - include: "#punctuation"
          - include: "#types"
          - include: $self
      - begin: (\#\[)\s*
        end: \s*(\])
        name: meta.brace.square.kiara
        captures:
          1: {name: punctuation.definition.sequence.kiara}
        patterns:
          - include: "#punctuation"
          - include: "#types"
          - include: $self
      - begin: (\[)\s*
        end: \s*(\])
        name: meta.brace.square.kiara
        captures:
          1: {name: punctuation.definition.array.kiara}
        patterns:
          - include: "#punctuation"
          - include: "#types"
          - include: $self

  type-keywords:
    patterns:
      - match: \s*(?<!(?:(?<!\.)\.|[?!:]:)=?)\b(from)\b\s*
        name: storage.type.extends.kiara
      - match: \s*(?<!(?:(?<!\.)\.|[?!:]:)=?)\b(for)\b\s*
        name: storage.type.implements.kiara
      - match: \s*(?<!(?:(?<!\.)\.|[?!:]:)=?)\b(infer|as|is)\b\s*
        name: keyword.operator.expression.$1.kiara
      - match: \s*(?<!(?:(?<!\.)\.|[?!:]:)=?)\b((instance|value|pair|type|name|size|key)of)\b\s*
        name: keyword.operator.expression.$1.kiara

  type-operators:
    unused:
      - comment: Function types
        match: (?:^|\s+)(?:(\|)|(>))(?=['"`({\[\w])|(?<=['"`)}\]\w])(?:(\|)|(<))(?:$|\s+)
        captures:
          1: {name: keyword.operator.type.function.kiara}
          2: {name: keyword.operator.type.channel.kiara}
          3: {name: keyword.operator.type.function.kiara}
          4: {name: keyword.operator.type.channel.kiara}

    patterns:
      - &qualified-name-separators
        comment: Primary binary operators
        match: (?<=[)}\]\w])(?:(\?[.:]=?)|(![.:]=?)|((?:::|\.)=?))(?=[({\[\w])
        captures:
          1: {name: keyword.operator.optional.kiara}
          2: {name: keyword.operator.assert.kiara}
          3: {name: keyword.operator.accessor.kiara}
      - match: \s*(--?>|~~?>|==?>)
        name: keyword.operator.type.function.kiara
      - match: \s*(<--?|<~~?|<==?)
        name: keyword.operator.type.channel.kiara
      - comment: type unions
        match: (?<=^|[\s({\[])(\|)(?=$|[)}\]\s])|(?<=['"`)}\]\w]|\\.)(\|)(?=['"`({\[\w])
        captures:
          1: {name: keyword.operator.union.kiara}
          2: {name: keyword.operator.union.kiara}
      - comment: type operators
        match: |
          (?x)
          (?<=^|[,;'"`({\[)}\]\w\s]|\\.)
            (?:
              (\+)|(\-)|(\*)|(\/)|(\%)|(\!)
              |(\?)|(\&)|(\^)|(\~)|(\$)|(:[<>]|[<>]:)
            )
          (?=$|[,;'"`({\[)}\]\w\s])
        captures:
          1: {name: keyword.operator.sum.kiara}
          2: {name: keyword.operator.difference.kiara}
          3: {name: keyword.operator.product.kiara}
          4: {name: keyword.operator.quotient.kiara}
          5: {name: keyword.operator.remainder.kiara}
          6: {name: keyword.operator.only.kiara}
          7: {name: keyword.operator.maybe.kiara}
          8: {name: keyword.operator.intersection.kiara}
          9: {name: keyword.operator.symmetric.kiara}
          10: {name: keyword.operator.negation.kiara}
          11: {name: keyword.operator.macro.dollar.kiara}
          12: {name: keyword.operator.class.kiara}

  # Literals and Constants

  literals:
    patterns:
      - include: "#regexps"
      - include: "#strings"
      - include: "#numbers"
      - include: "#constants"
      - include: "#strings-unquoted"

  constants:
    patterns:
      - match: |
          (?x)
          (?<!(?:(?<!\.)\.|[?!:]:)=?)\b
          (?:
            (true|false) # boolean
            |(null|nan)
            |(undef) # undefined
            |(inf) # infinity
          )
          \b
        captures:
          1: {name: constant.language.boolean.$1.kiara}
          2: {name: constant.language.$2.kiara}
          3: {name: constant.language.undefined.kiara}
          4: {name: constant.language.infinity.kiara}
      - match: |
          (?x)
          (?<!(?:(?<!\.)\.|[?!:]:)=?)\b
          (?:
            (it|this|super|self) # special arguments
            |(params) # arguments
            |(constructor) # constructor
            |(prototype) # prototype
          )
          \b
        captures:
          1: {name: variable.language.$1.kiara}
          2: {name: variable.language.arguments.kiara}
          3: {name: variable.language.constructor.kiara}
          4: {name: variable.language.prototype.kiara}
      - match: |
          (?x)
          (?<!(?:(?<!\.)\.|[?!:]:)=?)\b
          (
            console|document|window|global|process|require|module|exports
            |navigator|location|history|localStorage|sessionStorage
          )
          \b
        captures:
          1: {name: support.type.object.$1.kiara}

  # Numbers

  numbers:
    applyEndPatternLast: true
    begin: (?<!\.)(?=\d)
    end: \b
    name: meta.number.kiara
    patterns:
      - comment: hexadecimal integer literal
        name: constant.numeric.hexadecimal.kiara
        match: |
          (?ix) \b
            (0x) # prefix
            \h [\h_]* # integer part
            (\.)? # decimal point
            [\h_]* # fractional part
            (?: # exponent part
              (p) # delimiter
              ([+-])? # sign
              ([\d_]+) # mantissa
            )?
            ([\p{Pc}\p{L}]\w*)? # type suffix
          \b
        captures:
          1: {name: storage.type.numeric.kiara}
          2: {name: keyword.other.unit.kiara}
          3: {name: keyword.operator.expression.exponent.kiara}
          4: {name: keyword.operator.exponent.sign.kiara}
          5: {name: constant.numeric.decimal.exponent.mantissa.kiara}
          6: {name: keyword.other.unit.kiara}
      - comment: duodecimal integer literal
        name: constant.numeric.duodecimal.kiara
        match: |
          (?ix) \b
            (0z) # prefix
            [\d\u218a\u218babetx] [\d\u218a\u218babetx_]* # integer part
            (\.)? # decimal point
            [\d\u218a\u218babetx_]* # fractional part
            (?: # exponent part
              (p) # delimiter
              ([+-])? # sign
              ([\d_]+) # mantissa
            )?
            ([\p{Pc}\p{L}]\w*)? # type suffix
          \b
        captures:
          1: {name: storage.type.numeric.kiara}
          2: {name: keyword.other.unit.kiara}
          3: {name: keyword.operator.expression.exponent.kiara}
          4: {name: keyword.operator.exponent.sign.kiara}
          5: {name: constant.numeric.decimal.exponent.mantissa.kiara}
          6: {name: keyword.other.unit.kiara}
      - comment: octal integer literal
        name: constant.numeric.octal.kiara
        match: |
          (?ix) \b
            (0o) # prefix
            [0-7] [0-7_]* # integer part
            (\.)? # decimal point
            [0-7_]* # fractional part
            (?: # exponent part
              (p) # delimiter
              ([+-])? # sign
              ([\d_]+) # mantissa
            )?
            ([\p{Pc}\p{L}]\w*)? # type suffix
          \b
        captures:
          1: {name: storage.type.numeric.kiara}
          2: {name: keyword.other.unit.kiara}
          3: {name: keyword.operator.expression.exponent.kiara}
          4: {name: keyword.operator.exponent.sign.kiara}
          5: {name: constant.numeric.decimal.exponent.mantissa.kiara}
          6: {name: keyword.other.unit.kiara}
      - comment: binary integer literal
        name: constant.numeric.binary.kiara
        match: |
          (?ix) \b
            (0b) # prefix
            [01] [01_]* # integer part
            (\.)? # decimal point
            [01_]* # fractional part
            (?: # exponent part
              (p) # delimiter
              ([+-])? # sign
              ([\d_]+) # mantissa
            )?
            ([\p{Pc}\p{L}]\w*)? # type suffix
          \b
        captures:
          1: {name: storage.type.numeric.kiara}
          2: {name: keyword.other.unit.kiara}
          3: {name: keyword.operator.expression.exponent.kiara}
          4: {name: keyword.operator.exponent.sign.kiara}
          5: {name: constant.numeric.decimal.exponent.mantissa.kiara}
          6: {name: keyword.other.unit.kiara}
      - comment: decimal (no prefix)
        name: constant.numeric.decimal.kiara
        match: |
          (?ix) \b
            () # prefix
            \d [\d_]* # integer part
            (\.)? # decimal point
            [\d_]* # fractional part
            (?: # exponent part
              (e) # delimiter
              ([+-])? # sign
              ([\d_]+) # mantissa
            )?
            ([\p{Pc}\p{L}]\w*)? # type suffix
          \b
        captures:
          1: {name: storage.type.numeric.kiara}
          2: {name: keyword.other.unit.kiara}
          3: {name: keyword.operator.expression.exponent.kiara}
          4: {name: keyword.operator.exponent.sign.kiara}
          5: {name: constant.numeric.decimal.exponent.mantissa.kiara}
          6: {name: keyword.other.unit.kiara}

  # Symbols

  decorators:
    applyEndPatternLast: true
    begin: (?<=^|\\.|['"`({\[)}\]\s]|(?:[)}\]\w\s'"`]|\\.)\s*[:=])(\@)(?=[\p{Pc}\p{L}])
    end: (?=)|$
    name: entity.name.decorator.kiara
    captures:
      1: {name: punctuation.definition.decorator.kiara}
      2: {name: entity.name.decorator.kiara}
    patterns:
      - include: "#function-calls"
      - include: "#sigil-function-calls"
      - match: '[?!:]:|[?!]?\.'
        name: punctuation.separator.namespace.kiara
      - include: "#brackets"
      - include: "#strings"
      - include: "#variables"

  symbols:
    patterns:
      - comment: quoted symbol
        applyEndPatternLast: true
        begin: (?<=^|\\.|['"`({\[)}\]\s]|(?:[)}\]\w\s'"`]|\\.)\s*[:=])(:)(?=[`'"])
        end: (?=)|$
        name: constant.language.symbol-type.kiara
        captures:
          1: {name: punctuation.definition.symbol.kiara}
        patterns:
          - include: "#strings-single-quoted"
          - include: "#strings-double-quoted"
          - include: "#strings-unquoted"
      - match: (?<=^|\\.|['"`({\[)}\]\s]|(?:[)}\]\w\s'"`]|\\.)\s*[:=])(:)(\b[\p{Pc}\p{L}]\w*\b)
        name: constant.other.symbol.kiara
        captures:
          1: {name: punctuation.definition.symbol.kiara}
          2: {name: constant.other.symbol.kiara}
        patterns:
          - include: "#string-escapes"

  strings-unquoted:
    comment: Unquoted string
    applyEndPatternLast: true
    begin: (`)
    end: (?=\W)|$
    name: string.template.kiara
    captures:
      1: {name: punctuation.definition.string.kiara}
    patterns:
      - match: \b\p{Pd}+\b
      - include: "#string-escapes"

  strings:
    patterns:
      - include: "#strings-prefixed"
      - include: "#strings-double-quoted"
      - include: "#strings-single-quoted"

  strings-single-quoted:
    patterns:
      - comment: single-quoted plain string
        begin: (?<!'+)((?i:\p{L}+))('''+|')\s*
        contentName: string.quoted.single.kiara
        end: \s*()(\2)(?!'+)
        captures:
          1: {name: storage.type.string.kiara}
          2: {name: punctuation.definition.string.kiara}
        patterns:
          - include: "#string-escapes"
      - comment: single-quoted plain string
        begin: (?<!'+)((?i:))('''+|')\s*
        contentName: string.quoted.single.kiara
        end: \s*()(\2)(?!'+)
        captures:
          1: {name: storage.type.string.kiara}
          2: {name: punctuation.definition.string.kiara}
        patterns:
          - include: "#string-escapes"

  strings-double-quoted:
    patterns:
      - comment: double-quoted plain string
        begin: (?<!"+)((?i:\p{L}+))("""+|")\s*
        contentName: string.quoted.double.kiara
        end: \s*()(\2)(?!"+)
        captures:
          1: {name: storage.type.string.kiara}
          2: {name: punctuation.definition.string.kiara}
        patterns:
          - include: "#string-escapes"
      - comment: double-quoted plain string
        begin: (?<!"+)((?i:))("""+|")\s*
        contentName: string.quoted.double.kiara
        end: \s*()(\2)(?!"+)
        captures:
          1: {name: storage.type.string.kiara}
          2: {name: punctuation.definition.string.kiara}
        patterns:
          - include: "#string-escapes"

  string-content:
    patterns:
      - include: "#string-escapes"
      - include: "#embedded"

  string-escapes:
    patterns:
      - begin: (\\)(?=\s*$)
        end: ^\s*(?=\S)
        captures:
          1: {name: constant.character.escape.newline.kiara}
      - include: "#named-escapes"
      - include: "#numeric-escapes"
      - match: \\([cm][a-z])
        name: constant.character.control.kiara
      - match: \\[abefprnstv]
        name: constant.character.escape.kiara
      - match: \\\p{S}
        name: constant.character.escape.symbol.kiara
      - match: \\\p{P}
        name: constant.character.escape.punctuation.kiara
      - match: \\[a-zA-Z\p{C}]
        name: invalid.illegal.escape.kiara
      - match: \\\s
        name: constant.character.escape.space.kiara
      - match: \\\p{L}
        name: constant.character.escape.letter.kiara
      - match: \\\p{N}
        name: constant.character.escape.number.kiara
      - match: \\.
        name: constant.character.escape.other.kiara

  named-characters:
    name: string.unquoted.plain.in.kiara
    comment: Grammar for the Unicode Named Character Mini-Language.
    patterns:
      - applyEndPatternLast: true
        name: constant.other.function.kiara
        begin: \b([\p{Pc}\p{L}]\w*\b([:.][\p{Pc}\p{L}]\w*)*)\b(?=\{)
        beginCaptures:
          1: {patterns: [include: "#function-namespace"]}
        end: (?=)|$
        patterns:
          - begin: (\{)
            end: (\})
            captures:
              1: {name: constant.other.function.kiara}
            patterns:
              - include: "#named-characters"
      - match: \b([\p{Pc}\p{L}]\w*\b([:.][\p{Pc}\p{L}]\w*)*)\b([;,]|(?=\W))
        name: constant.character.escape.kiara
        captures:
          1: {patterns: [include: "#character-namespace"]}
      - include: "#string-content"
      - include: "#punctuation"
      - include: "#illegal"

  function-namespace:
    patterns:
      - match: ([\p{Pc}\p{L}]\w*)\b(?=[.:])
        name: support entity.name.tag.namespace.kiara
      - match: ([\p{Pc}\p{L}]\w*)\b
        name: support entity.name.function.member.kiara

  character-namespace:
    patterns:
      - match: ([\p{Pc}\p{L}]\w*)\b(?=[.:])
        name: constant.other.character-class.kiara
      - match: ([\p{Pc}\p{L}]\w*)\b
        name: constant.character.escape.unicode.kiara

  named-escapes:
    patterns:
      - applyEndPatternLast: true
        name: constant.other.function.kiara
        begin: \\j([\p{Pc}\p{L}]\w*\b([:.][\p{Pc}\p{L}]\w*)*)\b(?=\{)
        beginCaptures:
          1: {patterns: [include: "#function-namespace"]}
        end: (?=)|$
        patterns:
          - begin: (\{)
            end: (\})
            captures:
              1: {name: constant.other.function.kiara}
            patterns:
              - include: "#named-characters"
      - match: \\j([\p{Pc}\p{L}]\w*\b([:.][\p{Pc}\p{L}]\w*)*)\b([;,]|(?=\W))
        name: constant.character.escape.kiara
        captures:
          1: {patterns: [include: "#character-namespace"]}
      - begin: \\j{\s*
        end: \s*}
        name: constant.other.character-class.unicode.kiara
        patterns:
          - applyEndPatternLast: true
            name: constant.other.function.kiara
            begin: \b([\p{Pc}\p{L}]\w*\b([:.][\p{Pc}\p{L}]\w*)*)\b(?=\{)
            beginCaptures:
              1: {patterns: [include: "#function-namespace"]}
            end: (?=)|$
            patterns:
              - begin: (\{)
                end: (\})
                captures:
                  1: {name: constant.other.function.kiara}
                patterns:
                  - include: "#named-characters"
          - match: \b([\p{Pc}\p{L}]\w*\b([:.][\p{Pc}\p{L}]\w*)*)\b([;,]|(?=\W))
            name: constant.character.escape.kiara
            captures:
              1: {patterns: [include: "#character-namespace"]}
          - include: "#string-content"
          - include: "#punctuation"
          - include: "#illegal"

  numeric-escapes:
    comments: |
      Hexadecimal escapes \u encode UTF-16 and 32  
      while \x encodes UTF-8 code points in addition  
      to Unicode characters.
    patterns:
      - comment: Binary escape sequences (0 to 417777)
        match: |
          (?x)
          \\b # prefix
            0* # leading zeroes
          (?: # numbers leading to 0001 0000 1111 1111 1111 1111
              10000[01]{16}
            | [01]{1,20}
          )
            (?![01])
        name: constant.character.escape.binary.kiara
      - comment: Decimal escape sequences
        match: |
          (?x)
          \\b # prefix
            [01]+
            (?![01])
        name: invalid.illegal.escape.binary.kiara
      - begin: \\b{
        end: \s*}
        name: constant.character.escape.binary.kiara
        patterns:
          - include: "#punctuation"
          - match: |
              (?x)
                \b
              0* # leading zeroes
              (?: # numbers leading to 0001 0000 1111 1111 1111 1111
                  10000[01]{16}
                | [01]{1,20}
              )
                (?![01])
            name: constant.character.escape.binary.kiara
          - include: "#illegal"

      - comment: Octal escape sequences (0 to 4177777)
        match: |
          (?x)
          \\o # prefix
            0* # leading zeroes
          (?: # numbers leading to 4177777
              4[01][0-7]{4}
            | [1-3][0-7]{5}
            | [1-7][0-7]{1,4}
            | [0-7]
          )
            (?![0-7])
        name: constant.character.escape.octal.kiara
      - comment: Octal escape sequences
        match: |
          (?x)
          \\o # prefix
            [0-7]+
            (?![0-7])
        name: invalid.illegal.escape.octal.kiara
      - begin: \\o{
        end: \s*}
        name: constant.character.escape.octal.kiara
        patterns:
          - include: "#punctuation"
          - match: |
              (?x)
                \b
              0* # leading zeroes
              ( # numbers up to 4177777
                  4[01][0-7]{4}
                | [1-3][0-7]{5}
                | [1-7][0-7]{1,4}
                | [0-7]
              )
                (?![0-7])
            name: constant.character.escape.octal.kiara
          - include: "#illegal"

      - comment: Duodecimal escapes (0 to 4588A7)
        match: |
          (?x)
          \\z # prefix
            0* # leading zeroes
          (?: # numbers leading to 4588A7
              4588 [\u218aatx] [0-7]
            | 4588 \d          [\d\u218a\u218babetx]
            | 458  [0-7]       [\d\u218a\u218babetx]{2}
            | 45   [0-7]       [\d\u218a\u218babetx]{3}
            | 4    [0-4]       [\d\u218a\u218babetx]{4}
            | [1-3]            [\d\u218a\u218babetx]{5}
            | [\d\u218a\u218babetx]{1,5}
          )
            (?![\d\u218a\u218babetx])
        name: constant.character.escape.duodecimal.kiara
      - comment: Duodecimal escape sequences
        match: |
          (?x)
          \\z # prefix
            [\d\u218a\u218babetx]+
            (?![\d\u218a\u218babetx])
        name: invalid.illegal.escape.duodecimal.kiara
      - begin: \\z{
        end: \s*}
        name: constant.character.escape.duodecimal.kiara
        patterns:
          - include: "#punctuation"
          - match: |
              (?x)
                \b
              0* # leading zeroes
              (?: # numbers up to 4588A7
                  4588 [\u218aatx] [0-7]
                | 4588 \d          [\d\u218a\u218babetx]
                | 458  [0-7]       [\d\u218a\u218babetx]{2}
                | 45   [0-7]       [\d\u218a\u218babetx]{3}
                | 4    [0-4]       [\d\u218a\u218babetx]{4}
                | [1-3]            [\d\u218a\u218babetx]{5}
                | [\d\u218a\u218babetx]{1,5}
              )
                (?![\d\u218a\u218babetx])
            name: constant.character.escape.duodecimal.kiara
          - include: "#illegal"

      - comment: Decimal escapes (0 to 1114111)
        match: |
          (?x)
          \\d? # prefix
            0* # leading zeroes
          (?: # numbers up to 1114111
              111411    [01]
            | 111410    \d
            | 11140     \d{2}
            | 111 [0-3] \d{3}
            | 110       \d{4}
            | 10        \d{5}
            | [1-9]     \d{1,5}
            | \d
          )
            (?!\d)
        name: constant.character.escape.decimal.kiara
      - comment: Decimal escape sequences
        match: |
          (?x)
          \\d? # prefix
            \d+
            (?!\d)
        name: invalid.illegal.escape.decimal.kiara
      - begin: \\d{
        end: \s*}
        name: constant.character.escape.decimal.kiara
        patterns:
          - include: "#punctuation"
          - match: |
              (?x)
                \b
              0* # leading zeroes
              (?: # numbers up to 1114111
                    111411    [01]
                  | 111410    \d
                  | 11140     \d{2}
                  | 111 [0-3] \d{3}
                  | 110       \d{4}
                  | 10        \d{5}
                  | [1-9]     \d{1,5}
                  | \d
              )
                (?!\d)
            name: constant.character.escape.decimal.kiara
          - include: "#illegal"

      - comment: Trailing byte pair U+80-U+BF
        match: |
          (?x)
            \\x # prefix
          (?i:
            0* # leading zeroes
            [89ab]\h
          )
            (?!\h)
        name: constant.character.escape.trailing.kiara
      - comment: Leading byte pair U+C0-U+FF
        match: |
          (?x)
            \\x # prefix
          (?i:
            0* # leading zeroes
            (?: # C0 to FF
                [c-f]\h
            )
          )
            (?!\h)
        name: constant.character.escape.leading.kiara
      - comment: Hexadecimal escape sequences
        match: |
          (?x)
            \\x # prefix
          (?i:
            0* # leading zeroes
            (?: # 0 to 10FFFF
                10\h{4}
              | [1-9a-f]\h{1,4}
              | \h
            )
          )
            (?!\h)
        name: constant.character.escape.hexadecimal.kiara
      - comment: Hexadecimal escape sequences
        match: |
          (?x)
          \\x # prefix
            \h+
            (?!\h)
        name: invalid.illegal.escape.hexadecimal.kiara
      - begin: \\x{
        end: \s*}
        name: constant.character.escape.hexadecimal.kiara
        patterns:
          - include: "#punctuation"
          - comment: Trailing byte pair U+80-U+BF
            match: |
              (?x)
                \b
              (?i:
                0* # leading zeroes
                [89ab]\h # 80 to BF
              )
                (?!\h)
            name: constant.character.escape.trailing.kiara
          - comment: Leading byte pair U+C0-U+FF
            match: |
              (?x)
                \b # prefix
              (?i:
                0* # leading zeroes
                (?: # C0 to FF
                    [c-f]\h
                )
              )
              (?!\h)
            name: constant.character.escape.leading.kiara
          - match: |
              (?x)
                \b
              (?i:
                0* # leading zeroes
                (?: # 0 to 10FFFF
                    10\h{4}
                  | [1-9a-f]\h{1,4}
                  | \h
                )
              )
                (?!\h)
            name: constant.character.escape.hexadecimal.kiara
          - include: "#illegal"

      - comment: Low surrogate pairs U+DC00-DFFF
        match: |
          (?x)
            \\u # prefix
          (?i:
            0* # leading zeroes
            d[c-f] \h{2}
          )
            (?!\h)
        name: constant.character.escape.surrogate.low.kiara
      - comment: High surrogate pairs U+D800-DBFF
        match: |
          (?x)
            \\u # prefix
          (?i:
            0* # leading zeroes
            d[89ab] \h{2}
          )
            (?!\h)
        name: constant.character.escape.surrogate.high.kiara
      - comment: Hexadecimal escape sequences
        match: |
          (?x)
            \\u # prefix
          (?i:
            0* # leading zeroes
            (?: # 0 to 10FFFF
                10\h{4}
              | [1-9a-f]\h{1,4}
              | \h
            )
          )
            (?!\h)
        name: constant.character.escape.unicode.kiara
      - comment: Unicode escape sequences
        match: |
          (?x)
          \\u # prefix
            \h+
            (?!\h)
        name: invalid.illegal.escape.unicode.kiara
      - comment: Unicode escape sequences
        match: |
          (?x)
            \\u # prefix
          (?i:
            0* # leading zeroes
            (?: # 0 to 10FFFF
                10\h{4}
              | [1-9a-f]\h{1,4}
              | \h
            )
            (?!\h)
          )
        name: constant.character.escape.unicode.kiara
      - comment: Unicode escapes
        begin: \\u{
        end: \s*}
        name: constant.character.escape.unicode.kiara
        patterns:
          - include: "#punctuation"
          - match: |
              (?x)
                \b
              (?i:
                0* # leading zeroes
                d [c-f] \h{2}
              )
                (?!\h)
            name: constant.character.escape.surrogate.low.kiara
          - match: |
              (?x)
                \b
              (?i:
                0* # leading zeroes
                d [89ab] \h{2}
              )
                (?!\h)
            name: constant.character.escape.surrogate.high.kiara
          - match: |
              (?x)
                \b
              (?i:
                0* # leading zeroes
                (?: # 0 to 10FFFF
                    10\h{4}
                  | [1-9a-f]\h{1,4}
                  | \h
                )
              )
                (?!\h)
            name: constant.character.escape.unicode.kiara
          - include: "#illegal"

  # Embedded expressions

  embedded:
    patterns:
      - include: "#embedded-expression"
      - include: "#embedded-format"
      - include: "#embedded-placeholder"

  embedded-verbatim:
    patterns:
      - match: \#\#|\$\$|\%\%
        name: constant.character.escape.kiara
      - include: "#embedded-expression"
      - include: "#embedded-format"
      - include: "#embedded-placeholder"

  embedded-expression:
    patterns:
      - comment: Interpolated expression
        begin: (\${)\s*
        end: \s*(})
        name: meta.embedded.expression.kiara
        captures:
          1: {name: punctuation.definition.variable.kiara}
        patterns:
          - include: $self
      - comment: Interpolated expression
        applyEndPatternLast: true
        name: meta.embedded.expression.kiara
        begin: |
          (?x)
          (\$) # beginning of identifier
          # ignore all keywords
          (?!
            (?<!(?:(?<!\.)\.|[?!:]:)=?)\b
            (?: # keywords
              in|of|as|is|new|delete
              |unset|ref|and|x?or|not
              |var|val|let|const|func
              |proc|method|type|class|crate
              |impl|enum|module|struct|field
              |union|iter|macro|query|elem
              |object|realm|trait|style|script
              |go|defer|do|with|from|where
              |if|unless|else|then|declare|ref
              |for|foreach|repeat|while|until
              |try|throw|catch|finally|switch
              |match|case|pass|default|goto|move
              |break|continue|redo|retry
              |return|yield|await|scope
              # |import|export|intern|extern
              |debug|assert|check
            )
            \b
          )
          (?=[\p{Pc}\p{L}]) # next to a word
        end: (?=)|$
        captures:
          1: {name: punctuation.definition.variable.kiara}
        patterns:
          - include: "#constants"
          - include: "#generics"
          - include: "#brackets"
          - include: "#embedded-function-calls"
          - match: (?<=>|\w)(!)(?=#?[({])
            captures:
              1: {name: keyword.operator.macro.kiara}
          - include: "#variables"
          - include: "#numbers"
          - *qualified-name-separators

  interpolated-code:
    patterns:
      - comment: Interpolated expression
        begin: (\#{)\s*
        end: \s*(})
        name: meta.embedded.expression.kiara
        captures:
          1: {name: punctuation.definition.variable.kiara}
        patterns:
          - include: $self
      - comment: Interpolated expression
        applyEndPatternLast: true
        name: meta.embedded.expression.kiara
        begin: |
          (?x)
          (\#) # beginning of identifier
          # ignore all keywords
          (?!
            (?<!(?:(?<!\.)\.|[?!:]:)=?)\b
            (?: # keywords
              in|of|as|is|new|delete
              |unset|ref|and|x?or|not
              |var|val|let|const|func
              |proc|method|type|class|crate
              |impl|enum|module|struct|field
              |union|iter|macro|query|elem
              |object|realm|trait|style|script
              |go|defer|do|with|from|where
              |if|unless|else|then|declare|ref
              |for|foreach|repeat|while|until
              |try|throw|catch|finally|switch
              |match|case|pass|default|goto|move
              |break|continue|redo|retry
              |return|yield|await|scope
              # |import|export|intern|extern
              |debug|assert|check
            )
            \b
          )
          (?=[\p{Pc}\p{L}]) # next to a word
        end: (?=)|$
        captures:
          1: {name: punctuation.definition.variable.kiara}
        patterns:
          - include: "#constants"
          - include: "#generics"
          - include: "#brackets"
          - include: "#embedded-function-calls"
          - include: "#variables"
          - include: "#numbers"
          - *qualified-name-separators

  embedded-placeholder:
    patterns:
      - name: meta.embedded.placeholder.kiara
        match: |
          (?x)
          (\#) # sigil
          (
            (?:
              (?:&|%|\$|~~?|\*\*?)? # sigil
              [!?]? # required or optional
            )?
            [+-]? \d+ # start of range
            (?:
              (?:[>.]\.[.<] | \.\. | [=.]\.[.=]|\.\.=?|=\.=) # range operator
              [+-]? \d+ # end of range
              (?:
                \.{1,3}
                [+-]? \d+ # increment
              )?
            )?
          )
        captures:
          1: {name: punctuation.definition.anchor.kiara}
          2:
            name: constant.numeric.decimal.kiara
            patterns:
              - match: "[+-]"
                name: keyword.operator.arithmetic.kiara
              - match: (?:[>.]\.[.<] | \.\. | [=.]\.[.=]|\.\.=?|=\.=)
                name: keyword.operator.range.kiara
      - name: meta.embedded.placeholder.kiara
        match: |
          (?x)
          (\#) # sigil
          (
            (?:
              (?:&|%|\$|~~?|\*\*?) # sigil
              [!?]? # required or optional
            )
            \b
              [\p{Pc}\p{L}]\w*
            \b
            |
            # ignore all keywords
            (?!
              (?<!(?:(?<!\.)\.|[?!:]:)=?)\b
              (?: # keywords
                in|of|as|is|new|delete
                |unset|ref|and|x?or|not
                |var|val|let|const|func
                |proc|method|type|class|crate
                |impl|enum|module|struct|field
                |union|iter|macro|query|elem
                |object|realm|trait|style|script
                |go|defer|do|with|from|where
                |if|unless|else|then|declare|ref
                |for|foreach|repeat|while|until
                |try|throw|catch|finally|switch
                |match|case|pass|default|goto|move
                |break|continue|redo|retry
                |return|yield|await|scope
                # |import|export|intern|extern
                |debug|assert|check
              )
              \b
            )
            \b
            [\p{Pc}\p{L}]\w* # identifier
            \b
          )
        captures:
          1: {name: punctuation.definition.anchor.kiara}
          2: {patterns: [include: "#placeholder-variables"]}
      - name: meta.embedded.placeholder.kiara
        begin: (\#{)\s*
        end: \s*(})
        captures:
          1: {name: punctuation.definition.anchor.kiara}
        patterns:
          - include: "#parameter-variables"
          - include: $self

  # Format and flag specifiers

  switch-clause:
    patterns:
      - comment: // for multiple flags at once with single-character aliases
        applyEndPatternLast: true
        begin: (?<=^|\\.|['"`({\[)}\]\s])(//)(?=[\p{Pc}\p{L}])
        end: (?=)|$
        captures:
          1: {name: punctuation.definition.flag.kiara}
        patterns:
          - comment: Format switch without value
            match: ([\p{Pc}\p{L}]\w*)
            captures:
              1: {name: keyword.other.flag.kiara}
      - comment: / for a single flag, with optional arguments
        applyEndPatternLast: true
        begin: (?<=^|\\.|['"`({\[)}\]\s])(/)(?=[\p{Pc}\p{L}])
        end: (?=)|$
        captures:
          1: {name: punctuation.definition.flag.kiara}
        patterns:
          - comment: Format switch without value
            match: ([\p{Pc}\p{L}]\w*)
            captures:
              1: {name: keyword.modifier.kiara}

  embedded-format:
    comment: Oniguruma supports only 20 levels of recursion
    applyEndPatternLast: true
    name: meta.embedded.formatting.kiara
    begin: (?<!%)(%)(?=[\p{Pc}\p{L}])
    end: (?=)|$
    captures:
      1: {name: punctuation.definition.directive.kiara}
    patterns:
      - include: "#format-syntax"

  format-syntax:
    comment: Format specifier language, inspired by MS-DOS, Bash and Python's f-strings.
    patterns:
      - comment: with optional value
        applyEndPatternLast: true
        begin: (?:(?<=%)|(\|))([\p{Pc}\p{L}]\w*)\b(:)
        end: (?=)|$
        name: storage.type.format.kiara
        captures:
          1: {name: punctuation.separator.mapping.kiara}
          2: {name: storage.type.format.kiara}
          3: {name: punctuation.separator.key-value.kiara}
        patterns:
          - include: "#constants"
          - include: "#generics"
          - include: "#brackets"
          - include: "#embedded-function-calls"
          - match: (?<=>|\w)(!)(?=#?[({])
            captures:
              1: {name: keyword.operator.macro.kiara}
          - include: "#variables"
          - include: "#numbers"
          - include: "#regexps"
          - include: "#symbols"
          - *qualified-name-separators
      - comment: type specifier
        match: (?:(?<=%)|(\|))([\p{Pc}\p{L}]\w*)\b
        name: storage.type.format.kiara
        captures:
          1: {name: punctuation.separator.mapping.kiara}
          2: {name: storage.type.format.kiara}

  # Regular expressions

  attribute-patterns:
    patterns:
      - applyEndPatternLast: true
        comment: Pattern section
        begin: (/>)\s*
        end: \s*(</)(\p{L}*)
        name: string.regexp.pattern.kiara
        captures:
          1: {name: punctuation.definition.regexp.kiara}
          2: {name: keyword.other.flag.kiara}
        patterns:
          - include: "#comments"
          - include: "#regexp-patterns"
          - comment: Replacement section
            begin: (</>)\s*
            end: \s*(?=</)
            name: string.regexp.replace.kiara
            captures:
              1: {name: punctuation.definition.regexp.kiara}
            patterns:
              - include: "#back-references"
              - include: "#string-content"
      - comment: Pattern section
        begin: (/)\s*
        end: \s*(/)(\p{L}*)
        name: string.regexp.pattern.kiara
        captures:
          1: {name: punctuation.definition.regexp.kiara}
          2: {name: keyword.other.flag.kiara}
        patterns:
          - include: "#regexp-patterns"

  regexps:
    applyEndPatternLast: true
    begin: |
      (?x)
      (?<=
        (?:
            # beginning of line
            ^
          | # separator
            [,;]
          | # opening bracket
            [({\[]
          | # postfix or infix operator
            [\p{S}\p{P}&&[^,;'"`({\[)}\]\p{Pc}]]+ \s
        ) \s*
        | # a keyword
        (?:
          (?:^|[,;'"({\[)}\]\s]) # beside a delimiter or space
          \b
            (?: # keywords
              in|of|as|is|new|delete
              |unset|ref|and|x?or|not
              |var|val|let|const|func
              |proc|method|type|class|crate
              |impl|enum|module|struct|field
              |union|iter|macro|query|elem
              |object|realm|trait|style|script
              |go|defer|do|with|from|where
              |if|unless|else|then|declare|ref
              |for|foreach|repeat|while|until
              |try|throw|catch|finally|switch
              |match|case|pass|default|goto|move
              |break|continue|redo|retry
              |return|yield|await|scope
              # |import|export|intern|extern
              |debug|assert|check
            )
          \b
        ) \s*
      ) \s*
      (?= />?)
    end: (?=)|$
    name: meta.regexp.kiara
    patterns:
      - applyEndPatternLast: true
        comment: Multi-line pattern section
        begin: (/>)\s*
        end: \s*(</)(\p{L}*)
        name: string.regexp.pattern.kiara
        captures:
          1: {name: punctuation.definition.regexp.kiara}
          2: {name: keyword.other.flag.kiara}
        patterns:
          - include: "#comments"
          - include: "#regexp-patterns"
          - comment: Multi-line replacement section
            begin: (</>)\s*
            end: \s*(</>)|\s*(?=</)
            name: string.regexp.replace.kiara
            captures:
              1: {name: punctuation.definition.regexp.kiara}
            patterns:
              - include: "#back-references"
              - include: "#string-content"
      - comment: Single-line pattern section
        begin: (/)\s*(?=(?:[^\\/]|\\.)+/\p{L}*)
        end: \s*(/)(\p{L}*)
        name: string.regexp.pattern.kiara
        captures:
          1: {name: punctuation.definition.regexp.kiara}
          2: {name: keyword.other.flag.kiara}
        patterns:
          - include: "#regexp-patterns"
          - comment: Single-line replacement section
            begin: (:)\s*
            end: \s*(\|)|\s*(?=/)
            name: string.regexp.replace.kiara
            captures:
              1: {name: punctuation.definition.regexp.kiara}
            patterns:
              - include: "#back-references"
              - include: "#string-content"

  fuzzy-expression:
    patterns:
      - include: "#punctuation"
      - include: "#comments"
      - include: "#function-calls"
      - include: "#literals"
      - include: "#embedded"
      - include: "#operators"
      - include: "#clauses"
      - include: "#declarations"
      - include: "#keywords"
      - include: "#fuzzy-brackets"
      - match: \b[\p{Pc}\p{L}]\w*\b
        name: keyword.other.unit.kiara
      - include: "#space"

  fuzzy-brackets:
    patterns:
      - begin: (\{)\s*
        end: \s*(\})
        captures:
          1: {name: punctuation.definition.mapping.kiara}
        patterns:
          - match: ","
            name: punctuation.separator.mapping.kiara
          - include: "#labels"
          - include: "#fuzzy-expression"
          - include: $self
      - begin: (\[)\s*
        end: \s*(\])
        captures:
          1: {name: punctuation.definition.array.kiara}
        patterns:
          - match: ","
            name: punctuation.separator.sequence.kiara
          - include: "#fuzzy-expression"
          - include: $self
      - begin: (\()\s*
        end: \s*(\))
        captures:
          1: {name: punctuation.definition.expression.kiara}
        patterns:
          - match: ","
            name: punctuation.separator.arguments.kiara
          - include: "#fuzzy-expression"
          - include: $self

  back-references:
    patterns:
      - match: \$(\d+[+-]?|[+-]\d*)
        name: keyword.other.back-reference.kiara
      - begin: (\$<)\s*
        end: \s*(>)
        name: keyword.other.back-reference.kiara
        captures:
          1: {name: keyword.other.back-reference.kiara}
        patterns: &regex-back-references
          - include: "#variables"
          - include: "#numbers"
          - include: "#operators"
          - include: "#string-content"
      - begin: (\$(['"]))\s*
        end: \s*(\2)
        name: keyword.other.back-reference.kiara
        captures:
          1: {name: keyword.other.back-reference.kiara}
        patterns: *regex-back-references

  regexp-patterns:
    comment: |
      See https://gist.github.com/CMCDragonkai/6c933f4a7d713ef712145c5eb94a1816
      and https://www.regular-expressions.info/
    patterns:
      - include: "#comments"
      - include: "#embedded"
      - include: "#strings"
      - match: \|
        name: keyword.operator.or.kiara
      - match: \&
        name: keyword.operator.compose.kiara
      - match: \.
        name: constant.character.all.kiara
      - match: (?i)\\[by](?:{(?:[^\\{}]|\\.)+})?
        name: keyword.control.anchor.kiara
      - match: (\\[aAm<]|\^+)(?:{(?:[^\\{}]|\\.)+})?
        name: keyword.control.begin.kiara
      - match: (\\[zZM>]|\$+)(?:{(?:[^\\{}]|\\.)+})?
        name: keyword.control.end.kiara}
      - match: \\K
        name: keyword.control.keep-out.kiara
      - match: \\G
        name: keyword.control.search.kiara
      - match: \\R
        name: constant.character.control.kiara
      - match: \\[XO]
        name: constant.character.unicode.kiara
      - match: \\\d+
        name: keyword.other.back-reference.kiara
      - match: \{\s*(?:\d*\s*,){,2}\s*\d*\s*}\s*(?:(\?)|(\+)|(\*))?
        captures:
          0: {name: keyword.operator.quantifier.kiara}
          1: {name: keyword.operator.modifier.lazy.kiara}
          2: {name: keyword.operator.modifier.eager.kiara}
          3: {name: keyword.operator.modifier.greedy.kiara}
      - match: (?:(\?)|(\+)|(\*))\s*(?:(\?)|(\+)|(\*))?
        captures:
          1: {name: keyword.operator.quantifier.lazy.kiara}
          2: {name: keyword.operator.quantifier.eager.kiara}
          3: {name: keyword.operator.quantifier.greedy.kiara}
          4: {name: keyword.operator.modifier.lazy.kiara}
          5: {name: keyword.operator.modifier.eager.kiara}
          6: {name: keyword.operator.modifier.greedy.kiara}
      - begin: (\\k<)
        end: \s*(>)
        name: constant.other.back-reference.kiara
        captures:
          1: {name: keyword.other.back-reference.kiara}
        patterns: *regex-back-references
      - begin: (\\g<)
        end: \s*(>)
        name: constant.other.subroutine.kiara
        captures:
          1: {name: keyword.other.subroutine.kiara}
        patterns: *regex-back-references
      - begin: (\\k('''+|"""+|['"]))
        end: \s*(\2)
        name: constant.other.back-reference.kiara
        captures:
          1: {name: keyword.other.back-reference.kiara}
        patterns: *regex-back-references
      - begin: (\\g('''+|"""+|['"]))
        end: \s*(\2)
        name: constant.other.subroutine.kiara
        captures:
          1: {name: keyword.other.subroutine.kiara}
        patterns: *regex-back-references
      - begin: ({)
        end: \s*(})
        name: meta.fuzzy.kiara
        captures:
          1: {name: punctuation.definition.fuzzy.kiara}
        patterns:
          - applyEndPatternLast: true
            begin: (?<=^|\\.|[,;'"`({\[)}\]\w\s])(:)
            beginCaptures:
              1: {name: punctuation.separator.key-value.kiara}
            end: (?=[,;}]|)|$
            patterns: &regexp-patterns
              - include: "#regexp-patterns"
          - include: "#fuzzy-expression"
      - match: \\[abefrntv]
        name: constant.character.escape.kiara
      - match: \\[wsdhulqmji]
        name: constant.other.character-class.kiara
      - match: \\[WSDHULQMJI]
        name: constant.other.character-class.negated.kiara
      - include: "#regexp-groups"
      - include: "#regexp-character-set"
      - include: "#regexp-character-class"
      - include: "#space"

  regexp-groups:
    patterns:
      - comment: Backtracking control verb
        begin: (\(\*([\p{Pc}\p{L}]\w*)?(:)?)
        end: \s*(\))
        name: meta.group.backtrack.kiara
        captures:
          1: {name: punctuation.section.expression.kiara}
          2: {name: keyword.control.kiara}
          3: {name: punctuation.separator.colon.kiara}
        patterns:
          - include: "#regexp-patterns"
      - comment: Block comment
        begin: (\()(\?#)
        contentName: comment.block.regexp.kiara
        end: \s*(\))
        name: comment.block.regexp.kiara
        captures:
          1: {name: punctuation.definition.comment.kiara}
        patterns:
          - match: \\.
            name: comment.block.regexp.kiara
      - comment: Lookahead assertion
        begin: (\(\?=)
        end: \s*(\))
        name: meta.group.look-ahead.kiara
        captures:
          1: {name: punctuation.definition.group.look-ahead.kiara}
        patterns:
          - include: "#regexp-patterns"
      - comment: Lookbehind assertion
        begin: (\(\?<=)
        end: \s*(\))
        name: meta.group.look-behind.kiara
        captures:
          1: {name: punctuation.definition.group.look-behind.kiara}
        patterns:
          - include: "#regexp-patterns"
      - comment: Negative lookahead assertion
        begin: (\(\?!)
        end: \s*(\))
        name: meta.group.negative-look-ahead.kiara
        captures:
          1:
            name: punctuation.definition.group.negative-look-ahead.kiara
        patterns: *regexp-patterns
      - comment: Negative lookbehind assertion
        begin: (\(\?<!)
        end: \s*(\))
        name: meta.group.negative-look-behind.kiara
        captures:
          1:
            name: punctuation.definition.group.negative-look-behind.kiara
        patterns:
          - include: "#regexp-patterns"
      - comment: Match directive Oniguruma supports only 20 levels of recursion
        begin: (?x)(\(\?)(?=%)
        captures:
          1: {name: punctuation.definition.group.directive.kiara}
        end: \s*(\))
        name: meta.group.directive.kiara
        patterns:
          - include: "#format-syntax"
          - include: "#regexp-patterns"
      - comment: Longest match
        begin: (\(\?/=?)
        end: \s*(\))
        name: meta.group.longest.kiara
        captures:
          1: {name: punctuation.definition.group.longest.kiara}
        patterns:
          - include: "#regexp-patterns"
      - comment: Back-reference groups
        begin: \((\?&(?:([+-]?\d+)|([\p{Pc}\p{L}]\w*)))(:)?
        end: \s*\)
        name: meta.group.back-reference.kiara
        captures:
          0: {name: punctuation.definition.group.back-reference.kiara}
          1: {name: punctuation.definition.group.back-reference.kiara}
          2: {name: constant.numeric.index.kiara}
          3: {patterns: [include: "#variables"]}
          4: {name: punctuation.separator.colon.kiara}
        patterns:
          - include: "#regexp-patterns"
      - comment: Back-reference groups
        begin: \((\?&)
        end: \s*\)
        name: meta.group.back-reference.kiara
        captures:
          0: {name: punctuation.definition.group.back-reference.kiara}
          1: {name: punctuation.definition.group.back-reference.kiara}
        patterns:
          - begin: (?<=\(\?&)('''+|"""+|['"])
            end: \s*(\1)
            name: constant.other.group.kiara
            captures:
              1: {name: punctuation.definition.group.back-reference.kiara}
            patterns: *regex-back-references
          - include: "#regexp-patterns"
      - comment: Flag modifier group
        begin: (\(\?\^?(?:([+-]?\d+?)|((?:[+-]\p{Lu}+)+|\p{Lu}+(?:[+-]\p{Lu}+)*)|((?:[+-]\p{Ll}+)+|\p{Ll}+(?:[+-]\p{Ll}+)*)))\s*(:)?
        end: \s*(\))
        name: meta.group.flag.kiara
        captures:
          0: {name: punctuation.definition.group.flag.kiara}
          1: {name: punctuation.definition.group.flag.kiara}
          2: {name: constant.numeric.index.kiara}
          3: {name: keyword.control.recursion.kiara}
          4: {name: keyword.other.flag.kiara}
          5: {name: punctuation.separator.colon.kiara}
        patterns:
          - include: "#regexp-patterns"
      - comment: Call-outs
        begin: (\(\?)(?={)
        end: \s*(\))
        name: meta.group.call-out.kiara
        captures:
          1: {name: punctuation.definition.group.call-out.kiara}
        patterns:
          - begin: (?<=\(\?)({)
            end: \s*(\})\s*([<*>])?(?:(\[)(.*?)(\]))?
            name: punctuation.definition.group.call-out.kiara
            captures:
              1: {name: punctuation.definition.group.call-out.kiara}
              2: {name: keyword.operator.range.kiara}
              3: {name: punctuation.definition.tag.kiara}
              4: {patterns: [include: "#function-names"]}
              5: {name: punctuation.definition.tag.kiara}
            patterns:
              - include: $self
          - include: "#regexp-patterns"
      - comment: Atomic groups
        begin: (\(\?>)
        end: \s*(\))
        name: meta.group.atomic.kiara
        captures:
          1: {name: punctuation.definition.group.atomic.kiara}
        patterns:
          - include: "#regexp-patterns"
      - comment: Non-capturing groups
        begin: (\(\?:)
        end: \s*(\))
        name: meta.group.non-capturing.kiara
        captures:
          1: {name: punctuation.definition.group.non-capturing.kiara}
        patterns:
          - include: "#regexp-patterns"
      - comment: Branch groups
        begin: (\(\?)(?=[(|])
        end: \s*(\))
        name: meta.group.branch.kiara
        captures:
          1: {name: punctuation.definition.group.branch.kiara}
        patterns:
          - include: "#regexp-patterns"
      - comment: Absent groups
        begin: (\(\?~)
        end: \s*(\))
        name: meta.group.absent.kiara
        captures:
          1: {name: punctuation.definition.group.absent.kiara}
        patterns:
          - include: "#regexp-patterns"
      - comment: Named groups (angle brackets)
        begin: \(\?(?=<(?![!=]))
        end: \s*(\))
        name: meta.group.named.kiara
        captures:
          0: {name: punctuation.definition.group.named.kiara}
        patterns:
          - begin: (?<=\(\?)(<)
            end: \s*(>)
            name: constant.other.group.kiara
            captures:
              1: {name: punctuation.definition.group.named.kiara}
            patterns: *regex-back-references
          - include: "#regexp-patterns"
      - comment: Named groups (single or double-quotes)
        begin: \(\?(?=['"])
        end: \s*(\))
        name: meta.group.named.kiara
        captures:
          0: {name: punctuation.definition.group.named.kiara}
        patterns:
          - begin: (?<=\(\?)('''+|"""+|['"])
            end: \s*(\1)
            name: constant.other.group.kiara
            captures:
              1: {name: punctuation.definition.group.named.kiara}
            patterns: *regex-back-references
          - include: "#regexp-patterns"
      - comment: Unnamed groups
        begin: (\()
        end: (\s*\))
        name: meta.group.kiara
        captures:
          1: {name: punctuation.definition.group.kiara}
        patterns:
          - include: "#regexp-patterns"

  regexp-character-class:
    patterns:
      - include: "#embedded"
      - begin: (\\)(?=\s*$)
        end: ^\s*(?=\S)
        captures:
          1: {name: constant.character.escape.newline.kiara}
      - include: "#named-escapes"
      - include: "#numeric-escapes"
      - begin: (?i)\\p{
        end: \s*}
        name: constant.other.character-class.unicode.kiara
        patterns:
          - include: "#attribute-selectors"
      - match: (?i)\\([cm][a-z])
        name: constant.character.control.kiara
      - match: (?i)\\p[a-z]{1,2}
        name: constant.other.character-class.unicode.kiara
      - match: (?i)\\[ci]({\w+})?
        name: constant.other.character-class.xml.kiara
      - match: (?i)\\n{(?:[^\\{}]|\\.)+}
        name: constant.character.escape.unicode.name.kiara
      - match: \\[abefprntv]
        name: constant.character.escape.kiara
      - match: \\[a-z]
        name: constant.other.character-class.kiara
      - match: \\[A-Z]
        name: constant.other.character-class.negated.kiara
      - match: \\\p{S}
        name: constant.character.escape.symbol.kiara
      - match: \\\p{P}
        name: constant.character.escape.punctuation.kiara
      - match: \\[a-zA-Z\p{C}]
        name: invalid.illegal.escape.kiara
      - match: \\\s
        name: constant.character.escape.space.kiara
      - match: \\\p{L}
        name: constant.character.escape.letter.kiara
      - match: \\\p{N}
        name: constant.character.escape.number.kiara
      - match: \\.
        name: constant.character.escape.other.kiara

  regexp-character-operators:
    patterns:
      - match: |
          (?x)
          ( # from
              \\(?:d?\d+|d{[\d\s,;]+}) # decimal escape
            | \\[xu](?:\h+|{[\h\s,;]+}) # hex escape
            | \\z(?:[\d\u218a\u218babetx]+|{[\d\u218a\u218babetx\s,;]+}) # duodecimal escape
            | \\o(?:[0-7]+|{[0-7\s,;]+}) # octal escape
            | \\b(?:[01]+|{[01\s,;]+}) # binary escape
            | \\[cm][a-z] # meta-character
            | \\n{(?:[^\\{}]|\\.)+} # Unicode named character
            | \\(?:[abefprntv]|[^a-zA-Z]) # any escape character
            | [^-\\\[\]] # any unescaped character
          )
            \s*
              (-|->|>-|>>) # range
            \s*
          ( # to
              \\(?:d?\d+|d{[\d\s,;]+}) # decimal escape
            | \\[xu](?:\h+|{[\h\s,;]+}) # hex escape
            | \\z(?:[\d\u218a\u218babetx]+|{[\d\u218a\u218babetx\s,;]+}) # duodecimal escape
            | \\o(?:[0-7]+|{[0-7\s,;]+}) # octal escape
            | \\b(?:[01]+|{[01\s,;]+}) # binary escape
            | \\[cm][a-z] # meta-character
            | \\n{(?:[^\\{}]|\\.)+} # Unicode named character
            | \\(?:[abefprntv]|[^a-zA-Z]) # any escape character
            | [^-\\\[\]] # any unescaped character
          ) (?:
              \s*
                (:) # range
              \s*
            ( # to
                \d+ # number
              | \\(?:d?\d+|d{[\d\s,;]+}) # decimal escape
              | \\[xu](?:\h+|{[\h\s,;]+}) # hex escape
              | \\z(?:[\d\u218a\u218babetx]+|{[\d\u218a\u218babetx\s,;]+}) # duodecimal escape
              | \\o(?:[0-7]+|{[0-7\s,;]+}) # octal escape
              | \\b(?:[01]+|{[01\s,;]+}) # binary escape
              | \\[cm][a-z] # meta-character
              | \\n{(?:[^\\{}]|\\.)+} # Unicode named character
              | \\(?:[abefprntv]|[^a-zA-Z]) # any escape character
              | [^-\\\[\]] # any unescaped character
            )
          )?
        captures:
          1:
            name: constant.other.character-class.range.from.kiara
            patterns:
              - include: "#regexp-character-operators"
              - include: "#regexp-character-class"
          2:
            name: keyword.operator.range.kiara
          3:
            name: constant.other.character-class.range.to.kiara
            patterns:
              - include: "#regexp-character-operators"
              - include: "#regexp-character-class"
          4:
            name: keyword.operator.range.kiara
          5:
            name: constant.other.character-class.range.by.kiara
            patterns:
              - include: "#numbers"
              - include: "#regexp-character-operators"
              - include: "#regexp-character-class"
      - match: \|\|
        name: keyword.operator.union.kiara
      - match: \&&
        name: keyword.operator.intersection.kiara
      - match: \^\^
        name: keyword.operator.symmetric.kiara
      - match: ~~
        name: keyword.operator.negation.kiara
      - match: --
        name: keyword.operator.difference.kiara

  regexp-character-set:
    patterns:
      - begin: (\[:)
        end: \s*(:\])
        name: constant.other.character-set.posix.kiara
        captures:
          1: {name: punctuation.definition.character-class.posix.kiara}
        patterns:
          - include: "#attribute-selectors"
      - begin: (\[\^)
        end: \s*(\])
        name: constant.other.character-set.negated.kiara
        captures:
          1:
            name: punctuation.definition.character-class.negated.kiara
        patterns:
          - include: "#comments"
          - include: "#regexp-character-operators"
          - include: "#regexp-character-class"
          - include: "#regexp-character-set"
      - begin: (\[)
        end: \s*(\])
        name: constant.other.character-set.kiara
        captures:
          1: {name: punctuation.definition.character-class.kiara}
        patterns:
          - include: "#comments"
          - include: "#regexp-character-operators"
          - include: "#regexp-character-class"
          - include: "#regexp-character-set"

  attribute-selectors:
    name: meta.attribute-selector.kiara
    patterns:
      - match: "[:!=</>.^$%?*+|&~]?="
        name: keyword.operator.pattern.kiara
      - match: \&\&|\|\||\^\^|\!
        name: keyword.operator.logical.kiara
      - match: ","
        name: punctuation.separator.sequence.kiara
      - match: \b(in|is)\b
        name: keyword.operator.expression.$1.kiara
      - begin: \b([\p{Pc}\p{L}]\w*)\b([:!=</>.^$%?*+|&~]?=)
        beginCaptures:
          1: {name: entity.other.attribute-name.key.kiara}
          2: {name: keyword.operator.pattern.kiara}
        end: (?=\&\&|\|\||\^\^|[\s,:;'"`)}\]]|\\.)
        name: string.unquoted.attribute-name.kiara
        patterns:
          - include: "#regexp-patterns"
      - match: (?xi)\b[is]\b\s*(?=[)}\]]|([&|^])\1)
        name: storage.modifier.ignore-when.kiara
      - include: "#string-escapes"
      - comment: Attribute names
        match: \b([\p{Pc}\p{L}]\w*)\b
        captures:
          1: {name: entity.other.attribute-name.kiara}
          2: {name: keyword.operator.pattern.kiara}
      - include: "#comments"
      - include: "#operators"

  # JSX and Markdown

  jsx:
    applyEndPatternLast: true
    comment: Only captured when next to opening brackets, commas, semicolons, keywords, and operators. JSX also supports functional components, so we need to be careful to also match those.
    begin: |
      (?x)
      (?<=
        (?:
            # beginning of line
            ^
          | # separator
            [,;]
          | # opening bracket
            [({\[]
          | # postfix or infix operator
            [\p{S}\p{P}&&[^,;'"`({\[)}\]\p{Pc}]]+ \s
        ) \s*
        | # a keyword
        (?:
          (?:^|[,;'"({\[)}\]\s]) # beside a delimiter or space
          \b
            (?: # keywords
              in|of|as|is|new|delete
              |unset|ref|and|x?or|not
              |var|val|let|const|func
              |proc|method|type|class|crate
              |impl|enum|module|struct|field
              |union|iter|macro|query|elem
              |object|realm|trait|style|script
              |go|defer|do|with|from|where
              |if|unless|else|then|declare|ref
              |for|foreach|repeat|while|until
              |try|throw|catch|finally|switch
              |match|case|pass|default|goto|move
              |break|continue|redo|retry
              |return|yield|await|scope
              # |import|export|intern|extern
              |debug|assert|check
            )
          \b
        ) \s*
      ) \s*
      (?=<[>\p{Pc}\p{L}])
    end: (?=)|$
    patterns:
      - include: "#tag-component-name"

  tag-component-name:
    patterns:
      - comment: JSX Fragment
        contentName: text.html.fragment.kiara
        begin: (<)(?=>)
        end: (?<=</)(>)
        beginCaptures:
          1: {name: punctuation.definition.tag.kiara}
        endCaptures:
          1: {name: punctuation.definition.tag.kiara}
        patterns:
          - include: "#tag-termination"
      - comment: Tags that end > are trapped in tag-termination
        contentName: text.html.kiara
        begin: |
          (?x)
          (<) # start tag begin
          (
            (?:
              \b
              [\p{Pc}\p{L}]\w* # identifier
              \b
              (?:[?!:]:|[?!]?\.) # qualified name separator
            )*
            [\p{Pc}\p{L}]\w* # last part of identifier
            \b
          )
          (?=[,;'"`({\[)}\]/>\s])
        end: |
          (?x) \s*
          (?:
              (?<=</)(\2)(>)
            | (<?/>)
            | ((?<=</)\O*?)>
          )
        beginCaptures:
          1: {name: punctuation.definition.tag.kiara}
          2: {patterns: [include: "#tag-names"]}
        endCaptures:
          1: {patterns: [include: "#tag-names"]}
          2: {name: punctuation.definition.tag.kiara}
          3: {name: punctuation.definition.tag.kiara}
          4: {name: invalid.illegal.termination.kiara}
        patterns:
          - include: "#tag-termination"
          - include: "#tag-attributes"

  jsx-comments:
    begin: (<!--)
    end: (-->)
    captures:
      1: {name: punctuation.definition.comment.kiara}
    name: comment.block.html.kiara
    patterns:
      - include: "#jsx-comments"

  tag-termination:
    comment: uses non consuming search for </ in </tag>
    contentName: meta.jsx.children.kiara
    begin: (>)
    end: (</)
    captures:
      0: {name: punctuation.definition.tag.kiara}
    patterns:
      - include: "#evaluated-code"
      - include: "#jsx-entities"
      - include: "#tag-component-name"
      - include: "#markdown"
      - include: "#jsx-comments"

  tag-attributes:
    patterns:
      - include: "#literals"
      - include: "#embedded-expression"
      - include: "#brackets"
      - applyEndPatternLast: true
        begin: \s*(=)\s*
        beginCaptures:
          1: {name: punctuation.separator.key-value.kiara}
        end: (?=)|$
        name: meta.property.jsx.kiara
        patterns:
          - include: "#style-property-values"
      - include: "#style-selectors"
      - include: "#attribute-names"
      - include: "#comments"
      - include: "#punctuation"

  attribute-names:
    match: \s*([\p{Pd}\w]+)\b\s*
    name: meta.attribute.kiara
    captures:
      1:
        name: entity.other.attribute-name.${1:/camelcase}.kiara
        patterns:
          - include: "#css-property-names"

  spread-attribute:
    comment: Spread attribute { ... AssignmentExpression }
    match: (?<!\*)\*(?!\*)
    name: keyword.operator.spread.kiara

  jsx-entities:
    patterns:
      - captures: &jsx-entities
          1: {name: punctuation.definition.entity.kiara}
          2: {name: punctuation.definition.entity.kiara}
        match: (&)#\d+(;)
        name: constant.character.escape.decimal.kiara
      - captures: *jsx-entities
        match: (?i)(&)#x\h+(;)
        name: constant.character.escape.hexadecimal.kiara
      - captures: *jsx-entities
        match: (?i)(&)#b[01]+(;)
        name: constant.character.escape.binary.kiara
      - captures: *jsx-entities
        match: (?i)(&)#o[0-7]\h+(;)
        name: constant.character.escape.octal.kiara
      - captures: *jsx-entities
        match: (&)(?:\\.|[^({\[)}\]\s;])+?(;)
        name: constant.character.entity.xml
      - match: '&(?=\w*;)'
        name: invalid.illegal.ambiguous-ampersand.kiara
      - comment: Entity with & and invalid name
        match: '&\s*+;'
        name: invalid.illegal.bad-ampersand.kiara

  inline-markdown:
    patterns:
      - include: "#ampersand"
      - include: "#bracket"
      - include: "#bold"
      - include: "#italic"
      - include: "#raw"
      - include: "#escape"
      - include: "#image-inline"
      - include: "#image-ref"
      - include: "#link-email"
      - include: "#link-inet"
      - include: "#link-inline"
      - include: "#link-ref"
      - include: "#link-ref-literal"
      - include: "#link-ref-shortcut"

  ampersand:
    comment: Markdown will convert this for us. We match it so that the HTML grammar will not mark it up as invalid.
    match: '&(?!([a-zA-Z\d]+|#[\d]+|#x\h+);)'
    name: meta.other.valid-ampersand.markdown

  bold:
    begin: |
      (?x)
      (?<open>(\*\*(?=\w)|(?<!\w)\*\*|(?<!\w)\b__))(?=\S)
      (?=
        (
          <[^>]*+> # HTML tags
          | (?<raw>`+)([^`]|(?!(?<!`)\k<raw>(?!`))`)*+\k<raw>
          # Raw
          | \\[\\`*_{}\[\]() #.!+\->]?+ # Escapes
          | \[
          (
              (?<square> # Named group
                [^\[\]\\] # Match most chars
                | \\. # Escaped chars
                | \[ \g<square>*+ \] # Nested brackets
              )*+
            \]
            (
              ( # Reference Link
                [ ]? # Optional space
                \[[^\]]*+\] # Ref name
              )
              | ( # Inline Link
                \( # Opening paren
                  [ \t]*+ # Optional whitespace
                  <?(.*?)>? # URL
                  [ \t]*+ # Optional whitespace
                  ( # Optional Title
                    (?<title>['"])
                    (.*?)
                    \k<title>
                  )?
                \)
              )
            )
          )
          | (?!(?<=\S)\k<open>). # Everything besides
          # style closer
        )++
        (?<=\S)(?=__\b|\*\*)\k<open> # Close
      )
    captures:
      1: {name: punctuation.definition.bold.markdown}
    end: (?<=\S)(\1)
    name: markup.bold.markdown
    patterns:
      - include: "#string-content"
      - include: "#escape"
      - include: "#ampersand"
      - include: "#bracket"
      - include: "#raw"
      - include: "#bold"
      - include: "#italic"
      - include: "#image-inline"
      - include: "#link-inline"
      - include: "#link-inet"
      - include: "#link-email"
      - include: "#image-ref"
      - include: "#link-ref-literal"
      - include: "#link-ref"
      - include: "#link-ref-shortcut"

  bracket:
    comment: Markdown will convert this for us. We match it so that the HTML grammar will not mark it up as invalid.
    match: <(?![a-zA-Z/?\$!])
    name: meta.other.valid-bracket.markdown

  escape:
    match: \\[-`*_#+.!({\[)}\]\\>]
    name: constant.character.escape.markdown

  image-inline:
    captures:
      1: {name: punctuation.definition.string.begin.markdown}
      2: {name: string.other.link.description.markdown}
      4: {name: punctuation.definition.string.end.markdown}
      5: {name: punctuation.definition.metadata.markdown}
      6: {name: punctuation.definition.link.markdown}
      7: {name: markup.underline.link.image.markdown}
      8: {name: punctuation.definition.link.markdown}
      9: {name: string.other.link.description.title.markdown}
      10: {name: punctuation.definition.string.markdown}
      11: {name: punctuation.definition.string.markdown}
      12: {name: string.other.link.description.title.markdown}
      13: {name: punctuation.definition.string.markdown}
      14: {name: punctuation.definition.string.markdown}
      15: {name: string.other.link.description.title.markdown}
      16: {name: punctuation.definition.string.markdown}
      17: {name: punctuation.definition.string.markdown}
      18: {name: punctuation.definition.metadata.markdown}
    match: |
      (?x)
      (\!\[)((?<square>[^\[\]\\]|\\.|\[\g<square>*+\])*+)(\])
      # Match the link text.
      (\() # Opening paren for url
        (<?)(\S+?)(>?) # The url
        [ \t]* # Optional whitespace
        (?:
            ((\().+?(\))) # Match title in parens...
          | ((").+?(")) # or in double quotes...
          | ((').+?(')) # or in single quotes.
        )? # Title is optional
        \s* # Optional whitespace
      (\))
    name: meta.image.inline.markdown

  image-ref:
    captures:
      1: {name: punctuation.definition.string.begin.markdown}
      2: {name: string.other.link.description.markdown}
      4: {name: punctuation.definition.string.begin.markdown}
      5: {name: punctuation.definition.constant.markdown}
      6: {name: constant.other.reference.link.markdown}
      7: {name: punctuation.definition.constant.markdown}
    match: (\!\[)((?<square>[^\[\]\\]|\\.|\[\g<square>*+\])*+)(\])[ ]?(\[)(.*?)(\])
    name: meta.image.reference.markdown
    patterns:
      - include: "#string-content"

  italic:
    begin: |
      (?x) (?<open>(\*(?=\w)|(?<!\w)\*|(?<!\w)\b_))(?=\S) # Open
      (?=
        (
          <[^>]*+> # HTML tags
          | (?<raw>`+)([^`]|(?!(?<!`)\k<raw>(?!`))`)*+\k<raw>
          # Raw
          | \\[\\`*_{}\[\]() #.!+\->]?+ # Escapes
          | \[
          (
              (?<square> # Named group
                [^\[\]\\] # Match most chars
                | \\. # Escaped chars
                | \[ \g<square>*+ \] # Nested brackets
              )*+
            \]
            (
              ( # Reference Link
                [ ]? # Optional space
                \[[^\]]*+\] # Ref name
              )
              | ( # Inline Link
                \( # Opening paren
                  [ \t]*+ # Optional whitespace
                  <?(.*?)>? # URL
                  [ \t]*+ # Optional whitespace
                  ( # Optional Title
                    (?<title>['"])
                    (.*?)
                    \k<title>
                  )?
                \)
              )
            )
          )
          | \k<open>\k<open> # Must be bold closer
          | (?!(?<=\S)\k<open>). # Everything besides
          # style closer
        )++
        (?<=\S)(?=_\b|\*)\k<open> # Close
      )
    captures:
      1: {name: punctuation.definition.italic.markdown}
    end: (?<=\S)(\1)((?!\1)|(?=\1\1))
    name: markup.italic.markdown
    patterns:
      - include: "#string-content"
      - include: "#escape"
      - include: "#ampersand"
      - include: "#bracket"
      - include: "#raw"
      - include: "#bold"
      - include: "#image-inline"
      - include: "#link-inline"
      - include: "#link-inet"
      - include: "#link-email"
      - include: "#image-ref"
      - include: "#link-ref-literal"
      - include: "#link-ref"
      - include: "#link-ref-shortcut"

  link-email:
    captures:
      1: {name: punctuation.definition.link.markdown}
      2: {name: markup.underline.link.markdown}
      4: {name: punctuation.definition.link.markdown}
    match: (<)((?:mailto:)?[a-zA-Z\d.!#$%&'*+/=?^_`{|}~-]+@[a-zA-Z\d-]+(?:\.[a-zA-Z\d-]+)*)(>)
    name: meta.link.email.lt-gt.markdown
    patterns:
      - include: "#string-content"

  link-inet:
    captures:
      1: {name: punctuation.definition.link.markdown}
      2: {name: markup.underline.link.markdown}
      3: {name: punctuation.definition.link.markdown}
    match: (<)((?:https?|ftp)://.*?)(>)
    name: meta.link.inet.markdown
    patterns:
      - include: "#string-content"

  link-inline:
    captures:
      1: {name: punctuation.definition.string.begin.markdown}
      2: {name: string.other.link.title.markdown}
      4: {name: punctuation.definition.string.end.markdown}
      5: {name: punctuation.definition.metadata.markdown}
      6: {name: punctuation.definition.link.markdown}
      7: {name: markup.underline.link.markdown}
      9: {name: punctuation.definition.link.markdown}
      10: {name: string.other.link.description.title.markdown}
      11: {name: punctuation.definition.string.begin.markdown}
      12: {name: punctuation.definition.string.end.markdown}
      13: {name: string.other.link.description.title.markdown}
      14: {name: punctuation.definition.string.begin.markdown}
      15: {name: punctuation.definition.string.end.markdown}
      16: {name: string.other.link.description.title.markdown}
      17: {name: punctuation.definition.string.begin.markdown}
      18: {name: punctuation.definition.string.end.markdown}
      19: {name: punctuation.definition.metadata.markdown}
    match: |
      (?x)
      (\[)((?<square>[^\[\]\\]|\\.|\[\g<square>*+\])*+)(\])
      # Match the link text.
      (\() # Opening paren for url
        (<?)((?<url>(?>[^\s()]+)|\(\g<url>*\))*)(>?) # The url
        [ \t]* # Optional whitespace
        (?:
            ((\().+?(\))) # Match title in parens...
          | ((").+?(")) # or in double quotes...
          | ((').+?(')) # or in single quotes.
        )? # Title is optional
        \s* # Optional whitespace
      (\))
    name: meta.link.inline.markdown
    patterns:
      - include: "#string-content"

  link-ref:
    captures:
      1: {name: punctuation.definition.string.begin.markdown}
      2: {name: string.other.link.title.markdown}
      4: {name: punctuation.definition.string.end.markdown}
      5: {name: punctuation.definition.constant.begin.markdown}
      6: {name: constant.other.reference.link.markdown}
      7: {name: punctuation.definition.constant.end.markdown}
    match: (\[)((?<square>[^\[\]\\]|\\.|\[\g<square>*+\])*+)(\])(\[)([^\]]*+)(\])
    name: meta.link.reference.markdown
    patterns:
      - include: "#string-content"

  link-ref-literal:
    captures:
      1: {name: punctuation.definition.string.begin.markdown}
      2: {name: string.other.link.title.markdown}
      4: {name: punctuation.definition.string.end.markdown}
      5: {name: punctuation.definition.constant.begin.markdown}
      6: {name: punctuation.definition.constant.end.markdown}
    match: (\[)((?<square>[^\[\]\\]|\\.|\[\g<square>*+\])*+)(\])[ ]?(\[)(\])
    name: meta.link.reference.literal.markdown
    patterns:
      - include: "#string-content"

  link-ref-shortcut:
    captures:
      1: {name: punctuation.definition.string.begin.markdown}
      2: {name: string.other.link.title.markdown}
      3: {name: punctuation.definition.string.end.markdown}
    match: (\[)(\S+?)(\])
    name: meta.link.reference.markdown
    patterns:
      - include: "#string-content"

  raw:
    captures:
      1: {name: punctuation.definition.raw.markdown}
      2: {patterns: [include: "#string-content"]}
      3: {name: punctuation.definition.raw.markdown}
    match: (`+)([^`]|(?!(?<!`)\1(?!`))`)*+(\1)
    name: markup.inline.raw.string.markdown
    patterns:
      - include: "#string-content"

  markdown:
    patterns:
      - include: "#comments"
      - include: "#jsx-entities"
      - include: "#html-tag"
      - include: "#string-content"
      - include: "#evaluated-code"
      - include: "#executed-code"
      - include: "#inline-styles"
      - include: "#blockquote"
      - include: "#unordered-list"
      - include: "#ordered-list"
      - include: "#inline-markdown"

    repository:
      blockquote:
        comment: "> blockquote"
        begin: ^\s*(\>)(\s+.*)\n*
        end: ^(?=\S)|(?!\G)
        beginCaptures:
          1: {name: punctuation.definition.quote.begin.markdown}
          2:
            name: markup.quote.markdown
            patterns: [include: "#markdown"]
        name: markup.quote.markdown
        patterns:
          - begin: ^(\s+)(?!\s)
            end: ^(?!\1|\s*$)
            name: markup.quote.markdown
            patterns: [include: "#markdown"]

      unordered-list:
        comment: "- unordered list"
        begin: ^\s*(\-)(?!>)\s+(.*)\n*
        end: ^(?=\S)|(?!\G)
        beginCaptures:
          1: {name: punctuation.definition.list.begin.markdown}
          2:
            name: markup.list.unnumbered.markdown
            patterns: [include: "#markdown"]
        name: markup.list.unnumbered.markdown
        patterns:
          - begin: ^(\s+)(?!\s)
            end: ^(?!\1|\s*$)
            name: markup.list.unnumbered.markdown
            patterns: [include: "#markdown"]

      ordered-list:
        comment: "+ ordered list"
        begin: ^\s*(\+)(?!>)\s+(.*)\n*
        end: ^(?=\S)|(?!\G)
        beginCaptures:
          1: {name: punctuation.definition.list.begin.markdown}
          2:
            name: markup.list.numbered.markdown
            patterns: [include: "#markdown"]
        name: markup.list.numbered.markdown
        patterns:
          - begin: ^(\s+)(?!\s)
            end: ^(?!\1|\s*$)
            name: markup.list.numbered.markdown
            patterns: [include: "#markdown"]

      evaluated-code:
        applyEndPatternLast: true
        comment: Evaluated code
        begin: (?<=^|[\w\s'"`])(=>)
        end: (?=|$)
        captures:
          1: {name: storage.type.method.kiara}
        patterns:
          - include: $self

      executed-code:
        applyEndPatternLast: true
        comment: Executed code
        begin: (?<=^|[\w\s'"`])(->)
        end: (?=|$)
        captures:
          1: {name: storage.type.subroutine.kiara}
        patterns:
          - include: $self

      html-tag:
        comment: <Tags
        applyEndPatternLast: true
        begin: (?<=^|[\w\s'"`])(<)\b
        end: (<?>?=?)|(?=)|$
        name: meta.tag.kiara
        captures:
          1: {name: punctuation.definition.tag.kiara}
        patterns:
          - comment: Tag name
            match: (?<=<)\b([\p{Pc}\p{L}]\w*\b(?:(?:[?!:]:|[?!]?\.)[\p{Pc}\p{L}]\w*)*)\b
            captures:
              1:
                name: entity.name.tag.kiara
                patterns: *html-tag-names
          - comment: ID
            match: (?<=#)\b([\p{Pc}\p{L}]\w*)\b
            name: entity.other.attribute-name.id.kiara
          - comment: Class
            match: (?<=\.)\b([\p{Pc}\p{L}]\w*)\b
            name: entity.other.attribute-name.class.kiara
          - begin: (\[)\s*
            end: \s*(\])\s*
            captures:
              1: {name: punctuation.definition.directive.kiara}
            patterns:
          - include: $self
          - begin: (\{)\s*
            end: \s*(\})\s*
            captures:
              1: {name: punctuation.definition.mapping.kiara}
            patterns:
              - include: "#style-properties"
              - include: $self
          - begin: (\()\s*
            end: \s*(\))
            captures:
              1: {name: punctuation.definition.parameters.kiara}
            patterns:
              - include: "#tag-attributes"
              - include: $self
          - match: \s*([.#])(?=[\w$])
            name: punctuation.definition.entity.kiara
          - comment: inline markup
            begin: (?<!'+)\s*('''+|')
            contentName: string.quoted.single.kiara
            end: \s*((\1)(?!'+))
            captures:
              1: {name: punctuation.definition.string.kiara}
            patterns: [include: "#markdown"]
          - comment: inline markup
            begin: (?<!"+)\s*("""+|")
            contentName: string.quoted.double.kiara
            end: \s*((\1)(?!"+))
            captures:
              1: {name: punctuation.definition.string.kiara}
            patterns: [include: "#markdown"]
          - include: "#regexps"

      inline-styles:
        begin: (?<=^|[\w\s'"`])(\+>)(.*)\n*
        beginCaptures:
          1:
            name: storage.type.style.kiara
          2:
            patterns:
              - match: (?<=^|\s)([?:]?=)(?=\s+|$)
                captures:
                  1: {name: keyword.operator.assignment.kiara}
              - include: "#comments"
              - include: "#style-pair"
              - include: "#style-rules"
              - include: "#declaration-clause"
              - match: *entity-name
                name: entity.name.style.kiara
        end: ^(?=\S)|(?!\G)
        patterns:
          - begin: ^(\s+)(?!\s)
            end: ^(?!\1|\s*$)
            name: meta.style.yaml
            patterns: [include: "#style-properties"]

  # Special code blocks

  html-builtins:
    patterns:
      - include: source.css.scss#constant_functions
      - include: source.css.scss#constant_sass_functions
      - include: source.css.scss#constant_important
      - include: source.css.scss#constant_default
      - include: source.css.scss#constant_optional

  property-name:
    match: \b([\p{Pc}\p{L}]\w*\b(?:(?:::|\.?)[\p{Pc}\p{L}]\w*)*)\b
    name: meta.property-name.kiara
    captures:
      1:
        patterns:
          - include: "#css-value-names"
          - match: ([\p{Pc}\p{L}]\w*)\b(?=[.:])
            name: constant.other.kiara
          - match: ([\p{Pc}\p{L}]\w*)\b
            name: constant.language.kiara
          - match: '\.|:|::'
            name: punctuation.separator.namespace.kiara

  style-list:
    begin: (\[)\s*
    end: \s*(\])
    name: meta.brace.square.kiara
    captures:
      1: {name: punctuation.definition.expression.kiara}
    patterns:
      - include: "#punctuation"
      - include: "#style-property-values"
      - include: $self

  style-property-values:
    patterns:
      - include: "#style-list"
      - include: "#style-block"
      - include: "#literals"
      - include: "#function-calls"
      - include: "#property-name"
      - include: "#hex-colors"
      - include: "#embedded-expression"
      - include: "#html-builtins"
      - include: "#line-continuation"
      - include: "#jsx"
      - include: "#brackets"

  hex-colors:
    match: (#)\b(?:\h{3,4}|\h{6}|\h{8})\b
    name: constant.other.color.rgb-value.hex.css
    captures:
      1: {name: punctuation.definition.constant.css}

  tag-names:
    match: \s*\b([\p{Pc}\p{L}]\w*\b(?:(?:::|\.?)[\p{Pc}\p{L}]\w*)*)\b\s*
    name: entity.name.tag.kiara
    captures:
      1:
        name: entity.name.tag.kiara
        patterns: *html-tag-names

  script-block:
    begin: (\{)\s*
    end: \s*(\})
    name: meta.brace.script.kiara
    captures:
      1: {name: punctuation.definition.block.script.kiara}
    patterns:
      - include: "#interpolated-code"
      - include: source.js
      - include: $self

  style-block:
    begin: (\{)\s*
    end: \s*(\})
    name: meta.brace.style.kiara
    captures:
      1: {name: punctuation.section.property-list.kiara}
    patterns:
      - include: "#style-properties"

  style-pair:
    applyEndPatternLast: true
    begin: \s*([\p{Pd}\w]+)\b(:)\s*
    end: (?=)|$
    name: meta.property.css.kiara
    beginCaptures:
      1:
        name: support.type.property-name.kiara
        patterns: [include: "#css-property-names"]
      2:
        name: punctuation.separator.key-value.kiara
    patterns:
      - include: "#style-property-values"
      - match: \s+
        name: meta.var.expr.kiara

  style-properties:
    patterns:
      - include: "#comments"
      - include: "#embedded"
      - include: "#clauses"
      - include: "#declarations"
      - include: "#keywords"
      - include: "#style-pair"
      - include: "#style-rules"
      - include: "#style-block"
      - include: $self

  style-rules:
    patterns:
      - comment: CSS operators
        match: \s*(?:(\+)|(\-)|(\*)|(/)|(\%)|(\!)|(\?)|(\&)|(\|)|(\^)|(\~)|(\$)|(\#)|([<>]))\s*
        captures:
          1: {name: keyword.operator.sum.kiara}
          2: {name: keyword.operator.difference.kiara}
          3: {name: keyword.operator.product.kiara}
          4: {name: keyword.operator.quotient.kiara}
          5: {name: keyword.operator.remainder.kiara}
          6: {name: keyword.operator.only.kiara}
          7: {name: keyword.operator.maybe.kiara}
          8: {name: keyword.operator.intersection.kiara}
          9: {name: keyword.operator.union.kiara}
          10: {name: keyword.operator.symmetric.kiara}
          11: {name: keyword.operator.negation.kiara}
          12: {name: keyword.operator.macro.dollar.kiara}
          13: {name: keyword.operator.private.kiara}
          14: {name: keyword.operator.class.kiara}
      - begin: \s*(\()\s*
        end: \s*(\))
        captures:
          1: {name: punctuation.definition.parameters.kiara}
        patterns:
          - match: \s*(?<!(?:(?<!\.)\.|[?!:]:)=?)\b(as)\b\s*
            name: keyword.operator.expression.as.kiara
          - include: "#clauses"
          - include: "#constants"
          - include: "#declarations"
          - include: "#expression-keywords"
          - include: "#style-pair"
          - include: "#parameter-variables"
          - include: $self
      - begin: \s*(\[)\s*
        end: \s*(\])\s*
        captures:
          1: {name: punctuation.definition.selector.kiara}
        patterns:
          - include: "#attribute-selectors"
          - include: $self
      - match: \s*(?<!(?:(?<!\.)\.|[?!:]:)=?)\b(from|to|except|only|as)\b\s*
        name: keyword.operator.expression.kiara
      - include: "#style-selectors"
      - include: "#format-syntax"
      - include: "#tag-names"

  style-selectors:
    patterns:
      - match: \s*([@#&*|%.:~^?]|::)(?=[\w$'"`])
        name: punctuation.definition.entity.kiara
      - match: \s*(?<=\@)[\p{Pc}\p{L}]\w*\b\s*
        name: keyword.control.at-rule.kiara
      - match: \s*(?<=\#)[\p{Pc}\p{L}]\w*\b\s*
        name: entity.other.attribute-name.id.kiara
      - match: \s*(?<=\.)[\p{Pc}\p{L}]\w*\b\s*
        name: entity.other.attribute-name.class.kiara
      - match: \s*(?<=::)[\p{Pc}\p{L}]\w*\b\s*
        name: entity.other.attribute-name.pseudo-component.kiara
      - match: \s*(?<=\~)[\p{Pc}\p{L}]\w*\b\s*
        name: entity.other.attribute-name.key.kiara
      - match: \s*(?<=\&)[\p{Pc}\p{L}]\w*\b\s*
        name: entity.other.attribute-name.kiara entity.name.type.anchor.kiara
      - match: \s*(?<=\*)[\p{Pc}\p{L}]\w*\b\s*
        name: entity.other.attribute-name.kiara entity.name.type.alias.kiara
      - match: \s*(?<=\%)[\p{Pc}\p{L}]\w*\b\s*
        name: entity.other.attribute-name.kiara entity.name.function.kiara
      - match: \s*(?<=\|)[\p{Pc}\p{L}]\w*\b\s*
        name: entity.other.attribute-name.kiara entity.name.method.kiara
      - match: \s*(?<=\:)[\p{Pc}\p{L}]\w*\b\s*
        name: entity.other.attribute-name.kiara entity.name.procedure.kiara
      - match: \s*(?<=\^)[\p{Pc}\p{L}]\w*\b\s*
        name: entity.other.attribute-name.kiara entity.name.property.kiara
      - match: \s*(?<=\?)[\p{Pc}\p{L}]\w*\b\s*
        name: entity.other.attribute-name.kiara entity.name.predicate.kiara

  # Comments

  comments:
    patterns:
      - include: "#block-comments"
      - include: "#line-comments"
      - include: "#nested-comments"

  block-comments:
    patterns:
      - begin: \s*(/\*\*)(?![\p{S}\p{P}&&[^,;'"`({\[)}\]\p{Pc}]]+)
        end: \s*(\*/)
        name: comment.block.documentation.kiara
        captures:
          1: {name: punctuation.definition.comment.kiara}
        patterns:
          - include: "#jsdoc"
          - include: text.html.markdown#inline
          - include: "#nested-jsdoc"
      - begin: \s*(/\*)(?![\p{S}\p{P}&&[^,;'"`({\[)}\]\p{Pc}]]+)
        end: \s*(\*/)
        name: comment.block.kiara
        captures:
          1: {name: punctuation.definition.comment.kiara}
        patterns:
          - include: text.html.markdown#inline
          - include: "#nested-block"

  line-comments:
    patterns:
      - begin: \s*(///)(?![\p{S}\p{P}&&[^,;'"`({\[)}\]\p{Pc}]]+)
        end: \s*$
        name: comment.line.documentation.kiara
        captures:
          1: {name: punctuation.definition.comment.kiara}
        patterns:
          - include: "#jsdoc"
          - include: text.html.markdown#inline
      - begin: \s*(//)(?![\p{S}\p{P}&&[^,;'"`({\[)}\]\p{Pc}]]+)
        end: \s*$
        name: comment.line.number-sign.kiara
        captures:
          1: {name: punctuation.definition.comment.kiara}
        patterns:
          - include: text.html.markdown#inline

  nested-jsdoc:
    begin: (/\*\*?)(?![\p{S}\p{P}&&[^,;'"`({\[)}\]\p{Pc}]]+)
    end: \s*(\*/)
    name: comment.block.documentation.nested.kiara
    captures:
      1: {name: punctuation.definition.comment.kiara}
    patterns:
      - include: "#jsdoc"
      - include: text.html.markdown#inline
      - include: "#nested-jsdoc"

  nested-block:
    begin: (/\*)(?![\p{S}\p{P}&&[^,;'"`({\[)}\]\p{Pc}]]+)
    end: \s*(\*/)
    name: comment.block.nested.kiara
    captures:
      1: {name: punctuation.definition.comment.kiara}
    patterns:
      - include: text.html.markdown#inline
      - include: "#nested-block"

  # JSDoc

  jsdoc:
    patterns:
      - include: "#jsdoc-inline-tags"
      - include: "#jsdoc-access"
      - include: "#jsdoc-as-name-path"
      - include: "#jsdoc-simple"
      - include: "#jsdoc-simple-name-path"
      - include: "#jsdoc-module"
      - include: "#jsdoc-type-name"
      - include: "#jsdoc-type-no-name"
      - comment: additional jsdoc V2 keywords
        match: (?<!\w)@(add|api|body|codeend|codestart|demo|download|group|hide|iframe|image|inherits|option|outline|page|parent|signature|tag)\b
        name: storage.type.class.jsdoc
      - comment: additional jsdoc keywords
        match: (?<!\w)@(accessor|alternateClassName|aside|cfg|chainable|docauthor|evented|experimental|ftype|hide|inheritable|localdoc|markdown|mixins|new|override|preventable|ptype|removed|scss mixin|object|template|uses|xtype)\b
        name: storage.type.class.jsdoc

  jsdoc-access:
    comment: "@tag protected...."
    match: (@(access))\s*(private|protected|public)?(?=\s|$)
    captures:
      1: {name: storage.type.class.jsdoc}
      3: {name: storage.modifier.jsdoc}

  jsdoc-module:
    comment: "@tag {optional type} module:file"
    begin: (@(exports|module|listens|requires)\b)\s*(?=({(?:(?>(?:[^\\{}]|\\.)+)|\g<-1>)*\})?\s*(\S*)([\S\s]*))
    end: ^|(?=\*/)|(?=\5$)
    beginCaptures:
      1: {name: storage.type.class.jsdoc}
    patterns:
      - include: "#jsdoc-typedef-scopes"
      - match: (?:(module)(:))?(((?!\*/)\S)+)
        captures:
          1: {name: keyword.module.jsdoc}
          2: {name: punctuation.jsdoc}
          3: {name: string.modulename.jsdoc}

  jsdoc-as-name-path:
    comment: to terminate the block
    begin: (@(borrows|lends)\b)\s*(?=(?!\*/)\S+(?:(?:\s*\bas\b\s*(?!\*/)\S+)?)?([\S\s]*))
    end: ^|(?=\*/)|(?=\3$)
    beginCaptures:
      1: {name: storage.type.class.jsdoc}
    patterns:
      - include: "#jsdoc-name-path-scopes"

  jsdoc-simple:
    comment: "@tag"
    match: (@(abstract|author|classdesc|copyright|default|defaultvalue|deprecated|description|desc|example|external|fileoverview|file|global|host|ignore|inheritdoc|inner|instance|license|override|overview|readonly|see|since|static|summary|todo|tutorial|virtual|variation|version)\b)(?=$|\s)
    captures:
      1: {name: storage.type.class.jsdoc}

  jsdoc-simple-name-path:
    comment: "@tag {opt type} Class#xxx or Class#Event:aaaa etc"
    begin: (@(alias|augments|callback|extends|emits|event|fires|impl|memberof|mixes|name|property|property|this|typedef)\b)\s*(?=({(?:(?>(?:[^\\{}]|\\.)+)|\g<-1>)*\})?\s*\S*([\S*\s]*))
    end: ^|(?=\*/)|(?=\4$)
    beginCaptures:
      1: {name: storage.type.class.jsdoc}
    patterns:
      - include: "#jsdoc-typedef-scopes"
      - include: "#jsdoc-name-path-scopes"

  jsdoc-type-name:
    comment: "@tag {optional type} name"
    begin: (@(arg|argument|class|constant|constructor|constructs|const|function|fn|kind|member|method|mixin|crate|param|var)\b)\s*(?=({(?:(?>(?:[^\\{}]|\\.)+)|\g<-1>)*\})?\s*(((\[(?:(?>[^\[\]]+)|\g<-1>)*\])|\S)+)?([\S\s]*))
    end: ^|(?=\*/)|(?=\7$)
    beginCaptures:
      1: {name: storage.type.class.jsdoc}
    patterns:
      - include: "#jsdoc-typedef-scopes"
      - include: "#jsdoc-name-scopes"

  jsdoc-type-no-name:
    comment: "@tag {types}"
    begin: (@(enum|exception|implements|private|protected|public|returns|return|throws|type)\b)\s*(?=({(?:(?>(?:[^\\{}]|\\.)+)|\g<-1>)*\})?\s*([\S\s]*))
    end: ^|(?=\*/)|(?=\4$)
    beginCaptures:
      1: {name: storage.type.class.jsdoc}
    patterns:
      - include: "#jsdoc-typedef-scopes"

  jsdoc-inline-tags:
    name: meta.tag.inline.jsdoc
    begin: (\[(?:(?>[^\[\]]+)|\g<-1>)*\])?({)(?=@)
    end: \s*(})
    beginCaptures:
      1: {name: string.linktext.jsdoc}
      2: {name: meta.brace.curly.jsdoc}
    endCaptures:
      1: {name: meta.brace.curly.jsdoc}
    patterns:
      - match: (@(link|tutorial))\b([^}]*)
        captures:
          1: {name: storage.type.class.jsdoc}
          3: {name: string.jsdoc}

  jsdoc-typedef-scopes:
    name: entity.name.type.instance.jsdoc
    begin: "{"
    end: "}|^"
    captures:
      0: {name: meta.brace.curly.jsdoc}
    patterns:
      - include: "#jsdoc-typedef-primitives"
      - include: "#jsdoc-name-path-scopes"
      - include: "#jsdoc-typedef-obj"

  jsdoc-typedef-primitives:
    match: \b(null|undefined|boolean|string|number)\b
    captures:
      1: {name: support.type.builtin.primitive.jsdoc}

  jsdoc-typedef-obj:
    comment: typedef object
    begin: "{"
    end: "}|^"
    captures:
      0: {name: meta.brace.curly.jsdoc}
    patterns:
      - include: "#jsdoc-typedef-primitives"
      - match: \b([\p{Pc}\p{L}]\w*)\b\s*(:)
        captures:
          1: {name: variable.other.readwrite.jsdoc}
      - include: "#jsdoc-name-path-scopes"
      - include: "#jsdoc-typedef-obj"

  jsdoc-name-scopes:
    patterns:
      - match: ((?!\*/)[\S&&[^\[\]"']])+
        captures:
          0: {name: variable.other.jsdoc}
      - name: variable.other.jsdoc
        begin: \[
        end: \]|^
        patterns:
          - include: "#jsdoc-string"
          - include: "#jsdoc-name-scopes"

  jsdoc-name-path-scopes:
    patterns:
      - match: \s*(?<!(?:(?<!\.)\.|[?!:]:)=?)\b(as)\b\s*(?=[\p{Pc}\p{L}])
        captures:
          1: {name: keyword.as.jsdoc}
      - match: \s*(?:([\p{Pc}\p{L}&&\P{Ll}]+\w*)|([\p{Pc}\p{L}]\w*))(?=[\s\-~.#]|$)
        captures:
          1: {name: entity.name.class.jsdoc}
          2: {name: entity.name.function.jsdoc}
      - match: (\.)([\p{Pc}\p{L}]\w*)\b(?=\s|$|\")
        captures:
          1: {name: keyword.operator.accessor.jsdoc}
          2: {name: entity.name.function.method.static.jsdoc}
      - match: (\#)([\p{Pc}\p{L}]\w*)\b(?=\s|$|\")
        captures:
          1: {name: keyword.operator.accessor.jsdoc}
          2: {name: entity.name.function.method.instance.jsdoc}
      - match: (~|-)([\p{Pc}\p{L}]\w*)\b(?=\s|$|\")
        captures:
          1: {name: keyword.operator.accessor.jsdoc}
          2: {name: entity.name.function.method.inner.jsdoc}
      - match: (\#)(event)(:)
        captures:
          1: {name: keyword.operator.accessor.jsdoc}
          2: {name: keyword.event.jsdoc}
          3: {name: keyword.operator.jsdoc}
      - name: string.method.jsdoc
        begin: \.(?="|')
        end: (?=.)
        applyEndPatternLast: true
        patterns:
          - include: "#jsdoc-string"

  jsdoc-string:
    name: string.jsdoc
    match: \"(\\"|[^"])*"|'(\\'|[^'])*'

  # Function and method calls

  sigil-function-calls:
    name: meta.function.arguments.kiara
    match: |
      (?x)
      \b
      (
        (?:
          \b
          [\p{Pc}\p{L}]\w* # identifier
          \b
          (?:[!?]?\.=?|[?!:]:=?) # qualified name separator
        )*
        [\p{Pc}\p{L}]\w* # last part of identifier
      )
      \b
      (?=
        \s*
        (?: # function application, composition and piping
            (?: [$@] | <\|{1,3} | <[+-]) ['"`({\[\w\s]
          | # C-style function call
            (?:[?!:]:=?|[?!]?\.=?)? \#? [({]
          | # generics
            (?:[?!:]:=?|[?!]?\.=?)? < ['"`({\[\w]
          | # macro calls
            ! \#? [({]
          | # strings
            \w*['"] | `\s*(?=\N)
        )
      )
    captures:
      1: {patterns: [include: "#function-names"]}

  function-calls:
    patterns:
      - name: meta.function.arguments.kiara
        match: |
          (?x)
          \b
          (
            # ignore all keywords
            (?!
              (?<!(?:(?<!\.)\.|[?!:]:)=?)\b
              (?: # keywords
                in|of|as|is|new|delete
                |unset|ref|and|x?or|not
                |var|val|let|const|func
                |proc|method|type|class|crate
                |impl|enum|module|struct|field
                |union|iter|macro|query|elem
                |object|realm|trait|style|script
                |go|defer|do|with|from|where
                |if|unless|else|then|declare|ref
                |for|foreach|repeat|while|until
                |try|throw|catch|finally|switch
                |match|case|pass|default|goto|move
                |break|continue|redo|retry
                |return|yield|await|scope
                # |import|export|intern|extern
                |debug|assert|check
              )
              \b
            )
            (?:
              \b
              [\p{Pc}\p{L}]\w* # identifier
              \b
              (?:[!?]?\.=?|[?!:]:=?) # qualified name separator
            )*
            [\p{Pc}\p{L}]\w* # last part of identifier
          )
          \b
          (?=
            \s*
            (?: # function application, composition and piping
                (?: [$@] | <\|{1,3} | <[+-]) ['"`({\[\w\s]
              | # C-style function call
                (?:[?!:]:=?|[?!]?\.=?)? \#? [({]
              | # generics
                (?:[?!:]:=?|[?!]?\.=?)? < ['"`({\[\w]
              | # macro calls
                ! \#? [({]
              | # strings
                \w*['"] | `\s*(?=\N)
            )
          )
        captures:
          1: {patterns: [include: "#function-names"]}
      - name: meta.function.arguments.kiara
        match: |
          (?x)
          (?<=
            \s* # opening
            (?:\|{1,3}> | [+-]>) # operator
            \s*
          )
          \b
          (
            # ignore all keywords
            (?!
              (?<!(?:(?<!\.)\.|[?!:]:)=?)\b
              (?: # keywords
                in|of|as|is|new|delete
                |unset|ref|and|x?or|not
                |var|val|let|const|func
                |proc|method|type|class|crate
                |impl|enum|module|struct|field
                |union|iter|macro|query|elem
                |object|realm|trait|style|script
                |go|defer|do|with|from|where
                |if|unless|else|then|declare|ref
                |for|foreach|repeat|while|until
                |try|throw|catch|finally|switch
                |match|case|pass|default|goto|move
                |break|continue|redo|retry
                |return|yield|await|scope
                # |import|export|intern|extern
                |debug|assert|check
              )
              \b
            )
            (?:
              \b
              [\p{Pc}\p{L}]\w* # identifier
              \b
              (?:[!?]?\.=?|[?!:]:=?) # qualified name separator
            )*
            [\p{Pc}\p{L}]\w* # last part of identifier
          )
          \b
        captures:
          1: {patterns: [include: "#function-names"]}

  embedded-function-calls:
    name: meta.function.name.kiara
    match: |
      (?x)
      (?:
        (?<=(?:^|[,;'"`(){}\[\]\w\s]|\\.)(?:[!?]?\.=?|[?!:]:=?)) \b
          (?: # Properties
            # Leading underscore
            (\p{Pc}+\w*\b(?!\p{Pc}+))
          | # Train case
            ([\p{L}&&\P{Ll}][\w&&\P{Ll}]*)
          | # Pascal case
            ((?:[\p{Pc}\p{L}&&\P{Ll}][\w&&\P{Lu}]*)+)
          | # Camel or kebab case
            ([\p{Pc}\p{L}]\w*)
          )
        \b
          (?= 
            \#? [({] | # opening bracket
            [?!:]: < | [?!]?\. < | < | # generics       
            ! # macro call operator
          ) 
        |
        (?<= ^ # beginning of line
          | ['"`({\[)}\]\w\s] # literal
          (?: # operators
            [\p{S}\p{P}&&[^,;'"`({\[)}\]\p{Pc}]]+
          )?
        ) \b
          (?: # Regular variables
            # Leading underscore
            (\p{Pc}+\w*\b(?!\p{Pc}+))
          | # Train case
            ([\p{L}&&\P{Ll}][\w&&\P{Ll}]*)
          | # Pascal case
            ((?:[\p{Pc}\p{L}&&\P{Ll}][\w&&\P{Lu}]*)+)
          | # Camel or kebab case
            ([\p{Pc}\p{L}]\w*)
          )
        \b
          (?= 
            \#? [({] | # opening bracket
            [?!:]: < | [?!]?\. < | < | # generics       
            ! # macro call operator
          ) 
      )
    captures:
      1:
        patterns: &builtin-names
          - include: "#type-names"
          - include: "#support-functions"
        name: entity.name.tag.kiara
      2:
        patterns: *builtin-names
        name: entity.name.tag.kiara support.class.component.kiara
      3:
        patterns: *builtin-names
        name: entity.name.class.builtin.kiara
      4:
        patterns: *builtin-names
        name: entity.name.function.method.kiara
      5:
        patterns: *builtin-names
        name: entity.name.function.tagged-template.kiara
      6:
        patterns: *builtin-names
        name: entity.name.type.kiara
      7:
        patterns: *builtin-names
        name: entity.name.class.kiara
      8:
        patterns: *builtin-names
        name: entity.name.function.kiara

  function-names:
    patterns:
      - &function-names
        name: meta.function.name.kiara
        match: |
          (?x)
          (?:
            (?<=(?:^|[,;'"`(){}\[\]\w\s]|\\.)(?:[!?]?\.=?|[?!:]:=?)) \b
              (?: # Properties
                # Leading underscore
                (\p{Pc}+\w*\b(?!\p{Pc}+))
              | # Train case
                ([\p{L}&&\P{Ll}][\w&&\P{Ll}]*)
              | # Pascal case
                ((?:[\p{Pc}\p{L}&&\P{Ll}][\w&&\P{Lu}]*)+)
              | # Camel or kebab case
                ([\p{Pc}\p{L}]\w*)
              )
            \b
              (?=
                  $ # end of line
                | (?: # operators
                    <\|{1,3} | <[-+] | \|{1,3}> | [-+]> | [$@]
                  )?
                  ['"`({\[)}\]\w\s]
              )
            |
            (?<=
              (?: ^ | [,;'"`({\[)}\]\w\s] | \\. ) # literal
              (?: # operators
                [\p{S}\p{P}&&[^,;'"`({\[)}\]\p{Pc}]]+
              )?
            ) \b
              (?: # Regular variables
                # Leading underscore
                (\p{Pc}+\w*\b(?!\p{Pc}+))
              | # Train case
                ([\p{L}&&\P{Ll}][\w&&\P{Ll}]*)
              | # Pascal case
                ((?:[\p{Pc}\p{L}&&\P{Ll}][\w&&\P{Lu}]*)+)
              | # Camel or kebab case
                ([\p{Pc}\p{L}]\w*)
              )
            \b
              (?=
                  $ # end of line
                | (?: # operators
                    <\|{1,3} | <[-+] | \|{1,3}> | [-+]> | [$@]
                  )?
                  ['"`({\[)}\]\w\s]
              )
          )
        captures:
          1:
            patterns: &builtin-names
              - include: "#type-names"
              - include: "#support-functions"
            name: entity.name.tag.kiara
          2:
            patterns: *builtin-names
            name: entity.name.tag.kiara support.class.component.kiara
          3:
            patterns: *builtin-names
            name: entity.name.class.builtin.kiara
          4:
            patterns: *builtin-names
            name: entity.name.function.method.kiara
          5:
            patterns: *builtin-names
            name: entity.name.function.tagged-template.kiara
          6:
            patterns: *builtin-names
            name: entity.name.type.kiara
          7:
            patterns: *builtin-names
            name: entity.name.class.kiara
          8:
            patterns: *builtin-names
            name: entity.name.function.kiara
      - include: "#variables"
      - include: "#primary-operators"

  # Variables

  parameter-variables:
    patterns:
      - match: |
          (?x)
          (?<=
            (?:
              ^ # SOL
              | (?:^ | [^|]) \| # open pipe
              | [({\[] # open bracket
              | [;,] # separator
              | [(|]\. \s # uncurried function
              | (?:^|[,;'"({\[)}\]|\s])
                \b (?:
                  var|val|let|const|func
                  |proc|method|type|class|crate
                  |impl|enum|module|struct|field
                  |union|iter|macro|query|elem
                  |object|realm|trait|style|script|as
                  |given|using
                ) \b
                (?:$|[,;'"({\[)}\]\s]) # var/val/as/given/using keyword
            ) \s*
          )
            \s*
            [?!] # optional or required
            \b [\p{Pc}\p{L}]\w* \b
            \s*
          (?=
            $ # EOL
            | # close bracket or pipe
              \s* [)}\]] | \s* \|:? [\w\s'"`({\[)}\]]
            | # separator
              \s* [;,]
            | # as keyword (aliasing)
              \s*
              (?<!(?:(?<!\.)\.|[?!:]:)=?)\b(as)\b
              \s*
            | # type specifier and assignment
              (?::|[?:]?=) \s* [\w'"`({\[]
            | \s+ (?::|[?:]?=) \s+ [\w'"`({\[]
          )
        name: variable.parameter.optional.kiara
      - match: |
          (?x)
          (?<=
            (?:
              ^ # SOL
              | (?:^ | [^|]) \| # open pipe
              | [({\[] # open bracket
              | [;,] # separator
              | [(|]\. \s # uncurried function
              | (?:^|[,;'"({\[)}\]|\s])
                \b (?:
                  var|val|let|const|func
                  |proc|method|type|class|crate
                  |impl|enum|module|struct|field
                  |union|iter|macro|query|elem
                  |object|realm|trait|style|script|as
                  |given|using
                ) \b
                (?:$|[,;'"({\[)}\]\s]) # var/val/as/given/using keyword
            ) \s*
          )
            \s*
            \*\*? # spread
            [?!]? # optional or required
            \b [\p{Pc}\p{L}]\w* \b
          (?=
            $ # EOL
            | # close bracket or pipe
              \s* [)}\]] | \s* \|:? [\w\s'"`({\[)}\]]
            | # separator
              \s* [;,]
            | # as keyword (aliasing)
              \s*
              (?<!(?:(?<!\.)\.|[?!:]:)=?)\b(as)\b
              \s*
            | # type specifier and assignment
              (?::|[?:]?=) \s* [\w'"`({\[]
            | \s+ (?::|[?:]?=) \s+ [\w'"`({\[]
          )
        name: variable.parameter.spread.kiara
      - match: |
          (?x)
          (?<=
            (?:
              ^ # SOL
              | (?:^ | [^|]) \| # open pipe
              | [({\[] # open bracket
              | [;,] # separator
              | [(|]\. \s # uncurried function
              | (?:^|[,;'"({\[)}\]|\s])
                \b (?:
                  var|val|let|const|func
                  |proc|method|type|class|crate
                  |impl|enum|module|struct|field
                  |union|iter|macro|query|elem
                  |object|realm|trait|style|script|as
                  |given|using
                ) \b
                (?:$|[,;'"({\[)}\]\s]) # var/val/as/given/using keyword
            ) \s*
          )
            \s*
            ~~? # named
            [?!]? # optional or required
            \b [\p{Pc}\p{L}]\w* \b
          (?=
            $ # EOL
            | # close bracket or pipe
              \s* [)}\]] | \s* \|:? [\w\s'"`({\[)}\]]
            | # separator
              \s* [;,]
            | # as keyword (aliasing)
              \s*
              (?<!(?:(?<!\.)\.|[?!:]:)=?)\b(as)\b
              \s*
            | # type specifier and assignment
              (?::|[?:]?=) \s* [\w'"`({\[]
            | \s+ (?::|[?:]?=) \s+ [\w'"`({\[]
          )
        name: variable.parameter.name.kiara
      - match: |
          (?x)
          (?<=
            (?:
              ^ # SOL
              | (?:^ | [^|]) \| # open pipe
              | [({\[] # open bracket
              | [;,] # separator
              | [(|]\. \s # uncurried function
              | (?:^|[,;'"({\[)}\]|\s])
                \b (?:
                  var|val|let|const|func
                  |proc|method|type|class|crate
                  |impl|enum|module|struct|field
                  |union|iter|macro|query|elem
                  |object|realm|trait|style|script|as
                  |given|using
                ) \b
                (?:$|[,;'"({\[)}\]\s]) # var/val/as/given/using keyword
            ) \s*
          )
            \s*
            \& # reference
            [?!]? # optional or required
            \b [\p{Pc}\p{L}]\w* \b
          (?=
            $ # EOL
            | # close bracket or pipe
              \s* [)}\]] | \s* \|:? [\w\s'"`({\[)}\]]
            | # separator
              \s* [;,]
            | # as keyword (aliasing)
              \s*
              (?<!(?:(?<!\.)\.|[?!:]:)=?)\b(as)\b
              \s*
            | # type specifier and assignment
              (?::|[?:]?=) \s* [\w'"`({\[]
            | \s+ (?::|[?:]?=) \s+ [\w'"`({\[]
          )
        name: variable.parameter.reference.kiara
      - match: |
          (?x)
          (?<=
            (?:
              ^ # SOL
              | (?:^ | [^|]) \| # open pipe
              | [({\[] # open bracket
              | [;,] # separator
              | [(|]\. \s # uncurried function
              | (?:^|[,;'"({\[)}\]|\s])
                \b (?:
                  var|val|let|const|func
                  |proc|method|type|class|crate
                  |impl|enum|module|struct|field
                  |union|iter|macro|query|elem
                  |object|realm|trait|style|script|as
                  |given|using
                ) \b
                (?:$|[,;'"({\[)}\]\s]) # var/val/as/given/using keyword
            ) \s*
          )
            \s*
            \% # other
            [?!]? # optional or required
            \b [\p{Pc}\p{L}]\w* \b
          (?=
            $ # EOL
            | # close bracket or pipe
              \s* [)}\]] | \s* \|:? [\w\s'"`({\[)}\]]
            | # separator
              \s* [;,]
            | # as keyword (aliasing)
              \s*
              (?<!(?:(?<!\.)\.|[?!:]:)=?)\b(as)\b
              \s*
            | # type specifier and assignment
              (?::|[?:]?=) \s* [\w'"`({\[]
            | \s+ (?::|[?:]?=) \s+ [\w'"`({\[]
          )
        name: variable.parameter.other.kiara
      - match: |
          (?x)
          (?<=
            (?:
              ^ # SOL
              | (?:^ | [^|]) \| # open pipe
              | [({\[] # open bracket
              | [;,] # separator
              | [(|]\. \s # uncurried function
              | (?:^|[,;'"({\[)}\]|\s])
                \b (?:
                  var|val|let|const|func
                  |proc|method|type|class|crate
                  |impl|enum|module|struct|field
                  |union|iter|macro|query|elem
                  |object|realm|trait|style|script|as
                  |given|using
                ) \b
                (?:$|[,;'"({\[)}\]\s]) # var/val/as/given/using keyword
            ) \s*
          )
            \s*
            \b [\p{Pc}\p{L}]\w* \b
          (?=
            $ # EOL
            | # close bracket or pipe
              \s* [)}\]] | \s* \|:? [\w\s'"`({\[)}\]]
            | # separator
              \s* [;,]
            | # as keyword (aliasing)
              \s*
              (?<!(?:(?<!\.)\.|[?!:]:)=?)\b(as)\b
              \s*
            | # type specifier and assignment
              (?::|[?:]?=) \s* [\w'"`({\[]
            | \s+ (?::|[?:]?=) \s+ [\w'"`({\[]
          )
        name: variable.parameter.kiara

  placeholder-variables:
    patterns:
      - match: (?i)\s*[?!][\p{Pc}\p{L}]\w*\b\s*
        name: variable.parameter.optional.kiara
      - match: (?i)\s*\*\*?[?!]?[\p{Pc}\p{L}]\w*\b\s*
        name: variable.parameter.spread.kiara
      - match: (?i)\s*~~?[?!]?[\p{Pc}\p{L}]\w*\b\s*
        name: variable.parameter.name.kiara
      - match: (?i)\s*&[?!]?[\p{Pc}\p{L}]\w*\b\s*
        name: variable.parameter.reference.kiara
      - match: (?i)\s*%[?!]?[\p{Pc}\p{L}]\w*\b\s*
        name: variable.parameter.other.kiara
      - match: (?i)\s*\b[\p{Pc}\p{L}]\w*\b\s*
        name: variable.parameter.kiara

  variables:
    patterns:
      - match: |
          (?x)
          (?<=
            \b # qualified name
              [\p{Pc}\p{L}]\w* # identifier
              (?:(?:[?!]?\.|[?!:]:)=?)
            \b
          )
          (?:\d\w*)
        name: variable.other.index.kiara
      - comment: |
          Four types of variables:
          - _lead_underscore
          - UPPERCASE
          - PascalCase
          - camelCase
        match: |
          (?x) \b

          (?:
            (?<=(?:^|[,;'"`(){}\[\]\w\s]|\\.)(?:[!?]?\.=?|[?!:]:=?))
            (?: # Properties
                # Leading underscore
                (\p{Pc}+\w*\b(?!\p{Pc}+))
              | # Train case
                ([\p{L}&&\P{Ll}][\w&&\P{Ll}]*)
              | # Pascal case
                ((?:[\p{Pc}\p{L}&&\P{Ll}][\w&&\P{Lu}]*)+)
              | # Camel or kebab case
                ([\p{Pc}\p{L}]\w*)
            )
            |
            (?: # Objects
                # Leading underscore
                (\p{Pc}+\w*\b(?!\p{Pc}+))
              | # Train case
                ([\p{L}&&\P{Ll}][\w&&\P{Ll}]*)
              | # Pascal case
                ((?:[\p{Pc}\p{L}&&\P{Ll}][\w&&\P{Lu}]*)+)
              | # Camel or kebab case
                ([\p{Pc}\p{L}]\w*)
            )
            (?=(?:[!?]?\.=?|[?!:]:=?|\s*\#?\[)(?:[,;'"`(){}\[\]\w\s]|$))
            |
            (?: # Regular variables
                # Leading underscore
                (\p{Pc}+\w*\b(?!\p{Pc}+))
              | # Train case
                ([\p{L}&&\P{Ll}][\w&&\P{Ll}]*)
              | # Pascal case
                ((?:[\p{Pc}\p{L}&&\P{Ll}][\w&&\P{Lu}]*)+)
              | # Camel or kebab case
                ([\p{Pc}\p{L}]\w*)
            )
          ) \b
        captures:
          1: {name: variable.other.property.dynamic.kiara}
          2: {name: variable.other.constant.property.kiara}
          3: {name: variable.other.property.static.kiara}
          4: {name: variable.other.property.kiara}
          5: {name: variable.other.global.kiara}
          6: {name: variable.other.constant.object.kiara}
          7: {name: variable.other.class.static.kiara}
          8: {name: variable.other.object.kiara}
          9: {name: variable.other.dollar.kiara}
          10: {name: variable.other.constant.kiara}
          11: {name: variable.other.class.kiara}
          12: {name: variable.other.readwrite.kiara}

  # Operators

  operators:
    patterns:
      - include: "#special-operators"
      - include: "#infix-operators"
      - include: "#primary-operators"
      - include: "#suffix-operators"
      - include: "#prefix-operators"

  special-operators:
    patterns:
      - match: (?<=>|\w)(!)(?=#?[({])
        captures:
          1: {name: keyword.operator.macro.kiara}
      - comment: "? ternary operator"
        begin: (?<=^|[\s({\[])(\?)(?=$|[)}\]\s])|(?<=['"`)}\]\w]|\\.)(\?)(?=['"`({\[\w])
        end: (?<=^|[\s({\[])(\:)(?=$|[)}\]\s])|(?<=['"`)}\]\w]|\\.)(\:)(?=['"`({\[\w])
        captures:
          1: {name: keyword.operator.conditional.kiara}
          2: {name: keyword.operator.conditional.kiara}
        patterns:
          - include: $self
      - comment: "! ternary operator"
        begin: (?<=^|[\s({\[])(\!)(?=$|[)}\]\s])|(?<=['"`)}\]\w]|\\.)(\!)(?=['"`({\[\w])
        end: (?<=^|[\s({\[])(\:)(?=$|[)}\]\s])|(?<=['"`)}\]\w]|\\.)(\:)(?=['"`({\[\w])
        captures:
          1: {name: keyword.operator.ternary.kiara}
          2: {name: keyword.operator.ternary.kiara}
        patterns:
          - include: $self

  infix-operators:
    name: keyword.operator.infix.kiara
    match: |
      (?xi)
      (?<=^|[\s({\[]) # opening
      (?:
        ( # 1: optional accessor
        \?[.:]=?
        ) |
        ( # 2: assertion/call operator
          ![.:]=?
        ) |
        ( # 3: accessor operator
          (?:::|\.)=?
        ) |
        ( # 4: compound assignment operators
          # all operators except ~ < = > . : !
          [\p{S}\p{P}&&[^~<=>.,:;!'"`({\[)}\]\p{Pc}]]
          # operator character
          [\p{S}\p{P}&&[^,;'"`({\[)}\]\p{Pc}]]*
          = # ending equal sign
        ) |
        ( # 5: arithmetic operator
          [+-][\%\|]? | \*{1,3}[\%\|]? | ~?/ | %%?
        ) |
        ( # 6: string/regex/array/set
          \+\+ | \-\-
        ) |
        ( # 7: logical operator
          \&\& | \|\| | \^\^ | ! | /\\ | \\/
        ) |
        ( # 8: bitwise and set
          \& | \| | \^ | ~
        ) |
        ( # 9: bitwise shift
          <<<? | >>>?
        ) |
        ( # 10: pipeline
          <\|+ | \|+>
        ) |
        ( # 11: composition
          <\+ | \+>
        ) |
        ( # 12: membership
          [<>][:!] | [:!][<>]
        ) |
        ( # 13: comparison
          < | > | <= | >= | <> | <=>
        ) |
        ( # 14: equality
          == | != | === | !==
        ) |
        ( # 15: similarity
          ~[=!] | [=!]~ | =<
        ) |
        ( # 16: functional
          <[/*|+$:]> | [/*|+$:]> | <[/*|+$:]
        ) |
        ( # 17: null coalescing
          \?+
        ) |
        ( # 18: non null coalescing
          !+
        ) |
        ( # 19: falsy coalescing
          \?:
        ) |
        ( # 20: truthy coalescing
          !:
        ) |
        ( # 21: function application
          [.$]
        ) |
        ( # 22: assignment
          :?=
        ) |
        ( # 23: range
          [>.]\.[.<] | \.\. | [=.]\.[.=]
        ) |
        ( # 24: fat arrow
            =+> # right side
          | <=+ # left side
        ) |
        ( # 25: skinny arrow
            -+> # right side
          | <-+ # left side
        ) |
        ( # 26: wavy arrow
            ~+> # right side
          | <~+ # left side
        ) |
        ( # 27: custom logical
          [&|^~] # leading chars
          [\p{S}\p{P}&&[^,;'"`({\[)}\]\p{Pc}]]+
        ) |
        ( # 28: custom arithmetic
          [-+*/%] # leading chars
          [\p{S}\p{P}&&[^,;'"`({\[)}\]\p{Pc}]]+
        ) |
        ( # 29: custom prototype
          [@:] # leading chars
          [\p{S}\p{P}&&[^,;'"`({\[)}\]\p{Pc}]]+
        ) |
        ( # 30: custom accessor
          [.] # leading chars
          [\p{S}\p{P}&&[^,;'"`({\[)}\]\p{Pc}]]+
        ) |
        ( # 31: custom comparison
          [=!] # leading chars
          [\p{S}\p{P}&&[^,;'"`({\[)}\]\p{Pc}]]+
        ) |
        ( # 32: custom relational
          [<>] # leading chars
          [\p{S}\p{P}&&[^,;'"`({\[)}\]\p{Pc}]]+
        ) |
        ( # 33: custom private
          [?\#] # leading chars
          [\p{S}\p{P}&&[^,;'"`({\[)}\]\p{Pc}]]+
        ) |
        ( # 34: custom math
          \p{Sm} # leading chars
          [\p{S}\p{P}&&[^,;'"`({\[)}\]\p{Pc}]]+
        ) |
        ( # 35: custom currency
          \p{Sc} # leading chars
          [\p{S}\p{P}&&[^,;'"`({\[)}\]\p{Pc}]]+
        ) |
        ( # 36: custom ascii
          [\p{S}\p{P}&&[\x80-\xFF]] # leading chars
          [\p{S}\p{P}&&[^,;'"`({\[)}\]\p{Pc}]]+
        ) |
        ( # 37: catch all
          [\p{S}\p{P}&&[^,;'"`({\[)}\]\p{Pc}]]+
        )
      )
      (?=$|[)}\]\s]) # closing
    captures:
      1: {name: keyword.operator.optional.kiara}
      2: {name: keyword.operator.assert.kiara}
      3: {name: keyword.operator.accessor.kiara}
      4: {name: keyword.operator.assignment.augmented.kiara}
      5: {name: keyword.operator.arithmetic.kiara}
      6: {name: keyword.operator.successor.kiara}
      7: {name: keyword.operator.logical.kiara}
      8: {name: keyword.operator.bitwise.kiara}
      9: {name: keyword.operator.bitwise.shift.kiara}
      10: {name: keyword.operator.pipeline.kiara}
      11: {name: keyword.operator.compose.kiara}
      12: {name: keyword.operator.class.kiara}
      13: {name: keyword.operator.relational.kiara}
      14: {name: keyword.operator.comparison.kiara}
      15: {name: keyword.operator.similarity.kiara}
      16: {name: keyword.operator.function.kiara}
      17: {name: keyword.operator.null-coalescing.kiara}
      18: {name: keyword.operator.coalescing.kiara}
      19: {name: keyword.operator.conditional.kiara}
      20: {name: keyword.operator.ternary.kiara}
      21: {name: keyword.operator.macro.kiara}
      22: {name: keyword.operator.assignment.kiara}
      23: {name: keyword.operator.range.kiara}
      24: {name: keyword.operator.arrow.fat.kiara}
      25: {name: keyword.operator.arrow.skinny.kiara}
      26: {name: keyword.operator.arrow.wavy.kiara}
      27: {name: keyword.operator.logical.custom.kiara}
      28: {name: keyword.operator.arithmetic.custom.kiara}
      29: {name: keyword.operator.prototype.custom.kiara}
      30: {name: keyword.operator.accessor.custom.kiara}
      31: {name: keyword.operator.comparison.custom.kiara}
      32: {name: keyword.operator.relational.custom.kiara}
      33: {name: keyword.operator.private.custom.kiara}
      34: {name: keyword.operator.math.custom.kiara}
      35: {name: keyword.operator.currency.custom.kiara}
      36: {name: keyword.operator.ascii.custom.kiara}
      37: {name: keyword.operator.primary.kiara}

  primary-operators:
    name: keyword.operator.primary.kiara
    match: |
      (?x)
      (?<=['"`)}\]\w]|\\.) # closing
      (?:
        ( # 1: optional accessor
        \?[.:]=?
        ) |
        ( # 2: assertion/call operator
          ![.:]=?
        ) |
        ( # 3: accessor operator
          (?:::|\.)=?
        ) |
        ( # 4: compound assignment operators
          # all operators except ~ < = > . : !
          [\p{S}\p{P}&&[^~<=>.,:;!'"`({\[)}\]\p{Pc}]]
          # operator character
          [\p{S}\p{P}&&[^,;'"`({\[)}\]\p{Pc}]]*
          = # ending equal sign
        ) |
        ( # 5: arithmetic operator
          [+-][\%\|]? | \*{1,3}[\%\|]? | ~?/ | %%?
        ) |
        ( # 6: string/regex/array/set
          \+\+ | \-\-
        ) |
        ( # 7: logical operator
          \&\& | \|\| | \^\^ | ! | /\\ | \\/
        ) |
        ( # 8: bitwise and set
          \& | \| | \^ | ~
        ) |
        ( # 9: bitwise shift
          <<<? | >>>?
        ) |
        ( # 10: pipeline
          <\|+ | \|+>
        ) |
        ( # 11: composition
          <\+ | \+>
        ) |
        ( # 12: membership
          [<>][:!] | [:!][<>]
        ) |
        ( # 13: comparison
          < | > | <= | >= | <> | <=>
        ) |
        ( # 14: equality
          == | != | === | !==
        ) |
        ( # 15: similarity
          ~[=!] | [=!]~ | =<
        ) |
        ( # 16: functional
          <[/*|+$:]> | [/*|+$:]> | <[/*|+$:]
        ) |
        ( # 17: null coalescing
          \?+
        ) |
        ( # 18: non null coalescing
          !+
        ) |
        ( # 19: falsy coalescing
          \?:
        ) |
        ( # 20: truthy coalescing
          !:
        ) |
        ( # 21: function application
          [.$]
        ) |
        ( # 22: assignment
          :?=
        ) |
        ( # 23: range
          [>.]\.[.<] | \.\. | [=.]\.[.=]
        ) |
        ( # 24: fat arrow
            =+> # right side
          | <=+ # left side
        ) |
        ( # 25: skinny arrow
            -+> # right side
          | <-+ # left side
        ) |
        ( # 26: wavy arrow
            ~+> # right side
          | <~+ # left side
        ) |
        ( # 27: custom logical
          [&|^~] # leading chars
          [\p{S}\p{P}&&[^,;'"`({\[)}\]\p{Pc}]]+
        ) |
        ( # 28: custom arithmetic
          [-+*/%] # leading chars
          [\p{S}\p{P}&&[^,;'"`({\[)}\]\p{Pc}]]+
        ) |
        ( # 29: custom prototype
          [@:] # leading chars
          [\p{S}\p{P}&&[^,;'"`({\[)}\]\p{Pc}]]+
        ) |
        ( # 30: custom accessor
          [.] # leading chars
          [\p{S}\p{P}&&[^,;'"`({\[)}\]\p{Pc}]]+
        ) |
        ( # 31: custom comparison
          [=!] # leading chars
          [\p{S}\p{P}&&[^,;'"`({\[)}\]\p{Pc}]]+
        ) |
        ( # 32: custom relational
          [<>] # leading chars
          [\p{S}\p{P}&&[^,;'"`({\[)}\]\p{Pc}]]+
        ) |
        ( # 33: custom private
          [?\#] # leading chars
          [\p{S}\p{P}&&[^,;'"`({\[)}\]\p{Pc}]]+
        ) |
        ( # 34: custom math
          \p{Sm} # leading chars
          [\p{S}\p{P}&&[^,;'"`({\[)}\]\p{Pc}]]+
        ) |
        ( # 35: custom currency
          \p{Sc} # leading chars
          [\p{S}\p{P}&&[^,;'"`({\[)}\]\p{Pc}]]+
        ) |
        ( # 36: custom ascii
          [\p{S}\p{P}&&[\x80-\xFF]] # leading chars
          [\p{S}\p{P}&&[^,;'"`({\[)}\]\p{Pc}]]+
        ) |
        ( # 37: catch all
          [\p{S}\p{P}&&[^,;'"`({\[)}\]\p{Pc}]]+
        )
      )
      (?=['"`({\[\w]) # opening
    captures:
      1: {name: keyword.operator.optional.kiara}
      2: {name: keyword.operator.assert.kiara}
      3: {name: keyword.operator.accessor.kiara}
      4: {name: keyword.operator.assignment.augmented.kiara}
      5: {name: keyword.operator.arithmetic.kiara}
      6: {name: keyword.operator.successor.kiara}
      7: {name: keyword.operator.logical.kiara}
      8: {name: keyword.operator.bitwise.kiara}
      9: {name: keyword.operator.bitwise.shift.kiara}
      10: {name: keyword.operator.pipeline.kiara}
      11: {name: keyword.operator.compose.kiara}
      12: {name: keyword.operator.class.kiara}
      13: {name: keyword.operator.relational.kiara}
      14: {name: keyword.operator.comparison.kiara}
      15: {name: keyword.operator.similarity.kiara}
      16: {name: keyword.operator.function.kiara}
      17: {name: keyword.operator.null-coalescing.kiara}
      18: {name: keyword.operator.coalescing.kiara}
      19: {name: keyword.operator.conditional.kiara}
      20: {name: keyword.operator.ternary.kiara}
      21: {name: keyword.operator.macro.kiara}
      22: {name: keyword.operator.assignment.kiara}
      23: {name: keyword.operator.range.kiara}
      24: {name: keyword.operator.arrow.fat.kiara}
      25: {name: keyword.operator.arrow.skinny.kiara}
      26: {name: keyword.operator.arrow.wavy.kiara}
      27: {name: keyword.operator.logical.custom.kiara}
      28: {name: keyword.operator.arithmetic.custom.kiara}
      29: {name: keyword.operator.prototype.custom.kiara}
      30: {name: keyword.operator.accessor.custom.kiara}
      31: {name: keyword.operator.comparison.custom.kiara}
      32: {name: keyword.operator.relational.custom.kiara}
      33: {name: keyword.operator.private.custom.kiara}
      34: {name: keyword.operator.math.custom.kiara}
      35: {name: keyword.operator.currency.custom.kiara}
      36: {name: keyword.operator.ascii.custom.kiara}
      37: {name: keyword.operator.primary.kiara}

  prefix-operators:
    comment: Prefix operators
    match: |
      (?x)
      (?:
        ([*/]) # 1
        |(\+) # 2
        |(\-) # 3
        |(\&) # 4
        |(\|) # 5
        |(\^) # 6
        |(\!) # 7
        |(\$) # 8
        |(\@) # 9
        |(\~) # 10
        |(\?) # 11
        |(\=) # 12
        |(\$) # 13
        |(\#) # 14
        |[\p{S}\p{P}&&[^,;'"`({\[)}\]\p{Pc}]]
      ) # 15
      (?=[\p{S}\p{P}&&[^,;'"`({\[)}\]\p{Pc}]]*
      ['"`({\[\w])
    name: keyword.operator.prefix.kiara
    captures:
      1: {name: keyword.operator.module.all.kiara}
      2: {name: keyword.operator.increment.kiara}
      3: {name: keyword.operator.decrement.kiara}
      4: {name: keyword.operator.intersection.kiara}
      5: {name: keyword.operator.union.kiara}
      6: {name: keyword.operator.symmetric.kiara}
      7: {name: keyword.operator.logical.kiara}
      8: {name: keyword.operator.private.kiara}
      9: {name: keyword.operator.decorator.kiara}
      10: {name: keyword.operator.bitwise.not.kiara}
      11: {name: keyword.operator.existential.kiara}
      12: {name: keyword.operator.assignment.kiara}
      13: {name: keyword.operator.pipeline.kiara}
      14: {name: keyword.operator.private.kiara}
      15: {name: keyword.operator.prefix.kiara}

  suffix-operators:
    comment: Suffix operators
    match: |
      (?x)
      (?<=(?:['"`)}\]\w]|\\.)
        [\p{S}\p{P}&&[^,;'"`({\[)}\]\p{Pc}]]*)
      (?:
        ([*/]) # 1
        |(\+) # 2
        |(\-) # 3
        |(\&) # 4
        |(\|) # 5
        |(\^) # 6
        |(\!) # 7
        |(\$) # 8
        |(\@) # 9
        |(\~) # 10
        |(\?) # 11
        |(\=) # 12
        |(\$) # 13
        |(\#) # 14
        |[\p{S}\p{P}&&[^,;'"`({\[)}\]\p{Pc}]]
      ) # 15
    name: keyword.operator.suffix.kiara
    captures:
      1: {name: keyword.operator.module.all.kiara}
      2: {name: keyword.operator.increment.kiara}
      3: {name: keyword.operator.decrement.kiara}
      4: {name: keyword.operator.intersection.kiara}
      5: {name: keyword.operator.union.kiara}
      6: {name: keyword.operator.symmetric.kiara}
      7: {name: keyword.operator.assert.kiara}
      8: {name: keyword.operator.private.kiara}
      9: {name: keyword.operator.decorator.kiara}
      10: {name: keyword.operator.bitwise.kiara}
      11: {name: keyword.operator.optional.kiara}
      12: {name: keyword.operator.assignment.kiara}
      13: {name: keyword.operator.pipeline.kiara}
      14: {name: keyword.operator.private.kiara}
      15: {name: keyword.operator.suffix.kiara}

  # Clauses and Keywords

  parameter-brackets:
    begin: (\()\s*
    end: \s*(\))
    captures:
      1: {name: punctuation.definition.parameters.kiara}
    patterns:
      - include: "#binding-pattern"
      - include: $self

  modifier-keywords:
    name: storage.modifier.kiara
    match: |
      (?x)
      (
        (?:
          (?:
            \s*
            (?<!(?:(?<!\.)\.|[?!:]:)=?)
            \b
              (?:
                pub|priv|prot|final|readonly|override
                |global|local|intern|extern|mut|immut
                |post|[gs]et|put|delete|req|opt|delegate
                |safe|unsafe|virtual|sealed|abstract
                |pure|impure|early|late|covar|contra
                |in|out|inout|inplace|ref|defer|a?sync
                |static|dyn|lazy|eager|bound|free|unique
                |union|open|closed?|rec|oper|curry|opaque
                |inline|prefix|infix|suffix|unary|left|right
              )
            )
            \b
          \s*
        )*
      )
      (?=
        \s*(?<!(?:(?<!\.)\.|[?!:]:)=?)\b
        (?:
          var|val|let|const|func
          |proc|method|type|class|crate
          |impl|enum|module|struct|field
          |union|iter|macro|query|elem
          |object|realm|trait|style|script
          |import|export|intern|extern
        )
        \b\s*
      )
    captures:
      1:
        patterns:
          - include: "#modifiers"

  modifiers:
    patterns:
      - comment: Visibility modifiers
        match: |
          (?x) \s*
          \b
          (?:
            pub|priv|prot|final|readonly|override
            |global|local|intern|extern|mut|immut
            |post|[gs]et|put|delete|req|opt|delegate
            |safe|unsafe|virtual|sealed|abstract
          )
          \b
          \s*
        name: storage.modifier.kiara
      - comment: Visibility modifiers
        match: |
          (?x) \s*
          \b
          (?:
            in|out|inout|inplace|ref|defer|a?sync
            |static|dyn|lazy|eager|bound|free|unique
            |union|open|closed?
          )
          \b
          \s*
        name: storage.modifier.declaration.kiara
      - comment: Functional modifiers
        match: |
          (?x) \s*
          \b
          (?:
            rec|oper|curry|opaque|inline|prefix
            |infix|suffix|unary|left|right
          )
          \b
          \s*
        name: storage.modifier.function.kiara

  declaration-keywords:
    patterns:
      - match: \s*(?<!(?:(?<!\.)\.|[?!:]:)=?)\b(declare)\b\s*
        name: keyword.other.declare.kiara
      - match: \s*(?<!(?:(?<!\.)\.|[?!:]:)=?)\b(var|val|let|const)\b\s*
        name: storage.type.kiara
      - match: |
          (?x)
          \s*
            (?<!(?:(?<!\.)\.|[?!:]:)=?)\b
            (
              func|proc|method|type|class|crate
              |impl|enum|module|struct|field
              |union|iter|macro|query|elem
              |object|realm|trait|style|script
            )
            \b
          \s*
        name: storage.type.$1.kiara

  general-keywords:
    comment: general keywords
    patterns:
      - match: \s*(?<!(?:(?<!\.)\.|[?!:]:)=?)\b(if|unless|else)\b\s*
        name: keyword.control.conditional.kiara
      - match: \s*(?<!(?:(?<!\.)\.|[?!:]:)=?)\b(for|foreach|repeat|while|until)\b\s*
        name: keyword.control.loop.kiara
      - match: \s*(?<!(?:(?<!\.)\.|[?!:]:)=?)\b(try|throw|catch|finally|then)\b\s*
        name: keyword.control.trycatch.kiara
      - match: \s*(?<!(?:(?<!\.)\.|[?!:]:)=?)\b(switch|case|default)\b\s*
        name: keyword.control.switch.kiara
      - match: \s*(?<!(?:(?<!\.)\.|[?!:]:)=?)\b(match)\b\s*
        name: keyword.control.match.kiara
      - match: \s*(?<!(?:(?<!\.)\.|[?!:]:)=?)\b(break|continue|redo|retry|return|await|scope|yield|goto|move|pass)\b\s*
        name: keyword.control.flow.kiara
      - match: \s*(?<!(?:(?<!\.)\.|[?!:]:)=?)\b(import|export|intern|extern)\b\s*
        name: keyword.control.module.kiara
      - match: \s*(?<!(?:(?<!\.)\.|[?!:]:)=?)\b(with|do|from|ref|go|defer)\b\s*
        name: keyword.control.$1.kiara
      - match: \s*(?<!(?:(?<!\.)\.|[?!:]:)=?)\b(debug|assert|check|where)\b\s*
        name: keyword.other.$1.kiara

  expression-keywords:
    comment: expression keywords
    patterns:
      - match: \s*(?<!(?:(?<!\.)\.|[?!:]:)=?)\b(in|of|as|is|new)\b\s*
        name: keyword.operator.expression.$1.kiara
      - match: \s*(?<!(?:(?<!\.)\.|[?!:]:)=?)\b(delete)\b\s*
        name: keyword.operator.expression.delete.kiara
      - match: \s*(?<!(?:(?<!\.)\.|[?!:]:)=?)\b(to|till|thru|by)\b\s*
        name: keyword.operator.expression.range.kiara
      - match: \s*(?<!(?:(?<!\.)\.|[?!:]:)=?)\b(unset)\b\s*
        name: keyword.operator.expression.void.kiara
      - match: \s*(?<!(?:(?<!\.)\.|[?!:]:)=?)\b(and|x?or|not)\b\s*
        name: keyword.operator.expression.logical.kiara

  keywords:
    patterns:
      - include: "#module-expression"
      - include: "#control-expression"
      - include: "#query-expression"
      - include: "#constraint-expression"
      - include: "#modifier-keywords"
      - include: "#declaration-keywords"
      - include: "#expression-keywords"
      - include: "#general-keywords"

  control-expression:
    applyEndPatternLast: true
    begin: \s*(?<!(?:(?<!\.)\.|[?!:]:)=?)\b(break|continue|redo|retry|scope|goto|move|pass)\b\s*
    end: (?=)|$
    beginCaptures:
      1: {name: keyword.control.flow.kiara}
    patterns:
      - match: *entity-name
        name: constant.other.label.kiara

  module-expression:
    patterns:
      - applyEndPatternLast: true
        begin: \s*(?<!(?:(?<!\.)\.|[?!:]:)=?)\b(import|export|intern|extern)\b\s*
        end: (?=)|$
        beginCaptures:
          1: {name: keyword.control.module.kiara}
        patterns:
          - match: \s*(?<!(?:(?<!\.)\.|[?!:]:)=?)\b(from|to|as|only|except|default)\b\s*
            name: keyword.control.module.kiara
          - include: "#module-content"

    repository:
      module-content:
        patterns:
          - begin: ({)\s*
            end: \s*(})
            captures:
              1: {name: punctuation.definition.block.kiara}
            patterns:
              - include: "#module-content"
              - include: "#illegal"
          - match: \s*(?<!(?:(?<!\.)\.|[?!:]:)=?)\b(as)\b\s*
            name: keyword.control.module.kiara
          - include: "#type-keywords"
          - include: "#strings"
          - include: "#regexps"
          - include: "#symbols"
          - match: \s*(?<!\*)\*(?!\*)\s*
            name: constant.language.import-export-all.js
          - include: "#modifiers"
          - include: "#comma"
          - include: "#line-continuation"
          - match: *entity-name
            name: variable.other.readwrite.alias.kiara

  constraint-expression:
    comment: most of the keywords come from Dafny
    begin: \s*(?<!(?:(?<!\.)\.|[?!:]:)=?)\b(where)\b\s*
    beginCaptures:
      1: {name: keyword.control.validate.kiara}
    end: (?=[,;)}\]])
    patterns:
      - match: &constraint-keyword |
          (?x)
          \s*
            (?<!(?:(?<!\.)\.|[?!:]:)=?)\b(
              (?:
                require|ensure|(de|in)(crease|crement)|throw|read|assume
                |return|yield|varie|change|create|alter|delete|drop|rename
                |reveal|write|name|permit|allow|grant|revoke|deny|disallow
                |modifie|renew|transfer|postpone|suspend|resume|abort|reject
                |cancel|post|put|get|set|patch|delete|trace|connect|disconnect
                |accept|receive|send|open|close|lock|unlock|flush|reboot|reload
                |restart|start|stop|kill|spawn|invoke|execute|derive|connect
                |extend|implement|use|borrow|lend
              )s
            )
            \b\s*
          \s*
        name: keyword.control.validate.kiara
      - include: $self

  query-expression:
    begin: \s*(?<!(?:(?<!\.)\.|[?!:]:)=?)\b(from)\b\s*
    beginCaptures:
      1: {name: keyword.control.query.kiara}
    end: (?=[,;)}\]])
    patterns:
      - include: "#query-body"
      - include: $self

  query-body:
    patterns:
      - include: "#in-clause"
      - include: "#where-clause"
      - include: "#join-clause"
      - include: "#sort-clause"
      - include: "#select-clause"
      - include: "#group-clause"
      - include: "#limit-clause"
      - include: "#reduce-clause"

    repository:
      in-clause:
        begin: |
          (?x)
          \s*
          (?<!(?:(?<!\.)\.|[?!:]:)=?)\b
            (
              in|of
            )
          \b
          \s*
        beginCaptures:
          1: {name: keyword.control.query.kiara}
          2: {patterns: [include: $self]}
          3: {name: keyword.control.query.kiara}
        end: (?=[,;)}\]])
        patterns:
          - include: "#query-body"
          - include: $self

      join-clause:
        begin: |
          (?x)
          \s*
          (?<!(?:(?<!\.)\.|[?!:]:)=?)\b
            (
              \b (?:full|part|self|cross)? \b \s*
              \b (?:inner|outer|left|right)? \b \s*
              \b (?:join)
            )
          \b
          \s*
        beginCaptures:
          1: {name: keyword.control.query.kiara}
          2: {patterns: [include: $self]}
          3: {name: keyword.control.query.kiara}
        end: (?=[,;)}\]])
        patterns:
          - match: \s*(?<!(?:(?<!\.)\.|[?!:]:)=?)\b([io]nto|equal|in|of)\b\s*
            name: keyword.control.query.kiara
          - include: "#query-body"
          - include: $self

      where-clause:
        begin: |
          (?x)
          \s*
          (?<!(?:(?<!\.)\.|[?!:]:)=?)\b
            (
              where|having|filter|reject
            )
          \b
          \s*
        beginCaptures:
          1: {name: keyword.control.query.kiara}
        end: (?=[,;)}\]])
        patterns:
          - include: "#query-body"
          - include: $self

      sort-clause:
        begin: |
          (?x)
          \s*
          (?<!(?:(?<!\.)\.|[?!:]:)=?)\b
            (
              \b (?:sort|order) \b \s*
              \b (?:asc|desc)? \b \s*
              \b (?:by|with)?
            )
          \b
          \s*
        beginCaptures:
          1: {name: keyword.control.query.kiara}
        end: (?=[,;)}\]])
        patterns:
          - include: "#query-body"
          - include: $self

      select-clause:
        begin: |
          (?x)
          \s*
          (?<!(?:(?<!\.)\.|[?!:]:)=?)\b
            (
              \b (?:select|map) \b \s*
              \b (?:unique|any|all|some|every)?
            )
          \b
          \s*
        beginCaptures:
          1: {name: keyword.control.query.kiara}
        end: (?=[,;)}\]])
        patterns:
          - match: \s*(?<!(?:(?<!\.)\.|[?!:]:)=?)\b(by|while|until|with)\b\s*
            name: keyword.control.query.kiara
          - include: "#query-body"
          - include: $self

      limit-clause:
        begin: |
          (?x)
          \s*
          (?<!(?:(?<!\.)\.|[?!:]:)=?)\b
            (
              \b (?:take|drop|limit|offset) \b \s*
              \b (?:first|last|head|tail)?
            )
          \b
          \s*
        beginCaptures:
          1: {name: keyword.control.query.kiara}
        end: (?=[,;)}\]])
        patterns:
          - match: \s*(?<!(?:(?<!\.)\.|[?!:]:)=?)\b(by|while|until|with)\b\s*
            name: keyword.control.query.kiara
          - include: "#query-body"
          - include: $self

      reduce-clause:
        begin: |
          (?x)
          \s*
          (?<!(?:(?<!\.)\.|[?!:]:)=?)\b
            (
              \b (?:fold|reduce|scan) \b \s*
              \b (?:first|last|left|right)?
            )
          \b
          \s*
        beginCaptures:
          1: {name: keyword.control.query.kiara}
        end: (?=[,;)}\]])
        patterns:
          - match: \s*(?<!(?:(?<!\.)\.|[?!:]:)=?)\b(by|while|until|with)\b\s*
            name: keyword.control.query.kiara
          - include: "#query-body"
          - include: $self

      group-clause:
        begin: |
          (?x)
          \s*
          (?<!(?:(?<!\.)\.|[?!:]:)=?)\b
            (
              group
            )
          \b
          \s*
        beginCaptures:
          1: {name: keyword.control.query.kiara}
        end: (?=[,;)}\]])
        patterns:
          - match: \s*(?<!(?:(?<!\.)\.|[?!:]:)=?)\b(by|[io]nto)\b\s*
            name: keyword.control.query.kiara
          - include: "#query-body"
          - include: $self

  declarations:
    patterns:
      - include: "#variable"
      - include: "#declare"
      - include: "#style"
      - include: "#script"
      - include: "#markup"
      - include: "#function"
      - include: "#procedure"
      - include: "#method"
      - include: "#class"
      - include: "#interface"
      - include: "#enum"
      - include: "#module"
      - include: "#iterator"
      - include: "#macro"
      - include: "#query"
      - include: "#object"
      - include: "#trait"
      - include: "#component"
      - include: "#field"
      - include: "#realm"
      - include: "#struct"
      - include: "#union"
      - include: "#model"
      - include: "#namespace"

    repository:
      style:
        applyEndPatternLast: true
        begin: \s*(?<!(?:(?<!\.)\.|[?!:]:)=?)\b(style)\b\s*
        end: (?=)|$
        beginCaptures:
          1: {name: storage.type.style.kiara}
        name: meta.style.kiara
        patterns:
          - include: "#style-rules"
          - include: "#style-pair"
          - include: "#style-block"
          - include: "#declaration-clause"
          - match: *entity-name
            name: entity.name.style.kiara

      script:
        applyEndPatternLast: true
        begin: \s*(?<!(?:(?<!\.)\.|[?!:]:)=?)\b(script)\b\s*
        end: (?=)|$
        beginCaptures:
          1: {name: storage.type.script.kiara}
        name: meta.script.kiara
        patterns:
          - include: "#script-block"
          - include: "#declaration-clause"
          - match: *entity-name
            name: entity.name.script.kiara

      component:
        applyEndPatternLast: true
        begin: \s*(?<!(?:(?<!\.)\.|[?!:]:)=?)\b(elem)\b\s*
        end: (?=)|$
        beginCaptures:
          1: {name: storage.type.component.kiara}
        patterns:
          - include: "#declaration-clause"
          - match: *entity-name
            name: entity.name.component.kiara
            patterns: *html-tag-names

      variable:
        applyEndPatternLast: true
        begin: \s*(?<!(?:(?<!\.)\.|[?!:]:)=?)\b(var|val|let|const)\b\s*
        end: (?=)|$
        beginCaptures:
          1: {name: storage.type.variable.kiara}

      declare:
        applyEndPatternLast: true
        begin: \s*(?<!(?:(?<!\.)\.|[?!:]:)=?)\b(declare)\b\s*
        end: (?=)|$
        beginCaptures:
          1: {name: keyword.other.declare.kiara}

      function:
        applyEndPatternLast: true
        begin: \s*(?<!(?:(?<!\.)\.|[?!:]:)=?)\b(func)\b\s*
        end: (?=)|$
        beginCaptures:
          1: {name: storage.type.function.kiara}
        patterns:
          - include: "#declaration-clause"
          - match: *entity-name
            name: entity.name.function.kiara

      namespace:
        applyEndPatternLast: true
        begin: \s*(?<!(?:(?<!\.)\.|[?!:]:)=?)\b(crate)\b\s*
        end: (?=)|$
        beginCaptures:
          1: {name: storage.type.namespace.kiara}
        patterns:
          - include: "#declaration-clause"
          - match: *entity-name
            name: entity.name.namespace.kiara

      method:
        applyEndPatternLast: true
        begin: \s*(?<!(?:(?<!\.)\.|[?!:]:)=?)\b(method)\b\s*
        end: (?=)|$
        beginCaptures:
          1: {name: storage.type.method.kiara}
        patterns:
          - include: "#declaration-clause"
          - match: *entity-name
            name: entity.name.method.kiara

      procedure:
        applyEndPatternLast: true
        begin: \s*(?<!(?:(?<!\.)\.|[?!:]:)=?)\b(proc)\b\s*
        end: (?=)|$
        beginCaptures:
          1: {name: storage.type.procedure.kiara}
        patterns:
          - include: "#declaration-clause"
          - match: *entity-name
            name: entity.name.procedure.kiara

      class:
        applyEndPatternLast: true
        begin: \s*(?<!(?:(?<!\.)\.|[?!:]:)=?)\b(class)\b\s*
        end: (?=)|$
        beginCaptures:
          1: {name: storage.type.class.kiara}
        patterns:
          - include: "#declaration-clause"
          - match: *entity-name
            name: entity.name.class.kiara

      interface:
        applyEndPatternLast: true
        begin: \s*(?<!(?:(?<!\.)\.|[?!:]:)=?)\b(impl)\b\s*
        end: (?=)|$
        beginCaptures:
          1: {name: storage.type.interface.kiara}
        patterns:
          - include: "#declaration-clause"
          - match: *entity-name
            name: entity.name.interface.kiara

      enum:
        applyEndPatternLast: true
        begin: \s*(?<!(?:(?<!\.)\.|[?!:]:)=?)\b(enum)\b\s*
        end: (?=)|$
        beginCaptures:
          1: {name: storage.type.enum.kiara}
        patterns:
          - include: "#declaration-clause"
          - match: *entity-name
            name: entity.name.enum.kiara

      module:
        applyEndPatternLast: true
        begin: \s*(?<!(?:(?<!\.)\.|[?!:]:)=?)\b(module)\b\s*
        end: (?=)|$
        beginCaptures:
          1: {name: storage.type.module.kiara}
        patterns:
          - include: "#declaration-clause"
          - match: *entity-name
            name: entity.name.module.kiara

      iterator:
        applyEndPatternLast: true
        begin: \s*(?<!(?:(?<!\.)\.|[?!:]:)=?)\b(iter)\b\s*
        end: (?=)|$
        beginCaptures:
          1: {name: storage.type.iterator.kiara}
        patterns:
          - include: "#declaration-clause"
          - match: *entity-name
            name: entity.name.iterator.kiara

      model:
        applyEndPatternLast: true
        begin: \s*(?<!(?:(?<!\.)\.|[?!:]:)=?)\b(model)\b\s*
        end: (?=)|$
        beginCaptures:
          1: {name: storage.type.model.kiara}
        patterns:
          - include: "#declaration-clause"
          - match: *entity-name
            name: entity.name.model.kiara

      macro:
        applyEndPatternLast: true
        begin: \s*(?<!(?:(?<!\.)\.|[?!:]:)=?)\b(macro)\b\s*
        end: (?=)|$
        beginCaptures:
          1: {name: storage.type.macro.kiara}
        patterns:
          - include: "#declaration-clause"
          - match: *entity-name
            name: entity.name.macro.kiara

      query:
        applyEndPatternLast: true
        begin: \s*(?<!(?:(?<!\.)\.|[?!:]:)=?)\b(query)\b\s*
        end: (?=)|$
        beginCaptures:
          1: {name: storage.type.query.kiara}
        patterns:
          - include: "#declaration-clause"
          - match: *entity-name
            name: entity.name.query.kiara

      object:
        applyEndPatternLast: true
        begin: \s*(?<!(?:(?<!\.)\.|[?!:]:)=?)\b(object)\b\s*
        end: (?=)|$
        beginCaptures:
          1: {name: storage.type.object.kiara}
        patterns:
          - include: "#declaration-clause"
          - match: *entity-name
            name: entity.name.object.kiara

      trait:
        applyEndPatternLast: true
        begin: \s*(?<!(?:(?<!\.)\.|[?!:]:)=?)\b(trait)\b\s*
        end: (?=)|$
        beginCaptures:
          1: {name: storage.type.trait.kiara}
        patterns:
          - include: "#declaration-clause"
          - match: *entity-name
            name: entity.name.trait.kiara

      realm:
        applyEndPatternLast: true
        begin: \s*(?<!(?:(?<!\.)\.|[?!:]:)=?)\b(realm)\b\s*
        end: (?=)|$
        beginCaptures:
          1: {name: storage.type.realm.kiara}
        patterns:
          - include: "#declaration-clause"
          - match: *entity-name
            name: entity.name.realm.kiara

      union:
        applyEndPatternLast: true
        begin: \s*(?<!(?:(?<!\.)\.|[?!:]:)=?)\b(union)\b\s*
        end: (?=)|$
        beginCaptures:
          1: {name: storage.type.union.kiara}
        patterns:
          - include: "#declaration-clause"
          - match: *entity-name
            name: entity.name.union.kiara

      struct:
        applyEndPatternLast: true
        begin: \s*(?<!(?:(?<!\.)\.|[?!:]:)=?)\b(struct)\b\s*
        end: (?=)|$
        beginCaptures:
          1: {name: storage.type.struct.kiara}
        patterns:
          - include: "#declaration-clause"
          - match: *entity-name
            name: entity.name.struct.kiara

      field:
        applyEndPatternLast: true
        begin: \s*(?<!(?:(?<!\.)\.|[?!:]:)=?)\b(field)\b\s*
        end: (?=)|$
        beginCaptures:
          1: {name: storage.type.field.kiara}
        patterns:
          - include: "#declaration-clause"
          - match: *entity-name
            name: entity.name.field.kiara

  declaration-clause:
    name: meta.declaration.kiara
    patterns:
      - match: *constraint-keyword
        name: keyword.other.$1.kiara
      - match: \b([\p{Pc}\p{L}]\w*)\b(?=::|\.)
        name: entity.name.namespace.kiara
      - include: "#type-square-brackets"
      - include: "#type-signature"
      - include: "#decorators"
      - include: "#type-keywords"
      - match: \s*(?<!\*)\*(?!\*)\s*
        name: keyword.generator.asterisk.kiara
      - include: "#comments"
      - include: "#comma"
      - include: "#line-continuation"
      - begin: (\()\s*
        end: \s*(\))
        captures:
          1: {name: punctuation.definition.parameters.kiara}
        patterns:
          - include: "#binding-pattern"
          - include: $self
      - begin: (\#\{)\s*
        end: \s*(\})
        name: meta.brace.curly.kiara
        captures:
          1: {name: punctuation.section.class.kiara}
        patterns:
          - include: $self
      - begin: (\{)\s*
        end: \s*(\})
        name: meta.brace.curly.kiara
        captures:
          1: {name: punctuation.definition.block.kiara}
        patterns:
          - include: $self
      - include: "#brackets"
      - include: "#literals"
      - match: ::|\.
        name: punctuation.separator.namespace.kiara
      - match: \s+
        name: meta.block.kiara

  function-clause:
    patterns:
      - comment: |
          Function def before function keyword
          x = def()
        match: |
          (?x)

          \s*

          (?<=[?!:]:|\b\.|[?!]\.)

          \s*

          # Label
          \b([\p{Pc}\p{L}]\w*)\b\s+

          # Assignment operator
          (:?=)\s+

          (
            (?:
              \s*
              \b
              (?: # Modifier keywords
                pub|priv|prot|final|readonly|override
                |global|local|intern|extern|mut|immut
                |post|[gs]et|put|delete|req|opt|delegate
                |safe|unsafe|virtual|sealed|abstract
                |pure|impure|early|late|covar|contra
                |in|out|inout|inplace|ref|defer|a?sync
                |static|dyn|lazy|eager|bound|free|unique
                |union|open|closed?|rec|oper|curry|opaque
                |inline|prefix|infix|suffix|unary|left|right
              )
              \b
              \s*
            )*
          )

          (?=
            \s*
            \b
            (?: # Function types
              function|proc|method|type
              |class|impl|enum|module|struct|field|union
              |iter|macro|query|object|realm
              |trait|style|script|elem|field|model|crate
            )
            \b
          )
        name: meta.function.declaration.kiara
        captures:
          1: {name: entity.name.method.kiara}
          2: {name: keyword.operator.assignment.kiara}
          3: {patterns: [include: "#modifiers"]}
      - begin: |
          (?x)

          (?<=[?!:]:|\b\.|[?!]\.)

          \s*

          # Label
          \b([\p{Pc}\p{L}]\w*)\b\s+

          # Assignment operator
          (:?=)\s+

          (
            (?:
              \s*
              \b
              (?: # Modifier keywords
                pub|priv|prot|final|readonly|override
                |global|local|intern|extern|mut|immut
                |post|[gs]et|put|delete|req|opt|delegate
                |safe|unsafe|virtual|sealed|abstract
                |pure|impure|early|late|covar|contra
                |in|out|inout|inplace|ref|defer|a?sync
                |static|dyn|lazy|eager|bound|free|unique
                |union|open|closed?|rec|oper|curry|opaque
                |inline|prefix|infix|suffix|unary|left|right
              )
              \b
              \s*
            )*
          )

          \s*
          (\|)(?!\|)
        end: (?<!\|)(\|)(?!\|)
        name: meta.function.declaration.kiara
        captures:
          1: {name: entity.name.method.kiara}
          2: {name: keyword.operator.assignment.kiara}
          3: {patterns: [include: "#modifiers"]}
          4: {name: punctuation.separator.arguments.kiara}
        endCaptures:
          1: {name: punctuation.separator.arguments.kiara}
        patterns:
          - include: "#argument-list-content"
      - comment: |
          Function def before function keyword
          x = def()
        match: |
          (?x)

          \s*

          # Label
          \b([\p{Pc}\p{L}]\w*)\b\s+

          # Assignment operator
          (:?=)\s+

          (
            (?:
              \s*
              \b
              (?: # Modifier keywords
                pub|priv|prot|final|readonly|override
                |global|local|intern|extern|mut|immut
                |post|[gs]et|put|delete|req|opt|delegate
                |safe|unsafe|virtual|sealed|abstract
                |pure|impure|early|late|covar|contra
                |in|out|inout|inplace|ref|defer|a?sync
                |static|dyn|lazy|eager|bound|free|unique
                |union|open|closed?|rec|oper|curry|opaque
                |inline|prefix|infix|suffix|unary|left|right
              )
              \b
              \s*
            )*
          )

          (?=
            \s*
            \b
            (?: # Function types
              function|proc|method|type
              |class|impl|enum|module|struct|field|union
              |iter|macro|query|object|realm
              |trait|style|script|elem|field|model|crate
            )
            \b
          )
        name: meta.function.declaration.kiara
        captures:
          1: {name: entity.name.kiara}
          2: {name: keyword.operator.assignment.kiara}
          3: {patterns: [include: "#modifiers"]}
      - begin: |
          (?x)

          \s*

          # Label
          \b([\p{Pc}\p{L}]\w*)\b\s+

          # Assignment operator
          (:?=)\s+

          \s*

          (
            (?:
              \s*
              \b
              (?: # Modifier keywords
                pub|priv|prot|final|readonly|override
                |global|local|intern|extern|mut|immut
                |post|[gs]et|put|delete|req|opt|delegate
                |safe|unsafe|virtual|sealed|abstract
                |pure|impure|early|late|covar|contra
                |in|out|inout|inplace|ref|defer|a?sync
                |static|dyn|lazy|eager|bound|free|unique
                |union|open|closed?|rec|oper|curry|opaque
                |inline|prefix|infix|suffix|unary|left|right
              )
              \b
              \s*
            )*
          )

          \s*
          (\|)(?!\|)
        end: (?<!\|)(\|)(?!\|)
        name: meta.function.declaration.kiara
        captures:
          1: {name: entity.name.kiara}
          2: {name: keyword.operator.assignment.kiara}
          3: {patterns: [include: "#modifiers"]}
          4: {name: punctuation.separator.arguments.kiara}
        endCaptures:
          1: {name: punctuation.separator.arguments.kiara}
        patterns:
          - include: "#argument-list-content"

  argument-list:
    name: meta.function.arguments.kiara
    begin: |
      (?x)
      (?<=
        (?:
            # beginning of line
            ^
          | # separator
            [,;]
          | # opening bracket
            [({\[]
          | # postfix or infix operator
            [\p{S}\p{P}&&[^,;'"`({\[)}\]\p{Pc}]]+ \s
        ) \s*
        | # a keyword
        (?:
          (?:^|[,;'"({\[)}\]\s]) # beside a delimiter or space
          \b
            (?: # keywords
              in|of|as|is|new|delete
              |unset|ref|and|x?or|not
              |var|val|let|const|func
              |proc|method|type|class|crate
              |impl|enum|module|struct|field
              |union|iter|macro|query|elem
              |object|realm|trait|style|script
              |go|defer|do|with|from|where
              |if|unless|else|then|declare|ref
              |for|foreach|repeat|while|until
              |try|throw|catch|finally|switch
              |match|case|pass|default|goto|move
              |break|continue|redo|retry
              |return|yield|await|scope
              # |import|export|intern|extern
              |debug|assert|check
            )
          \b
        ) \s*
      ) \s*
      (\|)(?!\|)
    captures:
      1: {name: punctuation.separator.arguments.kiara}
    end: (?<!\|)(\|)(?!\|)
    patterns:
      - include: "#argument-list-content"

  argument-list-content:
    patterns:
      - match: \s*(?<!(?:(?<!\.)\.|[?!:]:)=?)\b(as)\b\s*
        name: keyword.operator.expression.as.kiara
      - match: (?<=[\w\s][(|])\.
        name: punctuation.definition.metadata.kiara
      - match: ","
        name: punctuation.separator.arguments.kiara
      - include: "#binding-pattern"

  clauses:
    patterns:
      - include: "#for-clause"
      - include: "#if-clause"
      - include: "#match-clause"
      - include: "#switch-clause"
      - include: "#catch-clause"
      - include: "#with-clause"
      - include: "#do-clause"
      - include: "#type-clause"
      - include: "#new-clause"

    repository:
      new-clause:
        applyEndPatternLast: true
        begin: \s*(?<!(?:(?<!\.)\.|[?!:]:)=?)\b(new)\b
        end: (?=)|$
        beginCaptures:
          1: {name: keyword.operator.expression.$1.kiara}
        patterns:
          - match: *entity-name
            name: entity.name.instance.kiara
          - include: "#type-clause"
          - include: "#type-keywords"
          - include: "#type-square-brackets"
          - include: "#parameter-brackets"
          - include: "#round-brackets"

      type-clause:
        patterns:
          - applyEndPatternLast: true
            begin: \s*(?<!(?:(?<!\.)\.|[?!:]:)=?)\b(is|as)\b\s*
            end: (?=)|$
            beginCaptures:
              1: {name: keyword.operator.expression.$1.kiara}
            patterns:
              - include: "#types"
          - applyEndPatternLast: true
            begin: \s*(?<!(?:(?<!\.)\.|[?!:]:)=?)\b(type)\b\s*
            end: (?=)|$
            captures:
              1: {name: keyword.other.typedef.kiara}
            patterns:
              - include: "#types"
              - match: \s*([:!=</>.^$%?*+|&~]?=)\s*
                captures:
                  1: {name: keyword.operator.assignment.kiara}

      catch-clause:
        applyEndPatternLast: true
        begin: \s*(?<!(?:(?<!\.)\.|[?!:]:)=?)\b(catch)\b\s*(?=\()
        end: (?=)|$
        name: meta.catch.kiara
        captures:
          1: {name: keyword.control.error.kiara}
        patterns:
          - begin: \s*(\()\s*
            end: \s*(\))
            captures:
              1: {name: punctuation.definition.expression.kiara}
            patterns:
              - match: \s*(?<!(?:(?<!\.)\.|[?!:]:)=?)\b(as)\b\s*
                name: keyword.control.error.kiara
              - include: $self
          - begin: \s*(\{)\s*
            end: \s*(\})\s*
            captures:
              1: {name: punctuation.definition.block.kiara}
            patterns:
              - include: "#catch-case-clause"
              - include: $self

      catch-case-clause:
        patterns:
          - match: \s*(?<!(?:(?<!\.)\.|[?!:]:)=?)\b(default)\b\s*(:)
            captures:
              1: {name: keyword.control.error.kiara}
              2:
                name: punctuation.definition.case-statement.kiara
          - begin: \s*(?<!(?:(?<!\.)\.|[?!:]:)=?)\b(case)\b\s*
            end: \s*(:)(?=['"`({\[)}\]\w\s])|$
            beginCaptures:
              1: {name: keyword.control.error.kiara}
            endCaptures:
              1:
                name: punctuation.definition.case-statement.kiara
            patterns:
              - include: "#argument-list"
              - applyEndPatternLast: true
                begin: \s*(?<!(?:(?<!\.)\.|[?!:]:)=?)\b(is)\b\s*
                end: (?=)|$
                beginCaptures:
                  1: {name: keyword.control.error.kiara}
                patterns:
                  - include: "#types"
              - match: \s*(?<!(?:(?<!\.)\.|[?!:]:)=?)\b(if|as)\b\s*
                name: keyword.control.error.kiara
              - include: "#type-keywords"
              - include: $self

      for-clause:
        applyEndPatternLast: true
        begin: \s*(?<!(?:(?<!\.)\.|[?!:]:)=?)\b(for|foreach|while|until)\b\s*(?=\()
        end: (?=)|$
        name: meta.for.kiara
        captures:
          1: {name: keyword.control.loop.kiara}
        patterns:
          - begin: \s*(\()\s*
            end: \s*(\))
            captures:
              1: {name: punctuation.definition.expression.kiara}
            patterns:
              - match: \s*(?<!(?:(?<!\.)\.|[?!:]:)=?)\b(in|of)\b\s*
                name: keyword.control.loop.kiara
              - include: $self

      if-clause:
        applyEndPatternLast: true
        begin: \s*(?<!(?:(?<!\.)\.|[?!:]:)=?)\b(if|unless)\b\s*(?=\()
        end: (?=)|$
        name: meta.if.kiara
        captures:
          1: {name: keyword.control.conditional.kiara}
        patterns:
          - begin: \s*(\()\s*
            end: \s*(\))
            captures:
              1: {name: punctuation.definition.expression.kiara}
            patterns:
              - match: \s*(?<!(?:(?<!\.)\.|[?!:]:)=?)\b(await)\b\s*
                name: keyword.control.conditional.kiara
              - include: $self

      match-clause:
        applyEndPatternLast: true
        begin: \s*(?<!(?:(?<!\.)\.|[?!:]:)=?)\b(match)\b\s*(?=[({])
        end: (?=)|$
        name: meta.match.kiara
        captures:
          1: {name: keyword.control.match.kiara}
        patterns:
          - begin: \s*(\()\s*
            end: \s*(\))
            captures:
              1: {name: punctuation.definition.expression.kiara}
            patterns:
              - match: \s*(?<!(?:(?<!\.)\.|[?!:]:)=?)\b(await)\b\s*
                name: keyword.control.match.kiara
              - include: $self
          - begin: \s*(\{)\s*
            end: \s*(\})\s*
            captures:
              1: {name: punctuation.definition.block.kiara}
            patterns:
              - include: "#match-case-clause"
              - include: $self

      switch-clause:
        applyEndPatternLast: true
        begin: \s*(?<!(?:(?<!\.)\.|[?!:]:)=?)\b(switch)\b\s*(?=[({])
        end: (?=)|$
        name: meta.switch.kiara
        captures:
          1: {name: keyword.control.switch.kiara}
        patterns:
          - begin: \s*(\()\s*
            end: \s*(\))
            captures:
              1: {name: punctuation.definition.expression.kiara}
            patterns:
              - match: \s*(?<!(?:(?<!\.)\.|[?!:]:)=?)\b(await)\b\s*
                name: keyword.control.switch.kiara
              - include: $self
          - begin: \s*(\{)\s*
            end: \s*(\})\s*
            captures:
              1: {name: punctuation.definition.block.kiara}
            patterns:
              - include: "#switch-case-clause"
              - include: $self

      switch-case-clause:
        patterns:
          - match: \s*(?<!(?:(?<!\.)\.|[?!:]:)=?)\b(default)\b\s*(:)
            captures:
              1: {name: keyword.control.switch.kiara}
              2:
                name: punctuation.definition.case-statement.kiara
          - begin: \s*(?<!(?:(?<!\.)\.|[?!:]:)=?)\b(case)\b\s*
            end: \s*(:)(?=['"`({\[)}\]\w\s])|$
            beginCaptures:
              1: {name: keyword.control.switch.kiara}
            endCaptures:
              1:
                name: punctuation.definition.case-statement.kiara
            patterns:
              - include: "#argument-list"
              - applyEndPatternLast: true
                begin: \s*(?<!(?:(?<!\.)\.|[?!:]:)=?)\b(is)\b\s*
                end: (?=)|$
                beginCaptures:
                  1: {name: keyword.control.switch.kiara}
                patterns:
                  - include: "#types"
              - match: \s*(?<!(?:(?<!\.)\.|[?!:]:)=?)\b(if|as)\b\s*
                name: keyword.control.switch.kiara
              - include: "#type-keywords"
              - include: $self

      match-case-clause:
        patterns:
          - match: \s*(?<!(?:(?<!\.)\.|[?!:]:)=?)\b(default)\b\s*(:)
            captures:
              1: {name: keyword.control.match.kiara}
              2:
                name: punctuation.definition.case-statement.kiara
          - begin: \s*(?<!(?:(?<!\.)\.|[?!:]:)=?)\b(case)\b\s*
            end: \s*(:)(?=['"`({\[)}\]\w\s])|$
            beginCaptures:
              1: {name: keyword.control.match.kiara}
            endCaptures:
              1:
                name: punctuation.definition.case-statement.kiara
            patterns:
              - include: "#argument-list"
              - applyEndPatternLast: true
                begin: \s*(?<!(?:(?<!\.)\.|[?!:]:)=?)\b(is)\b\s*
                end: (?=)|$
                beginCaptures:
                  1: {name: keyword.control.match.kiara}
                patterns:
                  - include: "#types"
              - match: \s*(?<!(?:(?<!\.)\.|[?!:]:)=?)\b(if|as)\b\s*
                name: keyword.control.match.kiara
              - include: "#type-keywords"
              - include: $self

      with-clause:
        applyEndPatternLast: true
        begin: \s*(?<!(?:(?<!\.)\.|[?!:]:)=?)\b(with)\b\s*(?=\()
        end: (?=)|$
        name: meta.with.kiara
        captures:
          1: {name: keyword.control.with.kiara}
        patterns:
          - begin: \s*(\()\s*
            end: \s*(\))
            captures:
              1: {name: punctuation.definition.expression.kiara}
            patterns:
              - match: \s*(?<!(?:(?<!\.)\.|[?!:]:)=?)\b(await|as)\b\s*
                name: keyword.control.with.kiara
              - include: $self

  # Binding patterns

  object-key:
    begin: (?<=^|{|;|,)\s*
    end: \s*(?=,|;|}|$)|\s*(:)
    name: meta.object-key.kiara
    endCaptures:
      1: {name: punctuation.separator.key-value.kiara}
    patterns:
      - include: "#literals"
      - include: "#embedded-expression"
      - include: "#brackets"
      - match: (?<=^|{|;|,)\s*\b[\p{Pc}\p{L}]\w*\b\s*(?=,|;|}|:|$)
        name: constant.other.object.key.kiara
      - include: "#space"
      - include: "#comments"
      - include: "#line-continuation"
      - include: $self

  object-value:
    patterns:
      - match: (?<=(?:^|{|;|,)\s*)\b[\p{Pc}\p{L}]\w*\b(?=\s*(?:,|;|}|=['"`({\[\w\s]|$))
        name: variable.other.constant.kiara
      - match: (?<=^|{|;|,)\s*\b[\p{Pc}\p{L}]\w*\b\s*(?=,|;|}|=['"`({\[\w\s]|$)
        name: variable.other.constant.kiara

  object-argument:
    patterns:
      - match: (?<=(?:^|{|;|,)\s*)\b[\p{Pc}\p{L}]\w*\b(?=\s*(?:,|;|}|=['"`({\[\w\s]|$))
        name: variable.parameter.named.kiara
      - match: (?<=^|{|;|,)\s*\b[\p{Pc}\p{L}]\w*\b\s*(?=,|;|}|=['"`({\[\w\s]|$)
        name: variable.parameter.named.kiara

  as-keyword:
    match: \s*(?<!(?:(?<!\.)\.|[?!:]:)=?)\b(as)\b\s*
    name: keyword.operator.expression.as.kiara

  given-using-keyword:
    match: \s*(?<!(?:(?<!\.)\.|[?!:]:)=?)\b(given|using)\b\s*
    name: keyword.operator.expression.$1.kiara

  binding-pattern-object:
    begin: (#?{)\s*
    end: \s*(})
    name: meta.brace.curly.kiara
    captures:
      1: {name: punctuation.definition.binding-pattern.object.kiara}
    patterns:
      - include: "#object-argument"
      - include: "#labels"
      - include: "#object-key"
      - match: ;|,
        name: punctuation.separator.mapping.kiara
      - include: "#binding-pattern"
      - include: "#illegal"

  binding-pattern-tuple:
    begin: (#?\()\s*
    end: \s*(\))
    name: meta.brace.curly.kiara
    captures:
      1: {name: punctuation.definition.binding-pattern.tuple.kiara}
    patterns:
      - include: "#labels"
      - match: ;|,
        name: punctuation.separator.arguments.kiara
      - include: "#binding-pattern"
      - include: "#illegal"

  binding-pattern-array:
    begin: (#?\[)\s*
    end: \s*(])
    name: meta.brace.curly.kiara
    captures:
      1: {name: punctuation.definition.binding-pattern.array.kiara}
    patterns:
      - include: "#labels"
      - match: ;|,
        name: punctuation.separator.sequence.kiara
      - include: "#binding-pattern"
      - include: "#illegal"

  default-value:
    begin: (?<=^|[\s({\[])(\=)(?=$|[)}\]\s])|(?<=['"`)}\]\w]|\\.)(\=)(?=['"`({\[\w])
    captures:
      1: {name: keyword.operator.assignment.kiara}
      2: {name: keyword.operator.assignment.kiara}
    end: (?=\|(?:$|[^|])|[,;)}\]])
    patterns:
      - include: $self

  binding-pattern:
    patterns:
      - include: "#default-value"
      - include: "#as-keyword"
      - include: "#given-using-keyword"
      - include: "#binding-pattern-object"
      - include: "#binding-pattern-tuple"
      - include: "#binding-pattern-array"
      - include: "#illegal-identifiers"
      - include: "#parameter-variables"
      - include: "#type-operators"
      - include: "#type-signature"
      - include: "#space"
      - include: "#comments"
      - include: "#calls"

  # Object labels

  labels:
    patterns:
      - comment: |
          Function def before function keyword
          x = def()
        match: |
          (?x)
          (?<=^\s*|[{;,]\s*)

          \s*

          # Label
          (\b[\p{Pc}\p{L}][\p{Pd}\w]*\b)
          # Key value separator
          (:)\s*

          (
            (?:
              \s*
              \b
              (?: # Modifier keywords
                pub|priv|prot|final|readonly|override
                |global|local|intern|extern|mut|immut
                |post|[gs]et|put|delete|req|opt|delegate
                |safe|unsafe|virtual|sealed|abstract
                |pure|impure|early|late|covar|contra
                |in|out|inout|inplace|ref|defer|a?sync
                |static|dyn|lazy|eager|bound|free|unique
                |union|open|closed?|rec|oper|curry|opaque
                |inline|prefix|infix|suffix|unary|left|right
              )
              \b
              \s*
            )*
          )

          (?=
            \s*
            \b
            (?: # Function types
              function|proc|method|type
              |class|impl|enum|module|struct|field|union
              |iter|macro|query|object|realm
              |trait|style|script|elem|field|model|crate
            )
            \b
          )
        name: meta.object-literal.key.kiara
        captures:
          1: {name: entity.name.kiara}
          2: {name: punctuation.separator.key-value.kiara}
          3: {patterns: [include: "#modifiers"]}
      - begin: |
          (?x)
          (?<=^\s*|[{;,]\s*)

          \s*

          # Label
          (\b[\p{Pc}\p{L}][\p{Pd}\w]*\b)
          # Key value separator
          (:)

          \s*

          (
            (?:
              \s*
              \b
              (?: # Modifier keywords
                pub|priv|prot|final|readonly|override
                |global|local|intern|extern|mut|immut
                |post|[gs]et|put|delete|req|opt|delegate
                |safe|unsafe|virtual|sealed|abstract
                |pure|impure|early|late|covar|contra
                |in|out|inout|inplace|ref|defer|a?sync
                |static|dyn|lazy|eager|bound|free|unique
                |union|open|closed?|rec|oper|curry|opaque
                |inline|prefix|infix|suffix|unary|left|right
              )
              \b
              \s*
            )*
          )

          \s*
          (\|)(?!\|)
        end: (?<!\|)(\|)(?!\|)
        name: meta.object-literal.key.kiara
        beginCaptures:
          1: {name: entity.name.kiara}
          2: {name: punctuation.separator.key-value.kiara}
          3: {patterns: [include: "#modifiers"]}
          4: {name: punctuation.separator.arguments.kiara}
        endCaptures:
          1: {name: punctuation.separator.arguments.kiara}
        patterns:
          - include: "#argument-list-content"
      - match: |
          (?x)
          (?<=^\s*|[{;,]\s*)

          \s*

          # label
          (\b[\p{Pc}\p{L}][\p{Pd}\w]*\b)

          (?=: ['"`({\[)}\]\w\s])
        name: meta.object-literal.key.kiara
        captures:
          1:
            name: constant.other.object.key.kiara
            patterns:
              - include: "#constants"
              - include: "#numbers"
              - include: "#symbols"
              - include: "#string-content"

  # Punctuation

  punctuation:
    patterns:
      - include: "#line-continuation"
      - include: "#comma"
      - include: "#double-semicolon"
      - include: "#semicolon"

  line-continuation:
    begin: \s*(`)\s*(?=/[/*](?![\p{S}\p{P}&&[^,;'"`({\[)}\]\p{Pc}]]+)|$)
    end: ^\s*(?=\S)
    captures:
      1: {name: punctuation.separator.continuation.line.kiara}
    patterns:
      - include: "#comments"

  comma:
    match: \s*(,)
    name: punctuation.separator.expression.kiara

  double-semicolon:
    match: \s*(;;)
    name: punctuation.terminator.expression.kiara

  semicolon:
    match: \s*(;)
    name: punctuation.terminator.statement.kiara

  brackets:
    patterns:
      - include: "#angle-brackets"
      - include: "#curly-brackets"
      - include: "#square-brackets"
      - include: "#round-brackets"

  generics:
    comment: Support for Turbofish syntax
    name: meta.type-arguments
    begin: (?<=^|['"`)}\]>\w\s])([?!:]:|[?!]?\.)(<)(?=['"`({\[\w])
    end: (?<=^|['"`)}\]>\w])()(>)(!\b)?
    captures:
      1:
        name: punctuation.type.arguments.kiara
        patterns: [include: "#generic-operators"]
      2: {name: punctuation.type.arguments.kiara}
      3: {name: keyword.operator.macro.kiara}
    patterns:
      - include: "#punctuation"
      - include: "#brackets"
      - include: "#types"
      - include: "#type-signature"

  generic-operators:
    name: punctuation.type.arguments.kiara
    match: |
      (?x)
      (?:
        ( # 1: optional accessor
          \?[.:]=?
        ) |
        ( # 2: assertion/call operator
          ![.:]=?
        ) |
        ( # 3: accessor operator
          (?:::|\.)=?
        )
      )
    captures:
      1: {name: keyword.operator.optional.kiara}
      2: {name: keyword.operator.assert.kiara}
      3: {name: keyword.operator.accessor.kiara}

  accessor-operators:
    name: punctuation.type.arguments.kiara
    match: |
      (?x)
      (?<=\b|>)
      (?:
        ( # 1: optional accessor
          \?[.:]=?
        ) |
        ( # 2: assertion/call operator
          ![.:]=?
        ) |
        ( # 3: accessor operator
          (?:::|\.)=?
        )
      )
      (?=\b|<)
    captures:
      1: {name: keyword.operator.optional.kiara}
      2: {name: keyword.operator.assert.kiara}
      3: {name: keyword.operator.accessor.kiara}

  angle-brackets:
    patterns:
      - comment: Type arguments. This is complicated since we don't want to match things like foo < 123 || bar > baz
        name: meta.type-arguments
        begin: (?<=^|['"`)}\]>\w\s])(<)(?=['"`({\[\w])
        end: (?<=^|['"`)}\]>\w])(>)
        captures:
          1: {name: punctuation.type.arguments.kiara}
        patterns:
          - include: "#punctuation"
          - include: "#brackets"
          - include: "#types"
          - include: "#type-signature"

  curly-brackets:
    repository:
      punctuation:
        patterns:
          - match: ","
            name: punctuation.separator.mapping.kiara
          - match: (?<=(?:['"`)}\]\w]|\\.)[\p{S}\p{P}&&[^,;'"`({\[)}\]\p{Pc}]]*):(?=['"`({\[\w\s]|$)
            name: punctuation.separator.key-value.kiara

    patterns:
      - begin: |
          (?x)
          (?<=
            (?:^|[,;'"({\[)}\]\s]) # beside a delimiter or space
            \b
              (?: # destructuring keywords
                var|val|let|const|case
              )
            \b
            (?:$|[,;'"({\[)}\]\s]) # beside a delimiter or space
            \s*
          )
          (\#?\{)\s*
        end: \s*(\})
        name: meta.brace.curly.kiara
        captures:
          1:
            name: punctuation.definition.binding-pattern.object.kiara
        patterns:
          - include: "#labels"
          - include: "#punctuation"
          - include: "#object-value"
          - include: "#object-key"
          - include: "#as-keyword"
          - include: $self
      - begin: |
          (?x)
          (?<=
            (?:^|[,;'"({\[)}\]\s]) # beside a delimiter or space
            \b
              (?: # expression keywords
                in|of|as|is|new|delete
                |unset|ref|and|x?or|not
              )
            \b
            (?:$|[,;'"({\[)}\]\s]) # beside a delimiter or space
            \s*
          )
          (\#\{)\s*
        end: \s*(\})
        name: meta.brace.curly.kiara
        captures:
          1: {name: punctuation.definition.mapping.kiara}
        patterns:
          - include: "#labels"
          - include: "#punctuation"
          - include: "#object-value"
          - include: "#object-key"
          - include: $self
      - begin: |
          (?x)
          (?<=
            (?:^|[,;'"({\[)}\]\s]) # beside a delimiter or space
            \b
              (?: # expression keywords
                in|of|as|is|new|delete
                |unset|ref|and|x?or|not
              )
            \b
            (?:$|[,;'"({\[)}\]\s]) # beside a delimiter or space
            \s*
          )
          (\{)\s*
        end: \s*(\})
        name: meta.brace.curly.kiara
        captures:
          1: {name: punctuation.definition.dictionary.kiara}
        patterns:
          - include: "#labels"
          - include: "#punctuation"
          - include: "#object-value"
          - include: "#object-key"
          - include: $self
      - begin: |
          (?x)
          (?<=
            (?:
                (?:^|[\s\p{P}\p{S}]):\|\s+\|
              | (?:^|[,;'"`)}\]\w\s]|\\.)\|
              | ^\s*\|
            )
            \s*
          )
          (\#\{)\s*
        end: \s*(\})
        name: meta.brace.curly.kiara
        captures:
          1: {name: punctuation.section.class.kiara}
        patterns:
          - include: $self
      - begin: |
          (?x)
          (?<=
            (?:
                (?:^|[\s\p{P}\p{S}]):\|\s+\|
              | (?:^|[,;'"`)}\]\w\s]|\\.)\|
              | ^\s*\|
            )
            \s*
          )
          (\{)\s*
        end: \s*(\})
        name: meta.brace.curly.kiara
        captures:
          1: {name: punctuation.definition.block.kiara}
        patterns:
          - include: $self
      - begin: |
          (?x)
          (?<=
            (?:
                ^
              | [,;({\[]
              | (?:^|[,;({\[)}\]\w'"`]|\\.):\s*
              | [\p{S}\p{P}&&[^,;'"`({\[)}\]\p{Pc}]]+
            )
            \s*
          )
          (\#\{)\s*
        end: \s*(\})
        name: meta.brace.curly.kiara
        captures:
          1: {name: punctuation.definition.mapping.kiara}
        patterns:
          - include: "#labels"
          - include: "#punctuation"
          - include: "#object-value"
          - include: "#object-key"
          - include: $self
      - begin: |
          (?x)
          (?<=
            (?:
                ^
              | [,;({\[]
              | (?:^|[,;({\[)}\]\w'"`]|\\.):\s*
              | [\p{S}\p{P}&&[^,;'"`({\[)}\]\p{Pc}]]+
            )
            \s*
          )
          (\{)\s*
        end: \s*(\})
        name: meta.brace.curly.kiara
        captures:
          1: {name: punctuation.definition.dictionary.kiara}
        patterns:
          - include: "#labels"
          - include: "#punctuation"
          - include: "#object-value"
          - include: "#object-key"
          - include: $self
      - begin: (\#\{)\s*
        end: \s*(\})
        name: meta.brace.curly.kiara
        captures:
          1: {name: punctuation.section.class.kiara}
        patterns:
          - include: $self
      - begin: (\{)\s*
        end: \s*(\})
        name: meta.brace.curly.kiara
        captures:
          1: {name: punctuation.definition.block.kiara}
        patterns:
          - include: $self

  round-brackets:
    repository:
      punctuation:
        patterns:
          - match: ","
            name: punctuation.separator.arguments.kiara
          - match: \s*(?<!(?:(?<!\.)\.|[?!:]:)=?)\b(as)\b\s*
            name: keyword.operator.expression.as.kiara
          - match: (?<=[\w\s][(|])\.
            name: punctuation.definition.metadata.kiara

    patterns:
      - begin: |
          (?x)
          (?<=
            (?:^|[,;'"({\[)}\]\s]) # beside a delimiter or space
            \b
              (?: # destructuring keywords
                var|val|let|const|case
              )
            \b
            (?:$|[,;'"({\[)}\]\s]) # beside a delimiter or space
            \s*
          )
          (\#?\()\s*
        end: \s*(\))
        name: meta.brace.round.kiara
        captures:
          1: {name: punctuation.definition.binding-pattern.tuple.kiara}
        patterns:
          - include: "#as-keyword"
          - include: "#punctuation"
          - include: $self
      - begin: |
          (?x)
          (?<= # literal
              (?: [\w'"`)}\]] | \\.) >* !? \s*
            | [^.]\.=?|[?!:]:=?
          )
          (\#?\()\s*
        end: \s*(\))
        name: meta.brace.round.kiara
        captures:
          1: {name: punctuation.definition.parameters.kiara}
        patterns:
          - include: "#parameter-variables"
          - include: $self
      - begin: (\#\()\s*
        end: \s*(\))
        name: meta.brace.round.kiara
        captures:
          1: {name: punctuation.definition.tuple.kiara}
        patterns:
          - include: $self
      - begin: (\()\s*
        end: \s*(\))
        name: meta.brace.round.kiara
        captures:
          1: {name: punctuation.definition.expression.kiara}
        patterns:
          - include: $self

  square-brackets:
    repository:
      punctuation:
        patterns:
          - match: ","
            name: punctuation.separator.sequence.kiara

    patterns:
      - begin: |
          (?x)
          (?<=
            (?:^|[,;'"({\[)}\]\s]) # beside a delimiter or space
            \b
              (?: # destructuring keywords
                var|val|let|const|case
              )
            \b
            (?:$|[,;'"({\[)}\]\s]) # beside a delimiter or space
            \s*
          )
          (\#?\[)\s*
        end: \s*(\])
        name: meta.brace.square.kiara
        captures:
          1: {name: punctuation.definition.binding-pattern.array.kiara}
        patterns:
          - include: "#punctuation"
          - include: "#as-keyword"
          - include: $self
      - begin: |
          (?x)
          (?<=
            (?:^|[,;'"({\[)}\]\s]) # beside a delimiter or space
            \b
              (?: # destructuring keywords
                in|of|as|is|new|delete
                |unset|ref|and|x?or|not
              )
            \b
            (?:$|[,;'"({\[)}\]\s]) # beside a delimiter or space
            \s*
          )
          (\[)\s*
        end: \s*(\])
        name: meta.brace.square.kiara
        captures:
          1: {name: punctuation.definition.sequence.kiara}
        patterns:
          - include: "#punctuation"
          - include: $self
      - begin: |
          (?x)
          (?<=
            (?:^|[,;'"({\[)}\]\s]) # beside a delimiter or space
            \b
              (?: # destructuring keywords
                in|of|as|is|new|delete
                |unset|ref|and|x?or|not
              )
            \b
            (?:$|[,;'"({\[)}\]\s]) # beside a delimiter or space
            \s*
          )
          (\[)\s*
        end: \s*(\])
        name: meta.brace.square.kiara
        captures:
          1: {name: punctuation.definition.array.kiara}
        patterns:
          - include: "#punctuation"
          - include: $self
      - begin: |
          (?x)
          (?<= # literal
              (?: [\w'"`)}\]] | \\.) \s*
            | [^.]\.=?|[?!:]:=?
          )
          (\#?\[)\s*
        end: \s*(\])
        name: meta.brace.square.kiara
        captures:
          1: {name: punctuation.definition.attribute-selector.kiara}
        patterns:
          - include: $self
      - begin: (\#\[)\s*
        end: \s*(\])
        name: meta.brace.square.kiara
        captures:
          1: {name: punctuation.definition.sequence.kiara}
        patterns:
          - include: "#punctuation"
          - include: $self
      - begin: (\[)\s*
        end: \s*(\])
        name: meta.brace.square.kiara
        captures:
          1: {name: punctuation.definition.array.kiara}
        patterns:
          - include: "#punctuation"
          - include: $self

  # Support

  css-property-names:
    patterns:
      - match: (?x)\b(additiveSymbols|alignContent|alignItems|alignSelf|all|animation|animationDelay|animationDirection|animationDuration|animationFillMode|animationIterationCount|animationName|animationPlayState|animationTimingFunction|backdropFilter|backfaceVisibility|background|backgroundAttachment|backgroundBlendMode|backgroundClip|backgroundColor|backgroundImage|backgroundOrigin|backgroundPosition|backgroundPosition[XY]|backgroundRepeat|backgroundSize|bleed|blockSize|border|borderBlockEnd|borderBlockEndColor|borderBlockEndStyle|borderBlockEndWidth|borderBlockStart|borderBlockStartColor|borderBlockStartStyle|borderBlockStartWidth|borderBottom|borderBottomColor|borderBottomLeftRadius|borderBottomRightRadius|borderBottomStyle|borderBottomWidth|borderCollapse|borderColor|borderEndEndRadius|borderEndStartRadius|borderImage|borderImageOutset|borderImageRepeat|borderImageSlice|borderImageSource|borderImageWidth|borderInlineEnd|borderInlineEndColor|borderInlineEndStyle|borderInlineEndWidth|borderInlineStart|borderInlineStartColor|borderInlineStartStyle|borderInlineStartWidth|borderLeft|borderLeftColor|borderLeftStyle|borderLeftWidth|borderRadius|borderRight|borderRightColor|borderRightStyle|borderRightWidth|borderSpacing|borderStartEndRadius|borderStartStartRadius|borderStyle|borderTop|borderTopColor|borderTopLeftRadius|borderTopRightRadius|borderTopStyle|borderTopWidth|borderWidth|bottom|boxDecorationBreak|boxShadow|boxSizing|breakAfter|breakBefore|breakInside|captionSide|caretColor|clear|clip|clipPath|clipRule|color|colorAdjust|colorInterpolationFilters|columnCount|columnFill|columnGap|columnRule|columnRuleColor|columnRuleStyle|columnRuleWidth|columnSpan|columnWidth|columns|contain|content|counterIncrement|counterReset|cursor|direction|display|emptyCells|enableBackground|fallback|fill|fillOpacity|fillRule|filter|flex|flexBasis|flexDirection|flexFlow|flexGrow|flexShrink|flexWrap|float|floodColor|floodOpacity|font|fontDisplay|fontFamily|fontFeatureSettings|fontKerning|fontLanguageOverride|fontOpticalSizing|fontSize|fontSizeAdjust|fontStretch|fontStyle|fontSynthesis|fontVariant|fontVariantAlternates|fontVariantCaps|fontVariantEastAsian|fontVariantLigatures|fontVariantNumeric|fontVariantPosition|fontVariationSettings|fontWeight|gap|glyphOrientationHorizontal|glyphOrientationVertical|grid|gridArea|gridAutoColumns|gridAutoFlow|gridAutoRows|gridColumn|gridColumnEnd|gridColumnGap|gridColumnStart|gridGap|gridRow|gridRowEnd|gridRowGap|gridRowStart|gridTemplate|gridTemplateAreas|gridTemplateColumns|gridTemplateRows|hangingPunctuation|height|hyphens|imageOrientation|imageRendering|imageResolution|imeMode|initialLetter|initialLetterAlign|inlineSize|inset|insetBlock|insetBlockEnd|insetBlockStart|insetInline|insetInlineEnd|insetInlineStart|isolation|justifyContent|justifyItems|justifySelf|kerning|left|letterSpacing|lightingColor|lineBreak|lineClamp|lineHeight|listStyle|listStyleImage|listStylePosition|listStyleType|margin|marginBlockEnd|marginBlockStart|marginBottom|marginInlineEnd|marginInlineStart|marginLeft|marginRight|marginTop|markerEnd|markerMid|markerStart|marks|mask|maskBorder|maskBorderMode|maskBorderOutset|maskBorderRepeat|maskBorderSlice|maskBorderSource|maskBorderWidth|maskClip|maskComposite|maskImage|maskMode|maskOrigin|maskPosition|maskRepeat|maskSize|maskType|maxBlockSize|maxHeight|maxInlineSize|maxLines|maxWidth|maxZoom|minBlockSize|minHeight|minInlineSize|minWidth|minZoom|mixBlendMode|negative|objectFit|objectPosition|offset|offsetAnchor|offsetDistance|offsetPath|offsetPosition|offsetRotation|opacity|order|orientation|orphans|outline|outlineColor|outlineOffset|outlineStyle|outlineWidth|overflow|overflowAnchor|overflowBlock|overflowInline|overflowWrap|overflow-[xy]|overscrollBehavior|overscrollBehaviorBlock|overscrollBehaviorInline|overscrollBehavior-[xy]|pad|padding|paddingBlockEnd|paddingBlockStart|paddingBottom|paddingInlineEnd|paddingInlineStart|paddingLeft|paddingRight|paddingTop|pageBreakAfter|pageBreakBefore|pageBreakInside|paintOrder|perspective|perspectiveOrigin|placeContent|placeItems|placeSelf|pointerEvents|position|prefix|quotes|range|resize|right|rotate|rowGap|rubyAlign|rubyMerge|rubyPosition|scale|scrollBehavior|scrollMargin|scrollMarginBlock|scrollMarginBlockEnd|scrollMarginBlockStart|scrollMarginBottom|scrollMarginInline|scrollMarginInlineEnd|scrollMarginInlineStart|scrollMarginLeft|scrollMarginRight|scrollMarginTop|scrollPadding|scrollPaddingBlock|scrollPaddingBlockEnd|scrollPaddingBlockStart|scrollPaddingBottom|scrollPaddingInline|scrollPaddingInlineEnd|scrollPaddingInlineStart|scrollPaddingLeft|scrollPaddingRight|scrollPaddingTop|scrollSnapAlign|scrollSnapCoordinate|scrollSnapDestination|scrollSnapStop|scrollSnapType|scrollbarColor|scrollbarGutter|scrollbarWidth|shapeImageThreshold|shapeMargin|shapeOutside|shapeRendering|size|speakAs|src|stopColor|stopOpacity|stroke|strokeDashArray|strokeDashOffset|strokeLineCap|strokeLineJoin|strokeMiterLimit|strokeOpacity|strokeWidth|suffix|symbols|system|tabSize|tableLayout|textAlign|textAlignLast|textAnchor|textCombineUpright|textDecoration|textDecorationColor|textDecorationLine|textDecorationSkip|textDecorationSkipInk|textDecorationStyle|textEmphasis|textEmphasisColor|textEmphasisPosition|textEmphasisStyle|textIndent|textJustify|textOrientation|textOverflow|textRendering|textShadow|textSizeAdjust|textTransform|textUnderlinePosition|top|touchAction|transform|transformBox|transformOrigin|transformStyle|transition|transitionDelay|transitionDuration|transitionProperty|transitionTimingFunction|translate|unicodeBidi|unicodeRange|userSelect|userZoom|verticalAlign|visibility|whiteSpace|widows|width|willChange|wordBreak|wordSpacing|wordWrap|writingMode|zIndex|zoom|alignmentBaseline|baselineShift|clipRule|colorInterpolation|colorInterpolationFilters|colorProfile|colorRendering|cx|cy|dominantBaseline|enableBackground|fill|fillOpacity|fillRule|floodColor|floodOpacity|glyphOrientationHorizontal|glyphOrientationVertical|height|kerning|lightingColor|markerEnd|markerMid|markerStart|r|rx|ry|shapeRendering|stopColor|stopOpacity|stroke|strokeDashArray|strokeDashOffset|strokeLineCap|strokeLineJoin|strokeMiterLimit|strokeOpacity|strokeWidth|textAnchor|width|x|y|adjust|after|align|alignLast|alignment|alignmentAdjust|appearance|attachment|azimuth|backgroundBreak|balance|baseline|before|bidi|binding|bookmark|bookmarkLabel|bookmarkLevel|bookmarkTarget|borderLength|bottomColor|bottomLeftRadius|bottomRightRadius|bottomStyle|bottomWidth|box|boxAlign|boxDirection|boxFlex|boxFlexGroup|boxLines|boxOrdinalGroup|boxOrient|boxPack|break|character|collapse|column|columnBreakAfter|columnBreakBefore|count|counter|crop|cue|cueAfter|cueBefore|decoration|decorationBreak|delay|displayModel|displayRole|down|drop|dropInitialAfterAdjust|dropInitialAfterAlign|dropInitialBeforeAdjust|dropInitialBeforeAlign|dropInitialSize|dropInitialValue|duration|elevation|emphasis|family|fit|fitPosition|flexGroup|floatOffset|gap|gridColumns|gridRows|hangingPunctuation|header|hyphenate|hyphenateAfter|hyphenateBefore|hyphenateCharacter|hyphenateLines|hyphenateResource|icon|image|increment|indent|index|initialAfterAdjust|initialAfterAlign|initialBeforeAdjust|initialBeforeAlign|initialSize|initialValue|inlineBoxAlign|iterationCount|justify|label|leftColor|leftStyle|leftWidth|length|level|line|lineStacking|lineStackingRuby|lineStackingShift|lineStackingStrategy|lines|list|mark|markAfter|markBefore|marks|marquee|marqueeDirection|marqueePlayCount|marqueeSpeed|marqueeStyle|max|min|model|moveTo|name|nav|navDown|navIndex|navLeft|navRight|navUp|new|numeral|offset|ordinalGroup|orient|origin|overflowStyle|overhang|pack|page|pagePolicy|pause|pauseAfter|pauseBefore|phonemes|pitch|pitchRange|playCount|playDuring|playState|point|presentation|presentationLevel|profile|property|punctuation|punctuationTrim|radius|rate|renderingIntent|repeat|replace|reset|resolution|resource|respondTo|rest|restAfter|restBefore|richness|rightColor|rightStyle|rightWidth|role|rotation|rotationPoint|rows|ruby|rubyOverhang|rubySpan|rule|ruleColor|ruleStyle|ruleWidth|shadow|size|sizeAdjust|sizing|space|spaceCollapse|spacing|span|speak|speakHeader|speakNumeral|speakPunctuation|speech|speechRate|speed|stacking|stackingRuby|stackingShift|stackingStrategy|stress|stretch|stringSet|style|styleImage|stylePosition|styleType|target|targetName|targetNew|targetPosition|text|textHeight|textJustify|textOutline|textReplace|textWrap|timingFunction|topColor|topLeftRadius|topRightRadius|topStyle|topWidth|trim|unicode|up|userSelect|variant|voice|voiceBalance|voiceDuration|voiceFamily|voicePitch|voicePitchRange|voiceRate|voiceStress|voiceVolume|volume|weight|white|whiteSpaceCollapse|word|wrap)\b
        name: support.type.property-name.css.kiara
      - match: (?x)\b(?:ah|apple|atsc|epub|hp|khtml|moz|ms|o|rim|ro|tc|wap|webkit|xv|mso|prince)(?:[\p{Pc}\p{L}&&\P{Ll}][\w&&\P{Lu}]*)+ \b
        name: support.type.vendored.property-name.css.kiara

  css-value-names:
    comment: TODO
    patterns:
      - match: (?x)\b(aqua|black|blue|fuchsia|gray|green|lime|maroon|navy|olive|orange|purple|red|silver|teal|white|yellow)\b
        name: support.constant.color.w3c-standard-color-name.css.kiara
      - match: (?x)\b(aliceblue|antiquewhite|aquamarine|azure|beige|bisque|blanchedalmond|blueviolet|brown|burlywood|cadetblue|chartreuse|chocolate|coral|cornflowerblue|cornsilk|crimson|cyan|darkblue|darkcyan|darkgoldenrod|darkgray|darkgreen|darkgrey|darkkhaki|darkmagenta|darkolivegreen|darkorange|darkorchid|darkred|darksalmon|darkseagreen|darkslateblue|darkslategray|darkslategrey|darkturquoise|darkviolet|deeppink|deepskyblue|dimgray|dimgrey|dodgerblue|firebrick|floralwhite|forestgreen|gainsboro|ghostwhite|gold|goldenrod|greenyellow|grey|honeydew|hotpink|indianred|indigo|ivory|khaki|lavender|lavenderblush|lawngreen|lemonchiffon|lightblue|lightcoral|lightcyan|lightgoldenrodyellow|lightgray|lightgreen|lightgrey|lightpink|lightsalmon|lightseagreen|lightskyblue|lightslategray|lightslategrey|lightsteelblue|lightyellow|limegreen|linen|magenta|mediumaquamarine|mediumblue|mediumorchid|mediumpurple|mediumseagreen|mediumslateblue|mediumspringgreen|mediumturquoise|mediumvioletred|midnightblue|mintcream|mistyrose|moccasin|navajowhite|oldlace|olivedrab|orangered|orchid|palegoldenrod|palegreen|paleturquoise|palevioletred|papayawhip|peachpuff|peru|pink|plum|powderblue|rebeccapurple|rosybrown|royalblue|saddlebrown|salmon|sandybrown|seagreen|seashell|sienna|skyblue|slateblue|slategray|slategrey|snow|springgreen|steelblue|tan|thistle|tomato|transparent|turquoise|violet|wheat|whitesmoke|yellowgreen)\b
        name: support.constant.color.w3c-extended-color-name.css.kiara
      - match: (?x)\b(currentColor)\b
        name: support.constant.color.current.css.kiara
      - match: (?x)\b(ActiveBorder|ActiveCaption|AppWorkspace|Background|ButtonFace|ButtonHighlight|ButtonShadow|ButtonText|CaptionText|GrayText|Highlight|HighlightText|InactiveBorder|InactiveCaption|InactiveCaptionText|InfoBackground|InfoText|Menu|MenuText|Scrollbar|ThreeDDarkShadow|ThreeDFace|ThreeDHighlight|ThreeDLightShadow|ThreeDShadow|Window|WindowFrame|WindowText)\b
        name: support.constant.color.system.css.kiara
      - match: (?x)\b(above|absolute|active|add|additive|afterEdge|alias|all|allPetiteCaps|allScroll|allSmallCaps|alpha|alphabetic|alternate|alternateReverse|always|antialiased|auto|autoPos|available|avoid|avoidColumn|avoidPage|avoidRegion|backwards|balance|baseline|beforeEdge|below|bevel|bidiOverride|blink|block|blockAxis|blockStart|blockEnd|bold|bolder|border|borderBox|both|bottom|bottomOutside|breakAll|breakWord|bullets|butt|capitalize|caption|cell|center|central|char|circle|clip|clone|closeQuote|closestCorner|closestSide|colResize|collapse|color|colorBurn|colorDodge|column|columnReverse|commonLigatures|compact|condensed|contain|content|contentBox|contents|contextMenu|contextual|copy|cover|crispEdges|crispEdges|crosshair|cyclic|darken|dashed|decimal|default|dense|diagonalFractions|difference|digits|disabled|disc|discretionaryLigatures|distribute|distributeAllLines|distributeLetter|distributeSpace|dot|dotted|double|doubleCircle|downleft|downright|eResize|eachLine|ease|easeIn|easeInOut|easeOut|economy|ellipse|ellipsis|embed|end|evenodd|ewResize|exact|exclude|exclusion|expanded|extends|extraCondensed|extraExpanded|fallback|farthestCorner|farthestSide|fill|fillAvailable|fillBox|filled|fitContent|fixed|flat|flex|flexEnd|flexStart|flip|flowRoot|forwards|freeze|fromImage|fullWidth|geometricPrecision|georgian|grab|grabbing|grayscale|grid|groove|hand|hanging|hardLight|help|hidden|hide|historicalForms|historicalLigatures|horizontal|horizontalTb|hue|icon|ideographAlpha|ideographNumeric|ideographParenthesis|ideographSpace|ideographic|inactive|infinite|inherit|initial|inline|inlineAxis|inlineBlock|inlineEnd|inlineFlex|inlineGrid|inlineListItem|inlineStart|inlineTable|inset|inside|interCharacter|interIdeograph|interWord|intersect|invert|isolate|isolateOverride|italic|jis04|jis78|jis83|jis90|justify|justifyAll|kannada|keepAll|landscape|large|larger|left|lighten|lighter|line|lineEdge|lineThrough|linear|linearRGB|liningNums|listItem|local|loose|lowercase|lr|lrTb|ltr|luminance|luminosity|mainSize|mandatory|manipulation|manual|marginBox|matchParent|matchSource|mathematical|maxContent|medium|menu|messageBox|middle|minContent|miter|mixed|move|multiply|nResize|narrower|neResize|nearestNeighbor|neswResize|newspaper|noChange|noClip|noCloseQuote|noCommonLigatures|noContextual|noDiscretionaryLigatures|noDrop|noHistoricalLigatures|noOpenQuote|noRepeat|none|nonzero|normal|notAllowed|nowrap|nsResize|numbers|numeric|nwResize|nwseResize|oblique|oldstyleNums|open|openQuote|optimizeLegibility|optimizeQuality|optimizeSpeed|optional|ordinal|outset|outside|over|overlay|overline|padding|paddingBox|page|painted|panDown|panLeft|panRight|panUp|panX|panY|paused|petiteCaps|pixelated|plaintext|pointer|portrait|pre|preLine|preWrap|preserve3d|progress|progressive|proportionalNums|proportionalWidth|proximity|radial|recto|region|relative|remove|repeat|repeat-[xy]|resetSize|reverse|revert|ridge|right|rl|rlTb|round|row|rowResize|rowReverse|rowSeverse|rtl|ruby|rubyBase|rubyBaseContainer|rubyText|rubyTextContainer|runIn|running|sResize|saturation|scaleDown|screen|scroll|scrollPosition|seResize|semiCondensed|semiExpanded|separate|sesame|show|sideways|sidewaysLeft|sidewaysLr|sidewaysRight|sidewaysRl|simplified|slashedZero|slice|small|smallCaps|smallCaption|smaller|smooth|softLight|solid|space|spaceAround|spaceBetween|spaceEvenly|spellOut|square|sRGB|stackedFractions|start|static|statusBar|swap|stepEnd|stepStart|sticky|stretch|strict|stroke|strokeBox|style|sub|subgrid|subpixelAntialiased|subtract|super|swResize|symbolic|table|tableCaption|tableCell|tableColumn|tableColumnGroup|tableFooterGroup|tableHeaderGroup|tableRow|tableRowGroup|tabularNums|tb|tbRl|text|textAfterEdge|textBeforeEdge|textBottom|textTop|thick|thin|titlingCaps|top|topOutside|touch|traditional|transparent|triangle|ultraCondensed|ultraExpanded|under|underline|unicase|unset|upleft|uppercase|upright|useGlyphOrientation|useScript|verso|vertical|verticalIdeographic|verticalLr|verticalRl|verticalText|viewBox|visible|visibleFill|visiblePainted|visibleStroke|wResize|wait|wavy|weight|whitespace|wider|words|wrap|wrapReverse|x|xLarge|xSmall|xxLarge|xxSmall|y|zero|zoomIn|zoomOut)\b
        name: support.constant.property-value.css.kiara
      - match: (?x)\b(arabicIndic|armenian|bengali|cambodian|circle|cjkDecimal|cjkEarthlyBranch|cjkHeavenlyStem|cjkIdeographic|decimal|decimalLeadingZero|devanagari|disc|disclosureClosed|disclosureOpen|ethiopicHalehameAm|ethiopicHalehameTiE[rt]|ethiopicNumeric|georgian|gujarati|gurmukhi|hangul|hangulConsonant|hebrew|hiragana|hiraganaIroha|japaneseFormal|japaneseInformal|kannada|katakana|katakanaIroha|khmer|koreanHangulFormal|koreanHanjaFormal|koreanHanjaInformal|lao|lowerAlpha|lowerArmenian|lowerGreek|lowerLatin|lowerRoman|malayalam|mongolian|myanmar|oriya|persian|simpChineseFormal|simpChineseInformal|square|tamil|telugu|thai|tibetan|tradChineseFormal|tradChineseInformal|upperAlpha|upperArmenian|upperLatin|upperRoman|urdu)\b
        name: support.constant.property-value.list-style-type.css.kiara
      - match: (?x)\b(arial|century|comic|courier|garamond|georgia|helvetica|impact|lucida|symbol|systemUi|system|tahoma|times|trebuchet|uiMonospace|uiRounded|uiSansSerif|uiSerif|utopia|verdana|webdings|sansSerif|serif|monospace)\b
        name: support.constant.font-name.css.kiara

  html-tag-names:
    patterns:
      - match: (?x)\b(all|print|screen|speech|aural|braille|embossed|handheld|projection|tty|tv)\b
        name: support.constant.media.css.kiara
      - match: (?x)\b(a|abbr|acronym|address|altGlyph|altGlyphDef|altGlyphItem|animate|animateColor|animateMotion|animateTransform|annotation|annotationXml|applet|area|article|aside|audio|b|base|basefont|bdi|bdo|bgsound|big|blink|blockquote|body|br|button|canvas|caption|center|circle|cite|clipPath|code|col|colgroup|colorProfile|command|content|cursor|data|datalist|dd|defs|del|desc|details|dfn|dialog|dir|discard|div|dl|dt|elem|ellipse|em|embed|feBlend|feColorMatrix|feComponentTransfer|feComposite|feConvolveMatrix|feDiffuseLighting|feDisplacementMap|feDistantLight|feDropShadow|feFlood|feFuncA|feFuncB|feFuncG|feFuncR|feGaussianBlur|feImage|feMerge|feMergeNode|feMorphology|feOffset|fePointLight|feSpecularLighting|feSpotLight|feTile|feTurbulence|fieldset|figcaption|figure|filter|font|fontFace|fontFaceFormat|fontFaceName|fontFaceSrc|fontFaceUri|footer|foreignObject|form|frame|frameset|g|glyph|glyphRef|hatch|hatchpath|hd|head|header|hgroup|hkern|hr|html|h[1-6]|i|iframe|image|img|input|ins|isindex|kbd|keygen|label|legend|li|line|linearGradient|link|listing|maction|main|maligngroup|malignmark|map|mark|marker|marquee|mask|math|menclose|menu|menuitem|merror|mesh|meshgradient|meshpatch|meshrow|meta|metadata|meter|mfenced|mfrac|mglyph|mi|missingGlyph|mlabeledtr|mlongdiv|mmultiscripts|mn|mo|mover|mpadded|mpath|mphantom|mroot|mrow|ms|mscarries|mscarry|msgroup|msline|mspace|msqrt|msrow|mstack|mstyle|msub|msubsup|msup|mtable|mtd|mtext|mtr|multicol|munder|munderover|nav|nextid|nobr|noembed|noframes|noscript|object|ol|optgroup|option|output|p|param|path|pattern|picture|plaintext|polygon|polyline|pre|progress|q|radialGradient|rb|rect|rp|rt|rtc|ruby|s|samp|script|section|select|semantics|set|shadow|slot|small|solidcolor|source|spacer|span|stop|strike|strong|style|sub|summary|sup|svg|switch|symbol|table|tbody|td|template|text|textarea|textPath|tfoot|th|thead|time|title|tr|track|tref|tspan|tt|u|ul|use|var|video|view|vkern|wbr|xmp)\b
        name: entity.name.tag.css.kiara

  entities:
    patterns:
      - include: "#function-names"
      - include: "#constant-names"
      - include: "#type-names"
      - include: "#variable-names"

  type-names:
    comment: Names for built-in types
    patterns:
      - comment: Primitive classes
        match: |
          (?x)\s*(?<![?!]?\.|[?!:]:)\b(
            # upper flat case
            Bool|Char|Rune|Str|Sym
            |(Big)?(Num|Int|Float|Frac|Real|Imag|Complex)
            # lower flat case
            |bool|char|rune|str|sym
            |num|int|float|frac|real|imag|complex
            |(big)?(Num|Int|Float|Frac|Real|Imag|Complex)
            # upper flat case
            |[fiu](\d+|size)
            |[FIU](\d+|size)
          )\b
        name: support.type.builtin.primitive.kiara
      - comment: Data query classes
        match: |
          (?x)\s*(?<![?!]?\.|[?!:]:)\b(
            Array|Tuple|Set|Map|Object|Seq|Record|Dict
            |Process|Range|Stack|Heap|Queue|Tree|Trie|Graph
            |Future|Stream|RegExp|Func|Buffer|FrozenSe[tq]
            # lower flat case
            |array|tuple|set|map|object|seq|record|dict
            |process|range|stack|heap|queue|tree|trie|graph
            |future|stream|regexp|func|buffer|frozense[tq]
          )\b
        name: support.type.builtin.kiara
      - comment: Constant/algebraic classes
        match: |
          (?x)\s*(?<![?!]?\.|[?!:]:)\b(
            True|False|Null|Void|NaN|Inf|Empty|Unit|Object
            |Any|Mixed|Just|Some|None|Never|(Im)?pure|Const|Undef
            # lower flat case
            |true|false|null|void|nan|inf|empty|unit|obj
            |any|mixed|just|some|none|never|(im)?pure|const|undef
          )\b
        name: support.type.primitive.kiara
      - comment: Error classes | BaseError, etc
        match: \s*\b((\p{Lu}[\w&&\P{Lu}]*)+)?(Error|Exception)\b
        name: support.class.error.kiara
      - comment: Interface classes | IEnumerable, etc
        match: \s*\bI((\p{Lu}[\w&&\P{Lu}]*)+)\b
        name: entity.name.interface.kiara
      - comment: Namespace classes | NSString, etc
        match: \s*\bNS((\p{Lu}[\w&&\P{Lu}]*)+)\b
        name: entity.name.namespace.kiara
      - comment: Trait classes | Serializable, Loggable etc
        match: \s*\b((\p{Lu}[\w&&\P{Lu}]*)+)able\b
        name: support.class.trait.kiara

  support-functions:
    comment: Names for built-in functions (initial dump)
    patterns:
      - comment: predicate functions
        match: \s*\bis(\p{Lu}[\w&&\P{Lu}]*)+\b\s*
        name: support.function.predicate.kiara
      - comment: magic functions
        match: \s*\b\p{Pc}+([\p{Pc}\p{L}]\w*)+\p{Pc}+\b\s*
        name: support.function.magic.kiara

  # Generated

  strings-prefixed:
    patterns:
      - comment: single-quoted verbatim, interpolated, format, and template string
        begin: (?<!'+)((?i:fprs|fpsr|frps|frsp|fspr|fsrp|pfrs|pfsr|prfs|prsf|psfr|psrf|rfps|rfsp|rpfs|rpsf|rsfp|rspf|sfpr|sfrp|spfr|sprf|srfp|srpf))('''+|')\s*
        contentName: string.quoted.single.kiara
        end: \s*()(\2)(?!'+)
        captures:
          1: {name: storage.type.string.kiara}
          2: {name: punctuation.definition.string.kiara}
        patterns:
          - match: '''''|\$\$|%%|\#\#'
            name: constant.character.escape.kiara
          - include: "#embedded-expression"
          - include: "#embedded-format"
          - include: "#embedded-placeholder"
      - comment: double-quoted verbatim, interpolated, format, and template string
        begin: (?<!"+)((?i:fprs|fpsr|frps|frsp|fspr|fsrp|pfrs|pfsr|prfs|prsf|psfr|psrf|rfps|rfsp|rpfs|rpsf|rsfp|rspf|sfpr|sfrp|spfr|sprf|srfp|srpf))("""+|")\s*
        contentName: string.quoted.double.kiara
        end: \s*()(\2)(?!"+)
        captures:
          1: {name: storage.type.string.kiara}
          2: {name: punctuation.definition.string.kiara}
        patterns:
          - match: '""|\$\$|%%|\#\#'
            name: constant.character.escape.kiara
          - include: "#embedded-expression"
          - include: "#embedded-format"
          - include: "#embedded-placeholder"
      - comment: single-quoted verbatim, interpolated, and format string
        begin: (?<!'+)((?i:frs|fsr|rfs|rsf|sfr|srf))('''+|')\s*
        contentName: string.quoted.single.kiara
        end: \s*()(\2)(?!'+)
        captures:
          1: {name: storage.type.string.kiara}
          2: {name: punctuation.definition.string.kiara}
        patterns:
          - match: '''''|\$\$|%%'
            name: constant.character.escape.kiara
          - include: "#embedded-expression"
          - include: "#embedded-format"
      - comment: double-quoted verbatim, interpolated, and format string
        begin: (?<!"+)((?i:frs|fsr|rfs|rsf|sfr|srf))("""+|")\s*
        contentName: string.quoted.double.kiara
        end: \s*()(\2)(?!"+)
        captures:
          1: {name: storage.type.string.kiara}
          2: {name: punctuation.definition.string.kiara}
        patterns:
          - match: '""|\$\$|%%'
            name: constant.character.escape.kiara
          - include: "#embedded-expression"
          - include: "#embedded-format"
      - comment: single-quoted verbatim, interpolated, and template string
        begin: (?<!'+)((?i:prs|psr|rps|rsp|spr|srp))('''+|')\s*
        contentName: string.quoted.single.kiara
        end: \s*()(\2)(?!'+)
        captures:
          1: {name: storage.type.string.kiara}
          2: {name: punctuation.definition.string.kiara}
        patterns:
          - match: '''''|\$\$|\#\#'
            name: constant.character.escape.kiara
          - include: "#embedded-expression"
          - include: "#embedded-placeholder"
      - comment: double-quoted verbatim, interpolated, and template string
        begin: (?<!"+)((?i:prs|psr|rps|rsp|spr|srp))("""+|")\s*
        contentName: string.quoted.double.kiara
        end: \s*()(\2)(?!"+)
        captures:
          1: {name: storage.type.string.kiara}
          2: {name: punctuation.definition.string.kiara}
        patterns:
          - match: '""|\$\$|\#\#'
            name: constant.character.escape.kiara
          - include: "#embedded-expression"
          - include: "#embedded-placeholder"
      - comment: single-quoted verbatim, format, and template string
        begin: (?<!'+)((?i:fpr|frp|pfr|prf|rfp|rpf))('''+|')\s*
        contentName: string.quoted.single.kiara
        end: \s*()(\2)(?!'+)
        captures:
          1: {name: storage.type.string.kiara}
          2: {name: punctuation.definition.string.kiara}
        patterns:
          - match: '''''|%%|\#\#'
            name: constant.character.escape.kiara
          - include: "#embedded-format"
          - include: "#embedded-placeholder"
      - comment: double-quoted verbatim, format, and template string
        begin: (?<!"+)((?i:fpr|frp|pfr|prf|rfp|rpf))("""+|")\s*
        contentName: string.quoted.double.kiara
        end: \s*()(\2)(?!"+)
        captures:
          1: {name: storage.type.string.kiara}
          2: {name: punctuation.definition.string.kiara}
        patterns:
          - match: '""|%%|\#\#'
            name: constant.character.escape.kiara
          - include: "#embedded-format"
          - include: "#embedded-placeholder"
      - comment: single-quoted interpolated, format, and template string
        begin: (?<!'+)((?i:fps|fsp|pfs|psf|sfp|spf))('''+|')\s*
        contentName: string.quoted.single.kiara
        end: \s*()(\2)(?!'+)
        captures:
          1: {name: storage.type.string.kiara}
          2: {name: punctuation.definition.string.kiara}
        patterns:
          - include: "#string-escapes"
          - include: "#embedded-expression"
          - include: "#embedded-format"
          - include: "#embedded-placeholder"
      - comment: double-quoted interpolated, format, and template string
        begin: (?<!"+)((?i:fps|fsp|pfs|psf|sfp|spf))("""+|")\s*
        contentName: string.quoted.double.kiara
        end: \s*()(\2)(?!"+)
        captures:
          1: {name: storage.type.string.kiara}
          2: {name: punctuation.definition.string.kiara}
        patterns:
          - include: "#string-escapes"
          - include: "#embedded-expression"
          - include: "#embedded-format"
          - include: "#embedded-placeholder"
      - comment: single-quoted verbatim and interpolated string
        begin: (?<!'+)((?i:rs|sr))('''+|')\s*
        contentName: string.quoted.single.kiara
        end: \s*()(\2)(?!'+)
        captures:
          1: {name: storage.type.string.kiara}
          2: {name: punctuation.definition.string.kiara}
        patterns:
          - match: '''''|\$\$'
            name: constant.character.escape.kiara
          - include: "#embedded-expression"
      - comment: double-quoted verbatim and interpolated string
        begin: (?<!"+)((?i:rs|sr))("""+|")\s*
        contentName: string.quoted.double.kiara
        end: \s*()(\2)(?!"+)
        captures:
          1: {name: storage.type.string.kiara}
          2: {name: punctuation.definition.string.kiara}
        patterns:
          - match: '""|\$\$'
            name: constant.character.escape.kiara
          - include: "#embedded-expression"
      - comment: single-quoted interpolated and format string
        begin: (?<!'+)((?i:fs|sf))('''+|')\s*
        contentName: string.quoted.single.kiara
        end: \s*()(\2)(?!'+)
        captures:
          1: {name: storage.type.string.kiara}
          2: {name: punctuation.definition.string.kiara}
        patterns:
          - include: "#string-escapes"
          - include: "#embedded-expression"
          - include: "#embedded-format"
      - comment: double-quoted interpolated and format string
        begin: (?<!"+)((?i:fs|sf))("""+|")\s*
        contentName: string.quoted.double.kiara
        end: \s*()(\2)(?!"+)
        captures:
          1: {name: storage.type.string.kiara}
          2: {name: punctuation.definition.string.kiara}
        patterns:
          - include: "#string-escapes"
          - include: "#embedded-expression"
          - include: "#embedded-format"
      - comment: single-quoted verbatim and template string
        begin: (?<!'+)((?i:pr|rp))('''+|')\s*
        contentName: string.quoted.single.kiara
        end: \s*()(\2)(?!'+)
        captures:
          1: {name: storage.type.string.kiara}
          2: {name: punctuation.definition.string.kiara}
        patterns:
          - match: '''''|\#\#'
            name: constant.character.escape.kiara
          - include: "#embedded-placeholder"
      - comment: double-quoted verbatim and template string
        begin: (?<!"+)((?i:pr|rp))("""+|")\s*
        contentName: string.quoted.double.kiara
        end: \s*()(\2)(?!"+)
        captures:
          1: {name: storage.type.string.kiara}
          2: {name: punctuation.definition.string.kiara}
        patterns:
          - match: '""|\#\#'
            name: constant.character.escape.kiara
          - include: "#embedded-placeholder"
      - comment: single-quoted interpolated and template string
        begin: (?<!'+)((?i:ps|sp))('''+|')\s*
        contentName: string.quoted.single.kiara
        end: \s*()(\2)(?!'+)
        captures:
          1: {name: storage.type.string.kiara}
          2: {name: punctuation.definition.string.kiara}
        patterns:
          - include: "#string-escapes"
          - include: "#embedded-expression"
          - include: "#embedded-placeholder"
      - comment: double-quoted interpolated and template string
        begin: (?<!"+)((?i:ps|sp))("""+|")\s*
        contentName: string.quoted.double.kiara
        end: \s*()(\2)(?!"+)
        captures:
          1: {name: storage.type.string.kiara}
          2: {name: punctuation.definition.string.kiara}
        patterns:
          - include: "#string-escapes"
          - include: "#embedded-expression"
          - include: "#embedded-placeholder"
      - comment: single-quoted format and template string
        begin: (?<!'+)((?i:fp|pf))('''+|')\s*
        contentName: string.quoted.single.kiara
        end: \s*()(\2)(?!'+)
        captures:
          1: {name: storage.type.string.kiara}
          2: {name: punctuation.definition.string.kiara}
        patterns:
          - include: "#string-escapes"
          - include: "#embedded-format"
          - include: "#embedded-placeholder"
      - comment: double-quoted format and template string
        begin: (?<!"+)((?i:fp|pf))("""+|")\s*
        contentName: string.quoted.double.kiara
        end: \s*()(\2)(?!"+)
        captures:
          1: {name: storage.type.string.kiara}
          2: {name: punctuation.definition.string.kiara}
        patterns:
          - include: "#string-escapes"
          - include: "#embedded-format"
          - include: "#embedded-placeholder"
      - comment: single-quoted verbatim string
        begin: (?<!'+)((?i:r))('''+|')\s*
        contentName: string.quoted.single.kiara
        end: \s*()(\2)(?!'+)
        captures:
          1: {name: storage.type.string.kiara}
          2: {name: punctuation.definition.string.kiara}
        patterns:
          - match: "''"
            name: constant.character.escape.kiara
      - comment: double-quoted verbatim string
        begin: (?<!"+)((?i:r))("""+|")\s*
        contentName: string.quoted.double.kiara
        end: \s*()(\2)(?!"+)
        captures:
          1: {name: storage.type.string.kiara}
          2: {name: punctuation.definition.string.kiara}
        patterns:
          - match: '""'
            name: constant.character.escape.kiara
      - comment: single-quoted interpolated string
        begin: (?<!'+)((?i:s))('''+|')\s*
        contentName: string.quoted.single.kiara
        end: \s*()(\2)(?!'+)
        captures:
          1: {name: storage.type.string.kiara}
          2: {name: punctuation.definition.string.kiara}
        patterns:
          - include: "#string-escapes"
          - include: "#embedded-expression"
      - comment: double-quoted interpolated string
        begin: (?<!"+)((?i:s))("""+|")\s*
        contentName: string.quoted.double.kiara
        end: \s*()(\2)(?!"+)
        captures:
          1: {name: storage.type.string.kiara}
          2: {name: punctuation.definition.string.kiara}
        patterns:
          - include: "#string-escapes"
          - include: "#embedded-expression"
      - comment: single-quoted template string
        begin: (?<!'+)((?i:p))('''+|')\s*
        contentName: string.quoted.single.kiara
        end: \s*()(\2)(?!'+)
        captures:
          1: {name: storage.type.string.kiara}
          2: {name: punctuation.definition.string.kiara}
        patterns:
          - include: "#string-escapes"
          - include: "#embedded-placeholder"
      - comment: double-quoted template string
        begin: (?<!"+)((?i:p))("""+|")\s*
        contentName: string.quoted.double.kiara
        end: \s*()(\2)(?!"+)
        captures:
          1: {name: storage.type.string.kiara}
          2: {name: punctuation.definition.string.kiara}
        patterns:
          - include: "#string-escapes"
          - include: "#embedded-placeholder"
