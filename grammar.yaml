name: Hitori
scopeName: source.spwn # will change to Hitori once the language is out
fileTypes: [hitori, spwn]
patterns: [include: '#core']

information: |
  **Hitori** is a high-level, high-on-syntax-sugar, high-on-regret programming
  language catering to indie devs, stubborn DSL writers, and anyone who's ever
  screamed: "Why doesn't this just let me _do the thing_?!"

  Hitori aims to be the most flexible, expressive, and downright fun programming 
  language out there. It combines the best features of modern languages with a 
  sprinkle of whimsy and a dash of rebellion against the mundane.

  This grammar file covers the syntax and structure of Hitori, including its 
  unique features like s-expressions, message passing, and inline DSLs (domain-
  specific languages).

  It is designed to provide accurate syntax highlighting 
  and code analysis for Hitori source files.

important: |
  This grammar is a work in progress. Features and syntax will change
  frequently as the language evolves. In the meantime, please be patient
  and report any issues you encounter.

todo: |
  - [ ] Rework inline Markdown syntax. Refer to Texy, Textile, AsciiDoc
    and cousins for inspiration. Reimplement with these extensions:
    - [ ] Citations 
    - [x] Deleted and inserted text ~~deleted~~ ++inserted++
    - [x] Superscript ^super^
    - [x] Subscript ~sub~
    - [x] Highlighted text ==highlight==
    - [x] Redacted text ||redacted||
    - [ ] Spans !!.custom.classes span!!
    - [ ] Selectors and anchors #anchor .class
    - [ ] Code blocks 
    - [ ] Definition blocks ::: 
    - [ ] Tables
    - [ ] Headings and subheadings
  - [ ] Plan and implement all the built-in modules, classes, objects, constants
    functions and properties for Hitori's standard library.
    This would all be done in a separate PR and once the grammar is completely
    finished.
  - [ ] Multi-base numeric literals (up to base 64). Digits will be 0-9, a-z, 
    lowercase Icelandic thorn, lowercase eth, A-Z, uppercase Icelandic thorn.
  - [ ] Add new parameter binding/destructuring syntax for:
    - [ ] Strings
    - [ ] Regular expressions
    - [ ] Arrays
    - [ ] Sets
    - [ ] Maps and objects
    - [ ] Tuples
    - [ ] Function arguments
    - [ ] Variables
  - [ ] Rework function call syntax to be more consistent and terser.
    Inspired by Haskell.
  - [ ] Rework import/export/module syntax to be terse, drawing inspiration 
    from JavaScript ES6 modules, with changes such as:
      - glob file path matching (import path/**/*.hitori)
      - named imports/exports (import module{a, b, c})
      - default imports/exports (import module)
      - renaming imports/exports (import module{a: x, b: y})
      - show/hide mechanism (import module{a,b - c,d})
      - glob-style pattern matching (import module{a*, b?, c{1,2}})
  - [ ] Fix and expand regex syntax and highlighting:
    - [ ] Add and expand quantifiers and range highlighting
    - [ ] Add support for fuzzy matching (edits, insertions, deletions, etc.)
    - [ ] Improve highlighting for regexes with flags

changelog: |
  A major rewrite is underway. This language's syntax would be terser
  and thus inspired by Rust, Zig and D.

  New changes:

  - Fixed syntax highlighting of code blocks beside lambda pipes.
  - Added base 4, 6 and 12 numeric literals. Except for base 14, all even
    bases up to 16 are now supported.
  - Overall now closely resembles Rust's. This includes keywords, comments,
    literals, strings etc. Only thing I need to do is to rework how code blocks
    (i.e. clauses) are highlighted to be more consistent with Rust's own grammar.
  - Added s-expressions and message passing, which intentionally
    resembles Lisp, Clojure, Elixir and Smalltalk.
  - Numbers and escape sequences have been reworked, and will no longer accept
  - Most keywords should have a max of 6 characters.
  - Range keywords to, till and by have been removed in favor of range operators.
  - Generics now capture properly before and after function names
    For example, T.<x>, T?.<x>, T!.<x>, T::<x>, T?:<x>, T!:<x>.
    They can even be curried: x<T><U>(y).
    integers bigger than decimal 1114111 which now are highlighted as an error.
  - Base 12 (0z, \z in strings and character classes) is added back,
    with A, X, T, or turned 2 for digit 10, and B, E or turned 3 for digit 11.
  - Bases 4 and 6 have been removed, though a multi-base (up to base 64)
    numeric literal is still in the works.
  - Interpolation and formatting syntax have been reworked and fixed, and can now
    span multiple lines and beyond 20 nested layers thanks to applyEndPatternLast.
    Because of this, spacing around most of the patterns here have also been removed;
    a separate 'space' scope is added to join everything together.
  - Function call syntax is heavily standardized and would need a later fix in
    the long run. This is if a more terser variant of Hitori is in the need,
    and if so would be inspired by Haskell.
  - Fixed some bugs with regular expressions:
    - Added and expanded quantifiers and range highlighting
    - Add support for fuzzy matching (edits, insertions, deletions, etc.)
    - Improved highlighting for regexes with flags
  - Added prefixes to strings.
  - Added Python negation syntax: is not, if not, not in, not of. 
    - Removed unless/until keywords. Replaced by if not, while not.
  - Switched around regular expressions: / triggers a regex when it begins an
    expression. ` is now used to begin unquoted strings.
  - Two (or more) regular expressions in a row on the same line without a comma
    triggers a replacement string instead of a normal regular expression literal.
  - Changed up syntax highlighting of switch and match statements to be more
    consistent with JavaScript.
  - Function calls now trigger beside ( and {.
  - Added Perl/Ruby's unless and until keywords.
  - Fixed module syntax to be more consistent with JavaScript.
  - Dashes will no longer allowed in identifiers.
  - Fixed XML highlighting and attributes, inspired by Svelte, Angular (TS), HAML
    - @directive
    - #id and .class
    - :event and |pipe (both from Svelte)
    - %directive
    - &reference and *spread
    - ?boolean and @property (from Lit)
  - Added script blocks for injection of raw JavaScript.
  - Fixed keys in literal objects
  - Fixed modifier keywords beside function literals
  - Fixed default values in function arguments, thus no longer requiring trailing
    commas. 'from' and 'where' statements, the string `\| and the operator | have to
    be bracketed.
  - Slightly changed attribute selectors to allow for regexp matches.
  - Added Scala's 'given'/'using' syntax to function arguments

  Fixes:

  - Fix a bug where interpolated syntax would not be
  - Add multiline \\ syntax for interpolated JS.
  - Large regexps scattered throughout this document also have been
    rewritten with the (?x) syntax to be more readable for editors.
    - [x] Markdown syntax
    - [x] function parameters
    - [x] function calls
    - [x] identifiers and variables
    - [x] operators
    - [x] object literals
    - [x] object labels
    - [x] pipeline functions
    - [x] modifier keywords
    - [x] function assignments
    - [x] anonymous functions
    - [x] embedded content
    - [x] rounded and square brackets
    - [x] LINQ, inline SQL and constraint syntax (more to come later)
  - Fix syntax of type annotations inside generics to avoid being parsed 
    as custom operators.
  - Fix syntax of generic type parameters and constraints.
  - Match unquoted globs in routes
  - Fix syntax for JavaScript ES5 module import and export statements
  - Reimplement Markdown syntax with these extensions:
    - [ ] Citations
    - [ ] Strike-through
    - [ ] Deleted and inserted text
    - [ ] Superscript
    - [ ] Subscript
    - [ ] Spans
    - [ ] Selectors and anchors
    - [ ] Code blocks
    - [ ] Definition blocks
    - [ ] Tables
    - [ ] Headings and subheadings
  - Rework inline "Markdown" syntax. Refer to Texy, Textile, AsciiDoc and cousins.
  - Plan and implement all the built-in objects, constants and
    functions for Hitori's standard library.
    This would all be done in a separate PR and once the grammar is completely
    finished.
    - A handful of built-in properties and constants are part of this grammar
      and are used to highlight CSS properties, constants and HTML tags. Other
      than that, nothing else is present...
      at least not in the moment
    - This features would include:
      - Type, interface, module/namespace and class names
      - Functions and methods
      - Constants and properties
      - Special variables
      - Various UI elements and color names
      - Character names (LaTeX/HTML/AGLFN)
  - Add new parameter binding/destructuring syntax for:
    - [ ] Strings
    - [ ] Regular expressions
    - [ ] Arrays
    - [ ] Sets
    - [ ] Maps and objects
    - [ ] Tuples
    - [ ] Function arguments
    - [ ] Variables

define:
  entity-name: &entity-name |
    (?x) \s*\b

    (?!
      (?<!(?:(?<!\.)\.|[?!:]:)=?)\b
      (?: # keywords
        [io]n|of|as|is|new|del
        |unset|ref|and|x?or|not
        |var|val|let|const|given|using
        |func|proc|method|type|class|actor
        |impl|enum|module|struct|field
        |union|iter|macro|query|elem
        |object|realm|trait|style|script
        |go|defer|do|with|from|where
        |if|else|then|guard|when
        |for|loop|while|goto|move
        |try|throw|catch|finally|switch
        |match|case|pass|def
        |break|skip|redo|retry
        |return|yield|await|scope
        |import|export|intern|extern
        |debug|assert|check
      )
      \b
    )

    # identifier
    ([\p{Pc}\p{L}]\w*)
    \b

  keywords: |
    (?x) \s* \b

    (?<!(?:(?<!\.)\.|[?!:]:)=?)\b
      (?: # keywords
        [io]n|of|as|is|new|del
        |unset|ref|and|x?or|not
        |var|val|let|const|given|using
        |func|proc|method|type|class|actor
        |impl|enum|module|struct|field
        |union|iter|macro|query|elem
        |object|realm|trait|style|script
        |go|defer|do|with|from|where
        |if|else|then|guard|when
        |for|loop|while|goto|move
        |try|throw|catch|finally|switch
        |match|case|pass|def
        |break|skip|redo|retry
        |return|yield|await|scope
        |import|export|intern|extern
        |debug|assert|check
      )
    \b

  html-tag-names: &html-tag-names
    - match: (?x)([?!:]:|[?!]?\.)
      captures:
        1: {name: punctuation.separator.namespace.hitori}
    - match: \b([\p{Pc}\p{L}]\w*)\b(?=[:.])
      name: entity.name.tag.namespace.hitori
    - match: \b((?:[\p{Pc}\p{L}&&\P{Ll}][\w&&\P{Lu}]*)+)\b
      name: support.class.component.hitori
    - include: '#clauses'
    - include: '#declarations'
    - include: '#keywords'
    - include: '#html-tag-names'

repository:
  core:
    patterns:
      - include: '#ignore-long-lines'
      - include: '#clauses'
      - include: '#declarations'
      - include: '#keywords'
      - include: '#comments'
      - include: '#argument-list'
      - include: '#function-clause'
      - include: '#symbols'
      - include: '#decorators'
      - include: '#type-signature'
      # - include: '#illegal-identifier'
      - include: '#xml'
      - include: '#generics'
      - include: '#literals'
      - include: '#accessor-operators'
      - include: '#brackets'
      - include: '#punctuation'
      - include: '#operators'
      - include: '#function-calls'
      - include: '#variables'
      - include: '#illegal'
      - include: '#space'

  # Ignore Patterns

  ignore-long-lines:
    comment: avoid parsing files with long lines of code
    match: ^.{4097,}$

  space:
    match: \s+
    name: meta.var.expr.hitori

  # Illegal Syntax

  illegal:
    patterns:
      - match: \p{N}[\w.+-/\\]*?
        name: invalid.illegal.numeric.hitori
      - match: '[\w]+?'
        name: invalid.illegal.variable.hitori
      - match: '[({\[)}\]]+?'
        name: invalid.illegal.missing-bracket.hitori
      - match: '[\p{S}\p{P}&&[^,;''"`({\[)}\]\p{Pc}]]+'
        name: invalid.illegal.operator.hitori
      - match: \S+?
        name: invalid.illegal.uncaught.hitori

  illegal-identifier:
    applyEndPatternLast: true
    name: meta.type.hitori
    begin: (?<=\w+\b)\s*(?=\b\w+)
    end: (?=)|$
    patterns:
      - match: \s*\w+\s*
        name: invalid.illegal.identifier.hitori

  # Types

  types:
    patterns:
      - include: '#comments'
      - include: '#embedded-expression'
      - include: '#angle-brackets'
      - include: '#modifiers'
      - include: '#type-keywords'
      - include: '#type-names'
      - include: '#literals'
      - include: '#type-variables'
      - include: '#type-operators'
      - include: '#type-brackets'
      - include: '#space'

  type-variables:
    comment: |
      Four types of variables:
      - _lead_underscore
      - UPPERCASE
      - PascalCase
      - camelCase
    match: |
      (?x) \s* \b

      (?!
        (?<!(?:(?<!\.)\.|[?!:]:)=?)\b
        (?: # keywords
          [io]n|of|as|is|new|del
          |unset|ref|and|x?or|not
          |var|val|let|const|given|using
          |func|proc|method|type|class|actor
          |impl|enum|module|struct|field
          |union|iter|macro|query|elem
          |object|realm|trait|style|script
          |go|defer|do|with|from|where
          |if|else|then|guard|when
          |for|loop|while|goto|move
          |try|throw|catch|finally|switch
          |match|case|pass|def
          |break|skip|redo|retry
          |return|yield|await|scope
          |import|export|intern|extern
          |debug|assert|check
        )
        \b
      )

      (?:
        (?<=(?:^|[,;'"`(){}\[\]\w\s]|\\.)(?:[!?]?\.=?|[?!:]:=?))
        (?: # Properties
            # Leading underscore
            (\p{Pc}+\w*\b(?!\p{Pc}+))
          | # Train case
            ([\p{L}&&\P{Ll}][\w&&\P{Ll}]*)
          | # Pascal case
            ((?:[\p{Pc}\p{L}&&\P{Ll}][\w&&\P{Lu}]*)+)
          | # Camel or kebab case
            ([\p{Pc}\p{L}]\w*)
        )
        |
        (?: # Objects
            # Leading underscore
            (\p{Pc}+\w*\b(?!\p{Pc}+))
          | # Train case
            ([\p{L}&&\P{Ll}][\w&&\P{Ll}]*)
          | # Pascal case
            ((?:[\p{Pc}\p{L}&&\P{Ll}][\w&&\P{Lu}]*)+)
          | # Camel or kebab case
            ([\p{Pc}\p{L}]\w*)
        )
        (?=(?:[!?]?\.=?|[?!:]:=?|<)(?:[,;'"`(){}\[\]\w\s]|$))
        |
        (?: # Regular variables
            # Leading underscore
            (\p{Pc}+\w*\b(?!\p{Pc}+))
          | # Train case
            ([\p{L}&&\P{Ll}][\w&&\P{Ll}]*)
          | # Pascal case
            ((?:[\p{Pc}\p{L}&&\P{Ll}][\w&&\P{Lu}]*)+)
          | # Camel or kebab case
            ([\p{Pc}\p{L}]\w*)
        )
      )\b

      \s*
    captures:
      1: {name: entity.name.trait.hitori}
      2: {name: entity.name.interface.hitori}
      3: {name: entity.name.interface.hitori}
      4: {name: entity.name.trait.hitori}
      5: {name: entity.name.module.hitori}
      6: {name: entity.name.namespace.hitori}
      7: {name: entity.name.namespace.hitori}
      8: {name: entity.name.module.hitori}
      9: {name: entity.name.type.hitori}
      10: {name: entity.name.class.hitori}
      11: {name: entity.name.class.hitori}
      12: {name: entity.name.type.hitori}

  type-signature:
    applyEndPatternLast: true
    name: meta.type.hitori
    begin: (?<=(?:[)}\]\w\s'"`]|\\.)\|?|^\|?)(:)(?=$|[\w\s'"`({\[])
    end: (?=)|$
    beginCaptures:
      1: {name: punctuation.definition.annotation.hitori}
    patterns:
      - include: '#types'

  type-brackets:
    patterns:
      - include: '#type-curly-brackets'
      - include: '#type-square-brackets'
      - include: '#type-round-brackets'

  type-curly-brackets:
    repository:
      punctuation:
        patterns:
          - match: ','
            name: punctuation.separator.mapping.hitori
          - match: (?<=(?:['"`)}\]\w]|\\.)[\p{S}\p{P}&&[^,;'"`({\[)}\]\p{Pc}]]*):(?=['"`({\[\w\s]|$)
            name: punctuation.separator.key-value.hitori

    patterns:
      - begin: |
          (?x)
          (?<=
            (?:^|[,;'"({\[)}\]\s]) # beside a delimiter or space
            \b
              (?: # destructuring keywords
                var|val|let|const|given|using|case
              )
            \b
            (?:$|[,;'"({\[)}\]\s]) # beside a delimiter or space
            \s*
          )
          (\#?\{)\s*
        end: \s*(\})
        name: meta.brace.curly.hitori
        captures:
          1:
            name: punctuation.definition.binding-pattern.object.hitori
        patterns:
          - include: '#labels'
          - include: '#punctuation'
          - include: '#as-keyword'
          - include: '#types'
          - include: $self
      - begin: |
          (?x)
          (?<=
            (?:^|[,;'"({\[)}\]\s]) # beside a delimiter or space
            \b
              (?: # expression keywords
                [io]n|of|as|is|new|del
                |unset|ref|and|x?or|not
              )
            \b
            (?:$|[,;'"({\[)}\]\s]) # beside a delimiter or space
            \s*
          )
          (\#\{)\s*
        end: \s*(\})
        name: meta.brace.curly.hitori
        captures:
          1: {name: punctuation.definition.mapping.hitori}
        patterns:
          - include: '#labels'
          - include: '#punctuation'
          - include: '#types'
          - include: $self
      - begin: |
          (?x)
          (?<=
            (?:^|[,;'"({\[)}\]\s]) # beside a delimiter or space
            \b
              (?: # expression keywords
                [io]n|of|as|is|new|del
                |unset|ref|and|x?or|not
              )
            \b
            (?:$|[,;'"({\[)}\]\s]) # beside a delimiter or space
            \s*
          )
          (\{)\s*
        end: \s*(\})
        name: meta.brace.curly.hitori
        captures:
          1: {name: punctuation.definition.dictionary.hitori}
        patterns:
          - include: '#labels'
          - include: '#punctuation'
          - include: '#types'
          - include: $self
      - begin: |
          (?x)
          (?<=
            (?:
                ^
              | [,;({\[]
              | (?:^|[,;({\[)}\]\w'"`]|\\.):\s*
              | [\p{S}\p{P}&&[^,;'"`({\[)}\]\p{Pc}]]+
            )
            \s*
          )
          (\#\{)\s*
        end: \s*(\})
        name: meta.brace.curly.hitori
        captures:
          1: {name: punctuation.definition.mapping.hitori}
        patterns:
          - include: '#labels'
          - include: '#punctuation'
          - include: '#types'
          - include: $self
      - begin: |
          (?x)
          (?<=
            (?:
                ^
              | [,;({\[]
              | (?:^|[,;({\[)}\]\w'"`]|\\.):\s*
              | [\p{S}\p{P}&&[^,;'"`({\[)}\]\p{Pc}]]+
            )
            \s*
          )
          (\{)\s*
        end: \s*(\})
        name: meta.brace.curly.hitori
        captures:
          1: {name: punctuation.definition.dictionary.hitori}
        patterns:
          - include: '#labels'
          - include: '#punctuation'
          - include: '#types'
          - include: $self

  type-round-brackets:
    repository:
      punctuation:
        patterns:
          - match: ','
            name: punctuation.separator.arguments.hitori
          - match: \s*(?<!(?:(?<!\.)\.|[?!:]:)=?)\b(as)\b\s*
            name: keyword.operator.expression.as.hitori
          - match: (?<=[\w\s][(|])\.
            name: punctuation.definition.metadata.hitori
    patterns:
      - begin: |
          (?x)
          (?<= # literal
              (?: [\w'"`)}\]] | \\.) >* \s*
            | [^.]\.=?|[?!:]:=?
          )
          (\#?\()\s*
        end: \s*(\))
        name: meta.brace.round.hitori
        captures:
          1: {name: punctuation.definition.parameters.hitori}
        patterns:
          - include: '#types'
          - include: $self
      - begin: |
          (?x)
          (?<=
            (?:^|[,;'"({\[)}\]\s]) # beside a delimiter or space
            \b
              (?: # destructuring keywords
                var|val|let|const|given|using|case
              )
            \b
            (?:$|[,;'"({\[)}\]\s]) # beside a delimiter or space
            \s*
          )
          (\#?\()\s*
        end: \s*(\))
        name: meta.brace.round.hitori
        captures:
          1: {name: punctuation.definition.binding-pattern.tuple.hitori}
        patterns:
          - include: '#punctuation'
          - include: '#types'
          - include: $self
      - begin: (\#\()\s*
        end: \s*(\))
        name: meta.brace.round.hitori
        captures:
          1: {name: punctuation.definition.tuple.hitori}
        patterns:
          - include: '#types'
          - include: $self
      - begin: (\()\s*
        end: \s*(\))
        name: meta.brace.round.hitori
        captures:
          1: {name: punctuation.definition.expression.hitori}
        patterns:
          - include: '#types'
          - include: $self

  type-square-brackets:
    repository:
      punctuation:
        patterns:
          - match: ','
            name: punctuation.separator.sequence.hitori
    patterns:
      - begin: |
          (?x)
          (?<= # literal
              (?: [\w'"`)}\]] | \\.) \s*
            | [^.]\.=?|[?!:]:=?
          )
          (\#?\[)\s*
        end: \s*(\])
        name: meta.brace.square.hitori
        captures:
          1: {name: punctuation.definition.attribute-selector.hitori}
        patterns:
          - include: '#types'
          - include: $self
      - begin: |
          (?x)
          (?<=
            (?:^|[,;'"({\[)}\]\s]) # beside a delimiter or space
            \b
              (?: # destructuring keywords
                var|val|let|const|given|using|case
              )
            \b
            (?:$|[,;'"({\[)}\]\s]) # beside a delimiter or space
            \s*
          )
          (\#?\[)\s*
        end: \s*(\])
        name: meta.brace.square.hitori
        captures:
          1: {name: punctuation.definition.binding-pattern.array.hitori}
        patterns:
          - include: '#punctuation'
          - include: '#types'
          - include: $self
      - begin: (\#\[)\s*
        end: \s*(\])
        name: meta.brace.square.hitori
        captures:
          1: {name: punctuation.definition.sequence.hitori}
        patterns:
          - include: '#punctuation'
          - include: '#types'
          - include: $self
      - begin: (\[)\s*
        end: \s*(\])
        name: meta.brace.square.hitori
        captures:
          1: {name: punctuation.definition.array.hitori}
        patterns:
          - include: '#punctuation'
          - include: '#types'
          - include: $self

  type-keywords:
    patterns:
      - match: \s*(?<!(?:(?<!\.)\.|[?!:]:)=?)\b(from)\b\s*
        name: storage.type.extends.hitori
      - match: \s*(?<!(?:(?<!\.)\.|[?!:]:)=?)\b(for)\b\s*
        name: storage.type.implements.hitori
      - match: \s*(?<!(?:(?<!\.)\.|[?!:]:)=?)\b(infer|as)\b\s*
        name: keyword.operator.expression.$1.hitori
      - match: \s*(?<!(?:(?<!\.)\.|[?!:]:)=?)\b(is\s+not|is)\b\s*
        name: keyword.operator.expression.is.hitori
      - match: \s*(?<!(?:(?<!\.)\.|[?!:]:)=?)\b((instance|value|pair|type|name|size|key)of)\b\s*
        name: keyword.operator.expression.$1.hitori

  type-operators:
    unused:
      - comment: Function types
        match: (?:^|\s+)(?:(\|)|(>))(?=['"`({\[\w])|(?<=['"`)}\]\w])(?:(\|)|(<))(?:$|\s+)
        captures:
          1: {name: keyword.operator.type.function.hitori}
          2: {name: keyword.operator.type.channel.hitori}
          3: {name: keyword.operator.type.function.hitori}
          4: {name: keyword.operator.type.channel.hitori}

    patterns:
      - &qualified-name-separators
        comment: Primary binary operators
        match: (?<=[)}\]\w])(?:(\?[.:]=?)|(![.:]=?)|((?:::|\.)=?))(?=[({\[\w])
        captures:
          1: {name: keyword.operator.optional.hitori}
          2: {name: keyword.operator.assert.hitori}
          3: {name: keyword.operator.accessor.hitori}
      - match: \s*(--?>|~~?>|==?>)
        name: keyword.operator.type.function.hitori
      - match: \s*(<--?|<~~?|<==?)
        name: keyword.operator.type.channel.hitori
      - comment: type unions
        match: (?<=^|[\s({\[])(\|)(?=$|[)}\]\s])|(?<=['"`)}\]\w]|\\.)(\|)(?=['"`({\[\w])
        captures:
          1: {name: keyword.operator.union.hitori}
          2: {name: keyword.operator.union.hitori}
      - comment: type operators
        match: |
          (?x)
          (?<=^|[,;'"`({\[)}\]\w\s]|\\.)
            (?:
              (\+)|(\-)|(\*)|(\/)|(\%)|(\!)
              |(\?)|(\&)|(\^)|(\~)|(\$)|(:[<>]|[<>]:)
            )
          (?=$|[,;'"`({\[)}\]\w\s])
        captures:
          1: {name: keyword.operator.sum.hitori}
          2: {name: keyword.operator.difference.hitori}
          3: {name: keyword.operator.product.hitori}
          4: {name: keyword.operator.quotient.hitori}
          5: {name: keyword.operator.remainder.hitori}
          6: {name: keyword.operator.only.hitori}
          7: {name: keyword.operator.maybe.hitori}
          8: {name: keyword.operator.intersection.hitori}
          9: {name: keyword.operator.symmetric.hitori}
          10: {name: keyword.operator.negation.hitori}
          11: {name: keyword.operator.macro.dollar.hitori}
          12: {name: keyword.operator.class.hitori}

  # Literals and Constants

  literals:
    patterns:
      - include: '#regexps'
      - include: '#strings'
      - include: '#numbers'
      - include: '#constants'
      - include: '#strings-unquoted'

  constants:
    patterns:
      - match: |
          (?x)
          (?<!(?:(?<!\.)\.|[?!:]:)=?)\b
          (?:
            (true|false) # boolean
            |(null|nan)
            |(undef) # undefined
            |(inf) # infinity
          )
          \b
        captures:
          1: {name: constant.language.boolean.$1.hitori}
          2: {name: constant.language.$2.hitori}
          3: {name: constant.language.undefined.hitori}
          4: {name: constant.language.infinity.hitori}
      - match: |
          (?x)
          (?<!(?:(?<!\.)\.|[?!:]:)=?)\b
          (?:
            (it|this|super|self) # special arguments
            |(params) # arguments
            |(constructor) # constructor
            |(prototype) # prototype
          )
          \b
        captures:
          1: {name: variable.language.$1.hitori}
          2: {name: variable.language.arguments.hitori}
          3: {name: variable.language.constructor.hitori}
          4: {name: variable.language.prototype.hitori}
      - match: |
          (?x)
          (?<!(?:(?<!\.)\.|[?!:]:)=?)\b
          (
            console|document|window|global|process|require|module|exports
            |navigator|location|history|localStorage|sessionStorage
          )
          \b
        captures:
          1: {name: support.type.object.$1.hitori}

  # Numbers

  numbers:
    applyEndPatternLast: true
    begin: (?<!\.)(?=\d)
    end: \b
    name: meta.number.hitori
    patterns:
      - comment: hexadecimal integer literal
        name: constant.numeric.hexadecimal.hitori
        match: |
          (?ix) \b
            (0x) # prefix
            \h [\h_]* # integer part
            (\.)? # decimal point
            [\h_]* # fractional part
            (?: # exponent part
              (p) # delimiter
              ([+-])? # sign
              ([\d_]+) # mantissa
            )?
            ([\p{Pc}\p{L}]\w*)? # type suffix
          \b
        captures:
          1: {name: storage.type.numeric.hitori}
          2: {name: keyword.other.unit.hitori}
          3: {name: keyword.operator.expression.exponent.hitori}
          4: {name: keyword.operator.exponent.sign.hitori}
          5: {name: constant.numeric.decimal.exponent.mantissa.hitori}
          6: {name: keyword.other.unit.hitori}
      - comment: duodecimal integer literal
        name: constant.numeric.duodecimal.hitori
        match: |
          (?ix) \b
            (0z) # prefix
            [\d\u218a\u218babetx] [\d\u218a\u218babetx_]* # integer part
            (\.)? # decimal point
            [\d\u218a\u218babetx_]* # fractional part
            (?: # exponent part
              (p) # delimiter
              ([+-])? # sign
              ([\d_]+) # mantissa
            )?
            ([\p{Pc}\p{L}]\w*)? # type suffix
          \b
        captures:
          1: {name: storage.type.numeric.hitori}
          2: {name: keyword.other.unit.hitori}
          3: {name: keyword.operator.expression.exponent.hitori}
          4: {name: keyword.operator.exponent.sign.hitori}
          5: {name: constant.numeric.decimal.exponent.mantissa.hitori}
          6: {name: keyword.other.unit.hitori}
      - comment: octal integer literal
        name: constant.numeric.octal.hitori
        match: |
          (?ix) \b
            (0o) # prefix
            [0-7] [0-7_]* # integer part
            (\.)? # decimal point
            [0-7_]* # fractional part
            (?: # exponent part
              (p) # delimiter
              ([+-])? # sign
              ([\d_]+) # mantissa
            )?
            ([\p{Pc}\p{L}]\w*)? # type suffix
          \b
        captures:
          1: {name: storage.type.numeric.hitori}
          2: {name: keyword.other.unit.hitori}
          3: {name: keyword.operator.expression.exponent.hitori}
          4: {name: keyword.operator.exponent.sign.hitori}
          5: {name: constant.numeric.decimal.exponent.mantissa.hitori}
          6: {name: keyword.other.unit.hitori}
      - comment: binary integer literal
        name: constant.numeric.binary.hitori
        match: |
          (?ix) \b
            (0b) # prefix
            [01] [01_]* # integer part
            (\.)? # decimal point
            [01_]* # fractional part
            (?: # exponent part
              (p) # delimiter
              ([+-])? # sign
              ([\d_]+) # mantissa
            )?
            ([\p{Pc}\p{L}]\w*)? # type suffix
          \b
        captures:
          1: {name: storage.type.numeric.hitori}
          2: {name: keyword.other.unit.hitori}
          3: {name: keyword.operator.expression.exponent.hitori}
          4: {name: keyword.operator.exponent.sign.hitori}
          5: {name: constant.numeric.decimal.exponent.mantissa.hitori}
          6: {name: keyword.other.unit.hitori}
      - comment: quaternary integer literal
        name: constant.numeric.quaternary.hitori
        match: |
          (?ix) \b
            (0q) # prefix
            [0-3] [0-3_]* # integer part
            (\.)? # decimal point
            [0-3_]* # fractional part
            (?: # exponent part
              (p) # delimiter
              ([+-])? # sign
              ([\d_]+) # mantissa
            )?
            ([\p{Pc}\p{L}]\w*)? # type suffix
          \b
        captures:
          1: {name: storage.type.numeric.hitori}
          2: {name: keyword.other.unit.hitori}
          3: {name: keyword.operator.expression.exponent.hitori}
          4: {name: keyword.operator.exponent.sign.hitori}
          5: {name: constant.numeric.decimal.exponent.mantissa.hitori}
          6: {name: keyword.other.unit.hitori}
      - comment: senary integer literal
        name: constant.numeric.senary.hitori
        match: |
          (?ix) \b
            (0s) # prefix
            [0-5] [0-5_]* # integer part
            (\.)? # decimal point
            [0-5_]* # fractional part
            (?: # exponent part
              (p) # delimiter
              ([+-])? # sign
              ([\d_]+) # mantissa
            )?
            ([\p{Pc}\p{L}]\w*)? # type suffix
          \b
        captures:
          1: {name: storage.type.numeric.hitori}
          2: {name: keyword.other.unit.hitori}
          3: {name: keyword.operator.expression.exponent.hitori}
          4: {name: keyword.operator.exponent.sign.hitori}
          5: {name: constant.numeric.decimal.exponent.mantissa.hitori}
          6: {name: keyword.other.unit.hitori}
      - comment: decimal (no prefix)
        name: constant.numeric.decimal.hitori
        match: |
          (?ix) \b
            () # prefix
            \d [\d_]* # integer part
            (\.)? # decimal point
            [\d_]* # fractional part
            (?: # exponent part
              (e) # delimiter
              ([+-])? # sign
              ([\d_]+) # mantissa
            )?
            ([\p{Pc}\p{L}]\w*)? # type suffix
          \b
        captures:
          1: {name: storage.type.numeric.hitori}
          2: {name: keyword.other.unit.hitori}
          3: {name: keyword.operator.expression.exponent.hitori}
          4: {name: keyword.operator.exponent.sign.hitori}
          5: {name: constant.numeric.decimal.exponent.mantissa.hitori}
          6: {name: keyword.other.unit.hitori}

  # Symbols

  decorators:
    applyEndPatternLast: true
    begin: (?<=^|\\.|['"`({\[)}\]\s]|(?:[)}\]\w\s'"`]|\\.)\s*[:=])(\@)(?=[\p{Pc}\p{L}])
    end: (?=)|$
    name: entity.name.decorator.hitori
    captures:
      1: {name: punctuation.definition.decorator.hitori}
      2: {name: entity.name.decorator.hitori}
    patterns:
      - include: '#function-calls'
      - include: '#sigil-function-calls'
      - match: '[?!:]:|[?!]?\.'
        name: punctuation.separator.namespace.hitori
      - include: '#brackets'
      - include: '#strings'
      - include: '#variables'

  symbols:
    patterns:
      - comment: quoted symbol
        applyEndPatternLast: true
        begin: (?<=^|\\.|['"`({\[)}\]\s]|(?:[)}\]\w\s'"`]|\\.)\s*[:=])(:)(?=[`'"])
        end: (?=)|$
        name: constant.language.symbol-type.hitori
        captures:
          1: {name: punctuation.definition.symbol.hitori}
        patterns:
          - include: '#strings-single-quoted'
          - include: '#strings-double-quoted'
          - include: '#strings-unquoted'
      - match: (?<=^|\\.|['"`({\[)}\]\s]|(?:[)}\]\w\s'"`]|\\.)\s*[:=])(:)(\b[\p{Pc}\p{L}]\w*\b)
        name: constant.other.symbol.hitori
        captures:
          1: {name: punctuation.definition.symbol.hitori}
          2: {name: constant.other.symbol.hitori}
        patterns:
          - include: '#string-escapes'

  strings-unquoted:
    comment: Unquoted string
    applyEndPatternLast: true
    begin: (`)
    end: (?=\W)|$
    name: string.template.hitori
    captures:
      1: {name: punctuation.definition.string.hitori}
    patterns:
      - match: \b\p{Pd}+\b
      - include: '#string-escapes'

  strings:
    patterns:
      - comment: multi single-quoted verbatim, interpolated, format, and template string
        begin: \s*([\\\$%#]+)('''+)\s*
        contentName: string.quoted.single.hitori
        end: \s*((\2)(?!'+))
        captures:
          1: {name: storage.type.string.hitori}
          2: {name: punctuation.definition.string.hitori}
        patterns:
          - include: '#string-escapes'
          - include: '#embedded-expression'
          - include: '#embedded-format'
          - include: '#embedded-placeholder'
      - comment: multi double-quoted verbatim, interpolated, format, and template string
        begin: \s*([\\\$%#]+)("""+)\s*
        contentName: string.quoted.double.hitori
        end: \s*((\2)(?!"+))
        captures:
          1: {name: storage.type.string.hitori}
          2: {name: punctuation.definition.string.hitori}
        patterns:
          - include: '#string-escapes'
          - include: '#embedded-expression'
          - include: '#embedded-format'
          - include: '#embedded-placeholder'
      - comment: single-quoted verbatim, interpolated, format, and template string
        begin: \s*([\\\$%#]+)(')\s*
        contentName: string.quoted.single.hitori
        end: \s*((\2)(?!'+))
        captures:
          1: {name: storage.type.string.hitori}
          2: {name: punctuation.definition.string.hitori}
        patterns:
          - include: '#string-escapes'
          - include: '#embedded-expression'
          - include: '#embedded-format'
          - include: '#embedded-placeholder'
      - comment: double-quoted verbatim, interpolated, format, and template string
        begin: \s*([\\\$%#]+)(")\s*
        contentName: string.quoted.double.hitori
        end: \s*((\2)(?!"+))
        captures:
          1: {name: storage.type.string.hitori}
          2: {name: punctuation.definition.string.hitori}
        patterns:
          - include: '#string-escapes'
          - include: '#embedded-expression'
          - include: '#embedded-format'
          - include: '#embedded-placeholder'
      - comment: multi single-quoted verbatim, interpolated, and format string
        begin: \s*([\\\$%]+)('''+)\s*
        contentName: string.quoted.single.hitori
        end: \s*((\2)(?!'+))
        captures:
          1: {name: storage.type.string.hitori}
          2: {name: punctuation.definition.string.hitori}
        patterns:
          - include: '#string-escapes'
          - include: '#embedded-expression'
          - include: '#embedded-format'
      - comment: multi double-quoted verbatim, interpolated, and format string
        begin: \s*([\\\$%]+)("""+)\s*
        contentName: string.quoted.double.hitori
        end: \s*((\2)(?!"+))
        captures:
          1: {name: storage.type.string.hitori}
          2: {name: punctuation.definition.string.hitori}
        patterns:
          - include: '#string-escapes'
          - include: '#embedded-expression'
          - include: '#embedded-format'
      - comment: single-quoted verbatim, interpolated, and format string
        begin: \s*([\\\$%]+)(')\s*
        contentName: string.quoted.single.hitori
        end: \s*((\2)(?!'+))
        captures:
          1: {name: storage.type.string.hitori}
          2: {name: punctuation.definition.string.hitori}
        patterns:
          - include: '#string-escapes'
          - include: '#embedded-expression'
          - include: '#embedded-format'
      - comment: double-quoted verbatim, interpolated, and format string
        begin: \s*([\\\$%]+)(")\s*
        contentName: string.quoted.double.hitori
        end: \s*((\2)(?!"+))
        captures:
          1: {name: storage.type.string.hitori}
          2: {name: punctuation.definition.string.hitori}
        patterns:
          - include: '#string-escapes'
          - include: '#embedded-expression'
          - include: '#embedded-format'
      - comment: multi single-quoted verbatim, interpolated, and template string
        begin: \s*([\\\$#]+)('''+)\s*
        contentName: string.quoted.single.hitori
        end: \s*((\2)(?!'+))
        captures:
          1: {name: storage.type.string.hitori}
          2: {name: punctuation.definition.string.hitori}
        patterns:
          - include: '#string-escapes'
          - include: '#embedded-expression'
          - include: '#embedded-placeholder'
      - comment: multi double-quoted verbatim, interpolated, and template string
        begin: \s*([\\\$#]+)("""+)\s*
        contentName: string.quoted.double.hitori
        end: \s*((\2)(?!"+))
        captures:
          1: {name: storage.type.string.hitori}
          2: {name: punctuation.definition.string.hitori}
        patterns:
          - include: '#string-escapes'
          - include: '#embedded-expression'
          - include: '#embedded-placeholder'
      - comment: single-quoted verbatim, interpolated, and template string
        begin: \s*([\\\$#]+)(')\s*
        contentName: string.quoted.single.hitori
        end: \s*((\2)(?!'+))
        captures:
          1: {name: storage.type.string.hitori}
          2: {name: punctuation.definition.string.hitori}
        patterns:
          - include: '#string-escapes'
          - include: '#embedded-expression'
          - include: '#embedded-placeholder'
      - comment: double-quoted verbatim, interpolated, and template string
        begin: \s*([\\\$#]+)(")\s*
        contentName: string.quoted.double.hitori
        end: \s*((\2)(?!"+))
        captures:
          1: {name: storage.type.string.hitori}
          2: {name: punctuation.definition.string.hitori}
        patterns:
          - include: '#string-escapes'
          - include: '#embedded-expression'
          - include: '#embedded-placeholder'
      - comment: multi single-quoted verbatim, format, and template string
        begin: \s*([\\%#]+)('''+)\s*
        contentName: string.quoted.single.hitori
        end: \s*((\2)(?!'+))
        captures:
          1: {name: storage.type.string.hitori}
          2: {name: punctuation.definition.string.hitori}
        patterns:
          - include: '#string-escapes'
          - include: '#embedded-format'
          - include: '#embedded-placeholder'
      - comment: multi double-quoted verbatim, format, and template string
        begin: \s*([\\%#]+)("""+)\s*
        contentName: string.quoted.double.hitori
        end: \s*((\2)(?!"+))
        captures:
          1: {name: storage.type.string.hitori}
          2: {name: punctuation.definition.string.hitori}
        patterns:
          - include: '#string-escapes'
          - include: '#embedded-format'
          - include: '#embedded-placeholder'
      - comment: single-quoted verbatim, format, and template string
        begin: \s*([\\%#]+)(')\s*
        contentName: string.quoted.single.hitori
        end: \s*((\2)(?!'+))
        captures:
          1: {name: storage.type.string.hitori}
          2: {name: punctuation.definition.string.hitori}
        patterns:
          - include: '#string-escapes'
          - include: '#embedded-format'
          - include: '#embedded-placeholder'
      - comment: double-quoted verbatim, format, and template string
        begin: \s*([\\%#]+)(")\s*
        contentName: string.quoted.double.hitori
        end: \s*((\2)(?!"+))
        captures:
          1: {name: storage.type.string.hitori}
          2: {name: punctuation.definition.string.hitori}
        patterns:
          - include: '#string-escapes'
          - include: '#embedded-format'
          - include: '#embedded-placeholder'
      - comment: multi single-quoted interpolated, format, and template string
        begin: \s*([\$%#]+)('''+)\s*
        contentName: string.quoted.single.hitori
        end: \s*((\2)(?!'+))
        captures:
          1: {name: storage.type.string.hitori}
          2: {name: punctuation.definition.string.hitori}
        patterns:
          - include: '#string-escapes'
          - include: '#embedded-expression'
          - include: '#embedded-format'
          - include: '#embedded-placeholder'
      - comment: multi double-quoted interpolated, format, and template string
        begin: \s*([\$%#]+)("""+)\s*
        contentName: string.quoted.double.hitori
        end: \s*((\2)(?!"+))
        captures:
          1: {name: storage.type.string.hitori}
          2: {name: punctuation.definition.string.hitori}
        patterns:
          - include: '#string-escapes'
          - include: '#embedded-expression'
          - include: '#embedded-format'
          - include: '#embedded-placeholder'
      - comment: single-quoted interpolated, format, and template string
        begin: \s*([\$%#]+)(')\s*
        contentName: string.quoted.single.hitori
        end: \s*((\2)(?!'+))
        captures:
          1: {name: storage.type.string.hitori}
          2: {name: punctuation.definition.string.hitori}
        patterns:
          - include: '#string-escapes'
          - include: '#embedded-expression'
          - include: '#embedded-format'
          - include: '#embedded-placeholder'
      - comment: double-quoted interpolated, format, and template string
        begin: \s*([\$%#]+)(")\s*
        contentName: string.quoted.double.hitori
        end: \s*((\2)(?!"+))
        captures:
          1: {name: storage.type.string.hitori}
          2: {name: punctuation.definition.string.hitori}
        patterns:
          - include: '#string-escapes'
          - include: '#embedded-expression'
          - include: '#embedded-format'
          - include: '#embedded-placeholder'
      - comment: multi single-quoted verbatim and interpolated string
        begin: \s*([\\\$]+)('''+)\s*
        contentName: string.quoted.single.hitori
        end: \s*((\2)(?!'+))
        captures:
          1: {name: storage.type.string.hitori}
          2: {name: punctuation.definition.string.hitori}
        patterns:
          - include: '#string-escapes'
          - include: '#embedded-expression'
      - comment: multi double-quoted verbatim and interpolated string
        begin: \s*([\\\$]+)("""+)\s*
        contentName: string.quoted.double.hitori
        end: \s*((\2)(?!"+))
        captures:
          1: {name: storage.type.string.hitori}
          2: {name: punctuation.definition.string.hitori}
        patterns:
          - include: '#string-escapes'
          - include: '#embedded-expression'
      - comment: single-quoted verbatim and interpolated string
        begin: \s*([\\\$]+)(')\s*
        contentName: string.quoted.single.hitori
        end: \s*((\2)(?!'+))
        captures:
          1: {name: storage.type.string.hitori}
          2: {name: punctuation.definition.string.hitori}
        patterns:
          - include: '#string-escapes'
          - include: '#embedded-expression'
      - comment: double-quoted verbatim and interpolated string
        begin: \s*([\\\$]+)(")\s*
        contentName: string.quoted.double.hitori
        end: \s*((\2)(?!"+))
        captures:
          1: {name: storage.type.string.hitori}
          2: {name: punctuation.definition.string.hitori}
        patterns:
          - include: '#string-escapes'
          - include: '#embedded-expression'
      - comment: multi single-quoted verbatim and format string
        begin: \s*([\\%]+)('''+)\s*
        contentName: string.quoted.single.hitori
        end: \s*((\2)(?!'+))
        captures:
          1: {name: storage.type.string.hitori}
          2: {name: punctuation.definition.string.hitori}
        patterns:
          - include: '#string-escapes'
          - include: '#embedded-format'
      - comment: multi double-quoted verbatim and format string
        begin: \s*([\\%]+)("""+)\s*
        contentName: string.quoted.double.hitori
        end: \s*((\2)(?!"+))
        captures:
          1: {name: storage.type.string.hitori}
          2: {name: punctuation.definition.string.hitori}
        patterns:
          - include: '#string-escapes'
          - include: '#embedded-format'
      - comment: single-quoted verbatim and format string
        begin: \s*([\\%]+)(')\s*
        contentName: string.quoted.single.hitori
        end: \s*((\2)(?!'+))
        captures:
          1: {name: storage.type.string.hitori}
          2: {name: punctuation.definition.string.hitori}
        patterns:
          - include: '#string-escapes'
          - include: '#embedded-format'
      - comment: double-quoted verbatim and format string
        begin: \s*([\\%]+)(")\s*
        contentName: string.quoted.double.hitori
        end: \s*((\2)(?!"+))
        captures:
          1: {name: storage.type.string.hitori}
          2: {name: punctuation.definition.string.hitori}
        patterns:
          - include: '#string-escapes'
          - include: '#embedded-format'
      - comment: multi single-quoted interpolated and format string
        begin: \s*([\$%]+)('''+)\s*
        contentName: string.quoted.single.hitori
        end: \s*((\2)(?!'+))
        captures:
          1: {name: storage.type.string.hitori}
          2: {name: punctuation.definition.string.hitori}
        patterns:
          - include: '#string-escapes'
          - include: '#embedded-expression'
          - include: '#embedded-format'
      - comment: multi double-quoted interpolated and format string
        begin: \s*([\$%]+)("""+)\s*
        contentName: string.quoted.double.hitori
        end: \s*((\2)(?!"+))
        captures:
          1: {name: storage.type.string.hitori}
          2: {name: punctuation.definition.string.hitori}
        patterns:
          - include: '#string-escapes'
          - include: '#embedded-expression'
          - include: '#embedded-format'
      - comment: single-quoted interpolated and format string
        begin: \s*([\$%]+)(')\s*
        contentName: string.quoted.single.hitori
        end: \s*((\2)(?!'+))
        captures:
          1: {name: storage.type.string.hitori}
          2: {name: punctuation.definition.string.hitori}
        patterns:
          - include: '#string-escapes'
          - include: '#embedded-expression'
          - include: '#embedded-format'
      - comment: double-quoted interpolated and format string
        begin: \s*([\$%]+)(")\s*
        contentName: string.quoted.double.hitori
        end: \s*((\2)(?!"+))
        captures:
          1: {name: storage.type.string.hitori}
          2: {name: punctuation.definition.string.hitori}
        patterns:
          - include: '#string-escapes'
          - include: '#embedded-expression'
          - include: '#embedded-format'
      - comment: multi single-quoted verbatim and template string
        begin: \s*([\\#]+)('''+)\s*
        contentName: string.quoted.single.hitori
        end: \s*((\2)(?!'+))
        captures:
          1: {name: storage.type.string.hitori}
          2: {name: punctuation.definition.string.hitori}
        patterns:
          - include: '#string-escapes'
          - include: '#embedded-placeholder'
      - comment: multi double-quoted verbatim and template string
        begin: \s*([\\#]+)("""+)\s*
        contentName: string.quoted.double.hitori
        end: \s*((\2)(?!"+))
        captures:
          1: {name: storage.type.string.hitori}
          2: {name: punctuation.definition.string.hitori}
        patterns:
          - include: '#string-escapes'
          - include: '#embedded-placeholder'
      - comment: single-quoted verbatim and template string
        begin: \s*([\\#]+)(')\s*
        contentName: string.quoted.single.hitori
        end: \s*((\2)(?!'+))
        captures:
          1: {name: storage.type.string.hitori}
          2: {name: punctuation.definition.string.hitori}
        patterns:
          - include: '#string-escapes'
          - include: '#embedded-placeholder'
      - comment: double-quoted verbatim and template string
        begin: \s*([\\#]+)(")\s*
        contentName: string.quoted.double.hitori
        end: \s*((\2)(?!"+))
        captures:
          1: {name: storage.type.string.hitori}
          2: {name: punctuation.definition.string.hitori}
        patterns:
          - include: '#string-escapes'
          - include: '#embedded-placeholder'
      - comment: multi single-quoted interpolated and template string
        begin: \s*([\$#]+)('''+)\s*
        contentName: string.quoted.single.hitori
        end: \s*((\2)(?!'+))
        captures:
          1: {name: storage.type.string.hitori}
          2: {name: punctuation.definition.string.hitori}
        patterns:
          - include: '#string-escapes'
          - include: '#embedded-expression'
          - include: '#embedded-placeholder'
      - comment: multi double-quoted interpolated and template string
        begin: \s*([\$#]+)("""+)\s*
        contentName: string.quoted.double.hitori
        end: \s*((\2)(?!"+))
        captures:
          1: {name: storage.type.string.hitori}
          2: {name: punctuation.definition.string.hitori}
        patterns:
          - include: '#string-escapes'
          - include: '#embedded-expression'
          - include: '#embedded-placeholder'
      - comment: single-quoted interpolated and template string
        begin: \s*([\$#]+)(')\s*
        contentName: string.quoted.single.hitori
        end: \s*((\2)(?!'+))
        captures:
          1: {name: storage.type.string.hitori}
          2: {name: punctuation.definition.string.hitori}
        patterns:
          - include: '#string-escapes'
          - include: '#embedded-expression'
          - include: '#embedded-placeholder'
      - comment: double-quoted interpolated and template string
        begin: \s*([\$#]+)(")\s*
        contentName: string.quoted.double.hitori
        end: \s*((\2)(?!"+))
        captures:
          1: {name: storage.type.string.hitori}
          2: {name: punctuation.definition.string.hitori}
        patterns:
          - include: '#string-escapes'
          - include: '#embedded-expression'
          - include: '#embedded-placeholder'
      - comment: multi single-quoted format and template string
        begin: \s*([%#]+)('''+)\s*
        contentName: string.quoted.single.hitori
        end: \s*((\2)(?!'+))
        captures:
          1: {name: storage.type.string.hitori}
          2: {name: punctuation.definition.string.hitori}
        patterns:
          - include: '#string-escapes'
          - include: '#embedded-format'
          - include: '#embedded-placeholder'
      - comment: multi double-quoted format and template string
        begin: \s*([%#]+)("""+)\s*
        contentName: string.quoted.double.hitori
        end: \s*((\2)(?!"+))
        captures:
          1: {name: storage.type.string.hitori}
          2: {name: punctuation.definition.string.hitori}
        patterns:
          - include: '#string-escapes'
          - include: '#embedded-format'
          - include: '#embedded-placeholder'
      - comment: single-quoted format and template string
        begin: \s*([%#]+)(')\s*
        contentName: string.quoted.single.hitori
        end: \s*((\2)(?!'+))
        captures:
          1: {name: storage.type.string.hitori}
          2: {name: punctuation.definition.string.hitori}
        patterns:
          - include: '#string-escapes'
          - include: '#embedded-format'
          - include: '#embedded-placeholder'
      - comment: double-quoted format and template string
        begin: \s*([%#]+)(")\s*
        contentName: string.quoted.double.hitori
        end: \s*((\2)(?!"+))
        captures:
          1: {name: storage.type.string.hitori}
          2: {name: punctuation.definition.string.hitori}
        patterns:
          - include: '#string-escapes'
          - include: '#embedded-format'
          - include: '#embedded-placeholder'
      - comment: multi single-quoted verbatim string
        begin: \s*(\\)('''+)\s*
        contentName: string.quoted.single.hitori
        end: \s*((\2)(?!'+))
        captures:
          1: {name: storage.type.string.hitori}
          2: {name: punctuation.definition.string.hitori}
        patterns:
          - include: '#string-escapes'
      - comment: multi double-quoted verbatim string
        begin: \s*(\\)("""+)\s*
        contentName: string.quoted.double.hitori
        end: \s*((\2)(?!"+))
        captures:
          1: {name: storage.type.string.hitori}
          2: {name: punctuation.definition.string.hitori}
        patterns:
          - include: '#string-escapes'
      - comment: single-quoted verbatim string
        begin: \s*(\\)(')\s*
        contentName: string.quoted.single.hitori
        end: \s*((\2)(?!'+))
        captures:
          1: {name: storage.type.string.hitori}
          2: {name: punctuation.definition.string.hitori}
        patterns:
          - include: '#string-escapes'
      - comment: double-quoted verbatim string
        begin: \s*(\\)(")\s*
        contentName: string.quoted.double.hitori
        end: \s*((\2)(?!"+))
        captures:
          1: {name: storage.type.string.hitori}
          2: {name: punctuation.definition.string.hitori}
        patterns:
          - include: '#string-escapes'
      - comment: multi single-quoted interpolated string
        begin: \s*(\$)('''+)\s*
        contentName: string.quoted.single.hitori
        end: \s*((\2)(?!'+))
        captures:
          1: {name: storage.type.string.hitori}
          2: {name: punctuation.definition.string.hitori}
        patterns:
          - include: '#string-escapes'
          - include: '#embedded-expression'
      - comment: multi double-quoted interpolated string
        begin: \s*(\$)("""+)\s*
        contentName: string.quoted.double.hitori
        end: \s*((\2)(?!"+))
        captures:
          1: {name: storage.type.string.hitori}
          2: {name: punctuation.definition.string.hitori}
        patterns:
          - include: '#string-escapes'
          - include: '#embedded-expression'
      - comment: single-quoted interpolated string
        begin: \s*(\$)(')\s*
        contentName: string.quoted.single.hitori
        end: \s*((\2)(?!'+))
        captures:
          1: {name: storage.type.string.hitori}
          2: {name: punctuation.definition.string.hitori}
        patterns:
          - include: '#string-escapes'
          - include: '#embedded-expression'
      - comment: double-quoted interpolated string
        begin: \s*(\$)(")\s*
        contentName: string.quoted.double.hitori
        end: \s*((\2)(?!"+))
        captures:
          1: {name: storage.type.string.hitori}
          2: {name: punctuation.definition.string.hitori}
        patterns:
          - include: '#string-escapes'
          - include: '#embedded-expression'
      - comment: multi single-quoted format string
        begin: \s*(%)('''+)\s*
        contentName: string.quoted.single.hitori
        end: \s*((\2)(?!'+))
        captures:
          1: {name: storage.type.string.hitori}
          2: {name: punctuation.definition.string.hitori}
        patterns:
          - include: '#string-escapes'
          - include: '#embedded-format'
      - comment: multi double-quoted format string
        begin: \s*(%)("""+)\s*
        contentName: string.quoted.double.hitori
        end: \s*((\2)(?!"+))
        captures:
          1: {name: storage.type.string.hitori}
          2: {name: punctuation.definition.string.hitori}
        patterns:
          - include: '#string-escapes'
          - include: '#embedded-format'
      - comment: single-quoted format string
        begin: \s*(%)(')\s*
        contentName: string.quoted.single.hitori
        end: \s*((\2)(?!'+))
        captures:
          1: {name: storage.type.string.hitori}
          2: {name: punctuation.definition.string.hitori}
        patterns:
          - include: '#string-escapes'
          - include: '#embedded-format'
      - comment: double-quoted format string
        begin: \s*(%)(")\s*
        contentName: string.quoted.double.hitori
        end: \s*((\2)(?!"+))
        captures:
          1: {name: storage.type.string.hitori}
          2: {name: punctuation.definition.string.hitori}
        patterns:
          - include: '#string-escapes'
          - include: '#embedded-format'
      - comment: multi single-quoted template string
        begin: \s*(#)('''+)\s*
        contentName: string.quoted.single.hitori
        end: \s*((\2)(?!'+))
        captures:
          1: {name: storage.type.string.hitori}
          2: {name: punctuation.definition.string.hitori}
        patterns:
          - include: '#string-escapes'
          - include: '#embedded-placeholder'
      - comment: multi double-quoted template string
        begin: \s*(#)("""+)\s*
        contentName: string.quoted.double.hitori
        end: \s*((\2)(?!"+))
        captures:
          1: {name: storage.type.string.hitori}
          2: {name: punctuation.definition.string.hitori}
        patterns:
          - include: '#string-escapes'
          - include: '#embedded-placeholder'
      - comment: single-quoted template string
        begin: \s*(#)(')\s*
        contentName: string.quoted.single.hitori
        end: \s*((\2)(?!'+))
        captures:
          1: {name: storage.type.string.hitori}
          2: {name: punctuation.definition.string.hitori}
        patterns:
          - include: '#string-escapes'
          - include: '#embedded-placeholder'
      - comment: double-quoted template string
        begin: \s*(#)(")\s*
        contentName: string.quoted.double.hitori
        end: \s*((\2)(?!"+))
        captures:
          1: {name: storage.type.string.hitori}
          2: {name: punctuation.definition.string.hitori}
        patterns:
          - include: '#string-escapes'
          - include: '#embedded-placeholder'
      - comment: multi single-quoted plain string
        begin: \s*()('''+)\s*
        contentName: string.quoted.single.hitori
        end: \s*((\2)(?!'+))
        captures:
          1: {name: storage.type.string.hitori}
          2: {name: punctuation.definition.string.hitori}
        patterns:
          - include: '#string-escapes'
      - comment: multi double-quoted plain string
        begin: \s*()("""+)\s*
        contentName: string.quoted.double.hitori
        end: \s*((\2)(?!"+))
        captures:
          1: {name: storage.type.string.hitori}
          2: {name: punctuation.definition.string.hitori}
        patterns:
          - include: '#string-escapes'
      - comment: single-quoted plain string
        begin: \s*()(')\s*
        contentName: string.quoted.single.hitori
        end: \s*((\2)(?!'+))
        captures:
          1: {name: storage.type.string.hitori}
          2: {name: punctuation.definition.string.hitori}
        patterns:
          - include: '#string-escapes'
      - comment: double-quoted plain string
        begin: \s*()(")\s*
        contentName: string.quoted.double.hitori
        end: \s*((\2)(?!"+))
        captures:
          1: {name: storage.type.string.hitori}
          2: {name: punctuation.definition.string.hitori}
        patterns:
          - include: '#string-escapes'

  string-content:
    patterns:
      - include: '#string-escapes'
      - include: '#embedded'

  string-escapes:
    patterns:
      - begin: (\\)(?=\s*$)
        end: ^\s*(?=\S)
        captures:
          1: {name: constant.character.escape.newline.hitori}
      - include: '#named-escapes'
      - include: '#numeric-escapes'
      - match: \\([cm][a-z])
        name: constant.character.control.hitori
      - match: \\[abefprnstv]
        name: constant.character.escape.hitori
      - match: \\\p{S}
        name: constant.character.escape.symbol.hitori
      - match: \\\p{P}
        name: constant.character.escape.punctuation.hitori
      - match: \\[a-zA-Z\p{C}]
        name: invalid.illegal.escape.hitori
      - match: \\\s
        name: constant.character.escape.space.hitori
      - match: \\\p{L}
        name: constant.character.escape.letter.hitori
      - match: \\\p{N}
        name: constant.character.escape.number.hitori
      - match: \\.
        name: constant.character.escape.other.hitori

  named-characters:
    name: string.unquoted.plain.in.hitori
    comment: Grammar for the Unicode Named Character Mini-Language.
    patterns:
      - applyEndPatternLast: true
        name: constant.other.function.hitori
        begin: \b([\p{Pc}\p{L}]\w*\b([:.][\p{Pc}\p{L}]\w*)*)\b(?=\{)
        beginCaptures:
          1: {patterns: [include: '#function-namespace']}
        end: (?=)|$
        patterns:
          - begin: (\{)
            end: (\})
            captures:
              1: {name: constant.other.function.hitori}
            patterns:
              - include: '#named-characters'
      - match: \b([\p{Pc}\p{L}]\w*\b([:.][\p{Pc}\p{L}]\w*)*)\b([;,]|(?=\W))
        name: constant.character.escape.hitori
        captures:
          1: {patterns: [include: '#character-namespace']}
      - include: '#string-content'
      - include: '#punctuation'
      - include: '#illegal'

  function-namespace:
    patterns:
      - match: ([\p{Pc}\p{L}]\w*)\b(?=[.:])
        name: support entity.name.tag.namespace.hitori
      - match: ([\p{Pc}\p{L}]\w*)\b
        name: support entity.name.function.member.hitori

  character-namespace:
    patterns:
      - match: ([\p{Pc}\p{L}]\w*)\b(?=[.:])
        name: constant.other.character-class.hitori
      - match: ([\p{Pc}\p{L}]\w*)\b
        name: constant.character.escape.unicode.hitori

  named-escapes:
    patterns:
      - applyEndPatternLast: true
        name: constant.other.function.hitori
        begin: \\j([\p{Pc}\p{L}]\w*\b([:.][\p{Pc}\p{L}]\w*)*)\b(?=\{)
        beginCaptures:
          1: {patterns: [include: '#function-namespace']}
        end: (?=)|$
        patterns:
          - begin: (\{)
            end: (\})
            captures:
              1: {name: constant.other.function.hitori}
            patterns:
              - include: '#named-characters'
      - match: \\j([\p{Pc}\p{L}]\w*\b([:.][\p{Pc}\p{L}]\w*)*)\b([;,]|(?=\W))
        name: constant.character.escape.hitori
        captures:
          1: {patterns: [include: '#character-namespace']}
      - begin: \\j{\s*
        end: \s*}
        name: constant.other.character-class.unicode.hitori
        patterns:
          - applyEndPatternLast: true
            name: constant.other.function.hitori
            begin: \b([\p{Pc}\p{L}]\w*\b([:.][\p{Pc}\p{L}]\w*)*)\b(?=\{)
            beginCaptures:
              1: {patterns: [include: '#function-namespace']}
            end: (?=)|$
            patterns:
              - begin: (\{)
                end: (\})
                captures:
                  1: {name: constant.other.function.hitori}
                patterns:
                  - include: '#named-characters'
          - match: \b([\p{Pc}\p{L}]\w*\b([:.][\p{Pc}\p{L}]\w*)*)\b([;,]|(?=\W))
            name: constant.character.escape.hitori
            captures:
              1: {patterns: [include: '#character-namespace']}
          - include: '#string-content'
          - include: '#punctuation'
          - include: '#illegal'

  numeric-escapes:
    comments: |
      Hexadecimal escapes \u encode UTF-16 and 32
      while \x encodes UTF-8 code points in addition
      to Unicode characters.
    patterns:
      - comment: Binary escape sequences (0 to 417777)
        match: |
          (?x)
          \\b # prefix
            0* # leading zeroes
          (?: # numbers leading to 0001 0000 1111 1111 1111 1111
              10000[01]{16}
            | [01]{1,20}
          )
            (?![01])
        name: constant.character.escape.binary.hitori
      - comment: Decimal escape sequences
        match: |
          (?x)
          \\b # prefix
            [01]+
            (?![01])
        name: invalid.illegal.escape.binary.hitori
      - begin: \\b{
        end: \s*}
        name: constant.character.escape.binary.hitori
        patterns:
          - include: '#punctuation'
          - match: |
              (?x)
                \b
              0* # leading zeroes
              (?: # numbers leading to 0001 0000 1111 1111 1111 1111
                  10000[01]{16}
                | [01]{1,20}
              )
                (?![01])
            name: constant.character.escape.binary.hitori
          - include: '#illegal'

      - comment: Quaternary escape sequences (0 to 10033333)
        match: |
          (?x)
          \\q # prefix
            0* # leading zeroes
          (?: # numbers leading to 0001 0000 1111 1111 1111 1111 (in quaternary)
              100[0-3]{8}
            | [1-3][0-3]{1,9}
            | [0-3]
          )
            (?![0-3])
        name: constant.character.escape.quaternary.hitori
      - comment: Invalid quaternary escape sequences
        match: |
          (?x)
          \\q # prefix
            [0-3]+
            (?![0-3])
        name: invalid.illegal.escape.quaternary.hitori
      - begin: \\q{
        end: \s*}
        name: constant.character.escape.quaternary.hitori
        patterns:
          - include: '#punctuation'
          - match: |
              (?x)
                \b
              0* # leading zeroes
              (?: # numbers leading to 0001 0000 1111 1111 1111 1111 (in quaternary)
                  100[0-3]{8}
                | [1-3][0-3]{1,9}
                | [0-3]
              )
                (?![0-3])
            name: constant.character.escape.quaternary.hitori
          - include: '#illegal'

      - comment: Senary escape sequences (0 to 1223043)
        match: |
          (?x)
          \\s # prefix
            0* # leading zeroes
          (?: # numbers leading to 0001 0000 1111 1111 1111 1111 (in senary)
              122304[0-3]
            | 12230[0-3][0-5]
            | 1223[0][0-5]{2}
            | 122[0-2][0-5]{3}
            | 12[0-1][0-5]{4}
            | 1[0-1][0-5]{5}
            | [1-5][0-5]{1,6}
            | [0-5]
          )
            (?![0-5])
        name: constant.character.escape.senary.hitori
      - comment: Invalid senary escape sequences
        match: |
          (?x)
          \\s # prefix
            [0-5]+
            (?![0-5])
        name: invalid.illegal.escape.senary.hitori
      - begin: \\s{
        end: \s*}
        name: constant.character.escape.senary.hitori
        patterns:
          - include: '#punctuation'
          - match: |
              (?x)
                \b
              0* # leading zeroes
              (?: # numbers leading to 0001 0000 1111 1111 1111 1111 (in senary)
                  122304[0-3]
                | 12230[0-3][0-5]
                | 1223[0][0-5]{2}
                | 122[0-2][0-5]{3}
                | 12[0-1][0-5]{4}
                | 1[0-1][0-5]{5}
                | [1-5][0-5]{1,6}
                | [0-5]
              )
                (?![0-5])
            name: constant.character.escape.senary.hitori
          - include: '#illegal'

      - comment: Octal escape sequences (0 to 4177777)
        match: |
          (?x)
          \\o # prefix
            0* # leading zeroes
          (?: # numbers leading to 4177777
              4[01][0-7]{4}
            | [1-3][0-7]{5}
            | [1-7][0-7]{1,4}
            | [0-7]
          )
            (?![0-7])
        name: constant.character.escape.octal.hitori
      - comment: Octal escape sequences
        match: |
          (?x)
          \\o # prefix
            [0-7]+
            (?![0-7])
        name: invalid.illegal.escape.octal.hitori
      - begin: \\o{
        end: \s*}
        name: constant.character.escape.octal.hitori
        patterns:
          - include: '#punctuation'
          - match: |
              (?x)
                \b
              0* # leading zeroes
              ( # numbers up to 4177777
                  4[01][0-7]{4}
                | [1-3][0-7]{5}
                | [1-7][0-7]{1,4}
                | [0-7]
              )
                (?![0-7])
            name: constant.character.escape.octal.hitori
          - include: '#illegal'

      - comment: Duodecimal escapes (0 to 4588A7)
        match: |
          (?x)
          \\z # prefix
            0* # leading zeroes
          (?: # numbers leading to 4588A7
              4588 [\u218aatx] [0-7]
            | 4588 \d          [\d\u218a\u218babetx]
            | 458  [0-7]       [\d\u218a\u218babetx]{2}
            | 45   [0-7]       [\d\u218a\u218babetx]{3}
            | 4    [0-4]       [\d\u218a\u218babetx]{4}
            | [1-3]            [\d\u218a\u218babetx]{5}
            | [\d\u218a\u218babetx]{1,5}
          )
            (?![\d\u218a\u218babetx])
        name: constant.character.escape.duodecimal.hitori
      - comment: Duodecimal escape sequences
        match: |
          (?x)
          \\z # prefix
            [\d\u218a\u218babetx]+
            (?![\d\u218a\u218babetx])
        name: invalid.illegal.escape.duodecimal.hitori
      - begin: \\z{
        end: \s*}
        name: constant.character.escape.duodecimal.hitori
        patterns:
          - include: '#punctuation'
          - match: |
              (?x)
                \b
              0* # leading zeroes
              (?: # numbers up to 4588A7
                  4588 [\u218aatx] [0-7]
                | 4588 \d          [\d\u218a\u218babetx]
                | 458  [0-7]       [\d\u218a\u218babetx]{2}
                | 45   [0-7]       [\d\u218a\u218babetx]{3}
                | 4    [0-4]       [\d\u218a\u218babetx]{4}
                | [1-3]            [\d\u218a\u218babetx]{5}
                | [\d\u218a\u218babetx]{1,5}
              )
                (?![\d\u218a\u218babetx])
            name: constant.character.escape.duodecimal.hitori
          - include: '#illegal'

      - comment: Decimal escapes (0 to 1114111)
        match: |
          (?x)
          \\d? # prefix
            0* # leading zeroes
          (?: # numbers up to 1114111
              111411    [01]
            | 111410    \d
            | 11140     \d{2}
            | 111 [0-3] \d{3}
            | 110       \d{4}
            | 10        \d{5}
            | [1-9]     \d{1,5}
            | \d
          )
            (?!\d)
        name: constant.character.escape.decimal.hitori
      - comment: Decimal escape sequences
        match: |
          (?x)
          \\d? # prefix
            \d+
            (?!\d)
        name: invalid.illegal.escape.decimal.hitori
      - begin: \\d{
        end: \s*}
        name: constant.character.escape.decimal.hitori
        patterns:
          - include: '#punctuation'
          - match: |
              (?x)
                \b
              0* # leading zeroes
              (?: # numbers up to 1114111
                    111411    [01]
                  | 111410    \d
                  | 11140     \d{2}
                  | 111 [0-3] \d{3}
                  | 110       \d{4}
                  | 10        \d{5}
                  | [1-9]     \d{1,5}
                  | \d
              )
                (?!\d)
            name: constant.character.escape.decimal.hitori
          - include: '#illegal'

      - comment: Trailing byte pair U+80-U+BF
        match: |
          (?x)
            \\x # prefix
          (?i:
            0* # leading zeroes
            [89ab]\h
          )
            (?!\h)
        name: constant.character.escape.trailing.hitori
      - comment: Leading byte pair U+C0-U+FF
        match: |
          (?x)
            \\x # prefix
          (?i:
            0* # leading zeroes
            (?: # C0 to FF
                [c-f]\h
            )
          )
            (?!\h)
        name: constant.character.escape.leading.hitori
      - comment: Hexadecimal escape sequences
        match: |
          (?x)
            \\x # prefix
          (?i:
            0* # leading zeroes
            (?: # 0 to 10FFFF
                10\h{4}
              | [1-9a-f]\h{1,4}
              | \h
            )
          )
            (?!\h)
        name: constant.character.escape.hexadecimal.hitori
      - comment: Hexadecimal escape sequences
        match: |
          (?x)
          \\x # prefix
            \h+
            (?!\h)
        name: invalid.illegal.escape.hexadecimal.hitori
      - begin: \\x{
        end: \s*}
        name: constant.character.escape.hexadecimal.hitori
        patterns:
          - include: '#punctuation'
          - comment: Trailing byte pair U+80-U+BF
            match: |
              (?x)
                \b
              (?i:
                0* # leading zeroes
                [89ab]\h # 80 to BF
              )
                (?!\h)
            name: constant.character.escape.trailing.hitori
          - comment: Leading byte pair U+C0-U+FF
            match: |
              (?x)
                \b # prefix
              (?i:
                0* # leading zeroes
                (?: # C0 to FF
                    [c-f]\h
                )
              )
              (?!\h)
            name: constant.character.escape.leading.hitori
          - match: |
              (?x)
                \b
              (?i:
                0* # leading zeroes
                (?: # 0 to 10FFFF
                    10\h{4}
                  | [1-9a-f]\h{1,4}
                  | \h
                )
              )
                (?!\h)
            name: constant.character.escape.hexadecimal.hitori
          - include: '#illegal'

      - comment: Low surrogate pairs U+DC00-DFFF
        match: |
          (?x)
            \\u # prefix
          (?i:
            0* # leading zeroes
            d[c-f] \h{2}
          )
            (?!\h)
        name: constant.character.escape.surrogate.low.hitori
      - comment: High surrogate pairs U+D800-DBFF
        match: |
          (?x)
            \\u # prefix
          (?i:
            0* # leading zeroes
            d[89ab] \h{2}
          )
            (?!\h)
        name: constant.character.escape.surrogate.high.hitori
      - comment: Hexadecimal escape sequences
        match: |
          (?x)
            \\u # prefix
          (?i:
            0* # leading zeroes
            (?: # 0 to 10FFFF
                10\h{4}
              | [1-9a-f]\h{1,4}
              | \h
            )
          )
            (?!\h)
        name: constant.character.escape.unicode.hitori
      - comment: Unicode escape sequences
        match: |
          (?x)
          \\u # prefix
            \h+
            (?!\h)
        name: invalid.illegal.escape.unicode.hitori
      - comment: Unicode escape sequences
        match: |
          (?x)
            \\u # prefix
          (?i:
            0* # leading zeroes
            (?: # 0 to 10FFFF
                10\h{4}
              | [1-9a-f]\h{1,4}
              | \h
            )
            (?!\h)
          )
        name: constant.character.escape.unicode.hitori
      - comment: Unicode escapes
        begin: \\u{
        end: \s*}
        name: constant.character.escape.unicode.hitori
        patterns:
          - include: '#punctuation'
          - match: |
              (?x)
                \b
              (?i:
                0* # leading zeroes
                d [c-f] \h{2}
              )
                (?!\h)
            name: constant.character.escape.surrogate.low.hitori
          - match: |
              (?x)
                \b
              (?i:
                0* # leading zeroes
                d [89ab] \h{2}
              )
                (?!\h)
            name: constant.character.escape.surrogate.high.hitori
          - match: |
              (?x)
                \b
              (?i:
                0* # leading zeroes
                (?: # 0 to 10FFFF
                    10\h{4}
                  | [1-9a-f]\h{1,4}
                  | \h
                )
              )
                (?!\h)
            name: constant.character.escape.unicode.hitori
          - include: '#illegal'

  # Embedded expressions

  embedded:
    patterns:
      - include: '#embedded-expression'
      - include: '#embedded-format'
      - include: '#embedded-placeholder'

  embedded-verbatim:
    patterns:
      - match: \#\#|\$\$|\%\%
        name: constant.character.escape.hitori
      - include: '#embedded-expression'
      - include: '#embedded-format'
      - include: '#embedded-placeholder'

  embedded-expression:
    patterns:
      - comment: Interpolated expression
        begin: (\${)\s*
        end: \s*(})
        name: meta.embedded.expression.hitori
        captures:
          1: {name: punctuation.definition.variable.hitori}
        patterns:
          - include: $self
      - comment: Interpolated expression
        applyEndPatternLast: true
        name: meta.embedded.expression.hitori
        begin: |
          (?x)
          (\$) # beginning of identifier
          # ignore all keywords
          (?!
            (?<!(?:(?<!\.)\.|[?!:]:)=?)\b
            (?: # keywords
              [io]n|of|as|is|new|del
              |unset|ref|and|x?or|not
              |var|val|let|const|given|using
              |func|proc|method|type|class|actor
              |impl|enum|module|struct|field
              |union|iter|macro|query|elem
              |object|realm|trait|style|script
              |go|defer|do|with|from|where
              |if|else|then|guard|when
              |for|loop|while|goto|move
              |try|throw|catch|finally|switch
              |match|case|pass|def
              |break|skip|redo|retry
              |return|yield|await|scope
              |import|export|intern|extern
              |debug|assert|check
            )
            \b
          )
          (?=[\p{Pc}\p{L}]) # next to a word
        end: (?=)|$
        captures:
          1: {name: punctuation.definition.variable.hitori}
        patterns:
          - include: '#constants'
          - include: '#generics'
          - include: '#brackets'
          - include: '#embedded-function-calls'
          - match: (?<=>|\w)(!)(?=#?[({])
            captures:
              1: {name: keyword.operator.macro.hitori}
          - include: '#variables'
          - include: '#numbers'
          - *qualified-name-separators

  interpolated-code:
    patterns:
      - comment: Interpolated expression
        begin: (\#{)\s*
        end: \s*(})
        name: meta.embedded.expression.hitori
        captures:
          1: {name: punctuation.definition.variable.hitori}
        patterns:
          - include: $self
      - comment: Interpolated expression
        applyEndPatternLast: true
        name: meta.embedded.expression.hitori
        begin: |
          (?x)
          (\#) # beginning of identifier
          # ignore all keywords
          (?!
            (?<!(?:(?<!\.)\.|[?!:]:)=?)\b
            (?: # keywords
              [io]n|of|as|is|new|del
              |unset|ref|and|x?or|not
              |var|val|let|const|given|using
              |func|proc|method|type|class|actor
              |impl|enum|module|struct|field
              |union|iter|macro|query|elem
              |object|realm|trait|style|script
              |go|defer|do|with|from|where
              |if|else|then|guard|when
              |for|loop|while|goto|move
              |try|throw|catch|finally|switch
              |match|case|pass|def
              |break|skip|redo|retry
              |return|yield|await|scope
              |import|export|intern|extern
              |debug|assert|check
            )
            \b
          )
          (?=[\p{Pc}\p{L}]) # next to a word
        end: (?=)|$
        captures:
          1: {name: punctuation.definition.variable.hitori}
        patterns:
          - include: '#constants'
          - include: '#generics'
          - include: '#brackets'
          - include: '#embedded-function-calls'
          - include: '#variables'
          - include: '#numbers'
          - *qualified-name-separators

  embedded-placeholder:
    patterns:
      - name: meta.embedded.placeholder.hitori
        match: |
          (?x)
          (\#) # sigil
          (
            (?:
              (?:&|%|\$|~~?|\*\*?)? # sigil
              [!?]? # required or optional
            )?
            [+-]? \d+ # start of range
            (?:
              (?:[>.]\.[.<]|\.\.|[=.]\.[.=]|\.\.=?|=\.=) # range operator
              [+-]? \d+ # end of range
              (?:
                \.{1,3}
                [+-]? \d+ # increment
              )?
            )?
          )
        captures:
          1: {name: punctuation.definition.anchor.hitori}
          2:
            name: constant.numeric.decimal.hitori
            patterns:
              - match: '[+-]'
                name: keyword.operator.arithmetic.hitori
              - match: (?:[>.]\.[.<]|\.\.|[=.]\.[.=]|\.\.=?|=\.=)
                name: keyword.operator.range.hitori
      - name: meta.embedded.placeholder.hitori
        match: |
          (?x)
          (\#) # sigil
          (
            (?:
              (?:&|%|\$|~~?|\*\*?) # sigil
              [!?]? # required or optional
            )
            \b
              [\p{Pc}\p{L}]\w*
            \b
            |
            # ignore all keywords
            (?!
              (?<!(?:(?<!\.)\.|[?!:]:)=?)\b
              (?: # keywords
                [io]n|of|as|is|new|del
                |unset|ref|and|x?or|not
                |var|val|let|const|given|using
                |func|proc|method|type|class|actor
                |impl|enum|module|struct|field
                |union|iter|macro|query|elem
                |object|realm|trait|style|script
                |go|defer|do|with|from|where
                |if|else|then|guard|when
                |for|loop|while|goto|move
                |try|throw|catch|finally|switch
                |match|case|pass|def
                |break|skip|redo|retry
                |return|yield|await|scope
                |import|export|intern|extern
                |debug|assert|check
              )
              \b
            )
            \b
            [\p{Pc}\p{L}]\w* # identifier
            \b
          )
        captures:
          1: {name: punctuation.definition.anchor.hitori}
          2: {patterns: [include: '#placeholder-variables']}
      - name: meta.embedded.placeholder.hitori
        begin: (\#{)\s*
        end: \s*(})
        captures:
          1: {name: punctuation.definition.anchor.hitori}
        patterns:
          - include: '#parameter-variables'
          - include: $self

  # Format and flag specifiers

  format-switch-clause:
    patterns:
      - comment: // for multiple flags at once with single-character aliases
        applyEndPatternLast: true
        begin: (?:(?<=%)|(//))([\p{Pc}\p{L}]\w*)\b
        end: (?=)|$
        captures:
          1: {name: punctuation.definition.flag.hitori}
          2: {name: storage.type.format.hitori}
        patterns:
          - comment: Format switch without value
            match: ([\p{Pc}\p{L}]\w*)
            captures:
              1: {name: keyword.other.flag.hitori}
      - comment: / for a single flag, with optional arguments
        applyEndPatternLast: true
        begin: (?:(?<=%)|(/))([\p{Pc}\p{L}]\w*)\b
        end: (?=)|$
        captures:
          1: {name: punctuation.definition.flag.hitori}
          2: {name: storage.type.format.hitori}
        patterns:
          - comment: Format switch without value
            match: ([\p{Pc}\p{L}]\w*)
            captures:
              1: {name: keyword.modifier.hitori}

  embedded-format:
    comment: Oniguruma supports only 20 levels of recursion
    applyEndPatternLast: true
    name: meta.embedded.formatting.hitori
    begin: (?<!%)(%)(?=[\p{Pc}\p{L}])
    end: (?=)|$
    captures:
      1: {name: punctuation.definition.directive.hitori}
    patterns:
      - include: '#format-syntax'

  format-syntax:
    comment: Format specifier language, inspired by MS-DOS, Bash and Python's f-strings.
    patterns:
      - comment: with optional value
        applyEndPatternLast: true
        begin: (?:(?<=%)|(\|))([\p{Pc}\p{L}]\w*)\b(:)
        end: (?=)|$
        name: storage.type.format.hitori
        captures:
          1: {name: punctuation.separator.mapping.hitori}
          2: {name: storage.type.format.hitori}
          3: {name: punctuation.separator.key-value.hitori}
        patterns:
          - include: '#constants'
          - include: '#generics'
          - include: '#brackets'
          - include: '#embedded-function-calls'
          - match: (?<=>|\w)(!)(?=#?[({])
            captures:
              1: {name: keyword.operator.macro.hitori}
          - include: '#variables'
          - include: '#numbers'
          - include: '#regexps'
          - include: '#symbols'
          - *qualified-name-separators
      - comment: type specifier
        match: (?:(?<=%)|(\|))([\p{Pc}\p{L}]\w*)\b
        name: storage.type.format.hitori
        captures:
          1: {name: punctuation.separator.mapping.hitori}
          2: {name: storage.type.format.hitori}
      - comment: // for multiple flags at once with single-character aliases
        match: (?:(?<=%)|(//))([\p{Pc}\p{L}]\w*)\b
        name: storage.type.format.hitori
        captures:
          1: {name: punctuation.definition.flag.hitori}
          2: {name: storage.type.format.hitori}
      - comment: / for a single flag, with optional arguments
        match: (?:(?<=%)|(/))([\p{Pc}\p{L}]\w*)\b
        name: storage.type.format.hitori
        captures:
          1: {name: punctuation.definition.flag.hitori}
          2: {name: storage.type.format.hitori}
      - include: '#format-switch-clause'

  # Regular expressions

  old-regexp--patterns:
    patterns:
      - applyEndPatternLast: true
        comment: Pattern section
        begin: (/>)\s*
        end: \s*(</)(\p{L}*)
        name: string.regexp.pattern.hitori
        captures:
          1: {name: punctuation.definition.regexp.hitori}
          2: {name: keyword.other.flag.hitori}
        patterns:
          - include: '#comments'
          - include: '#regexp-patterns'
          - comment: Replacement section
            begin: (</>)\s*
            end: \s*(?=</)
            name: string.regexp.replace.hitori
            captures:
              1: {name: punctuation.definition.regexp.hitori}
            patterns:
              - include: '#back-references'
              - include: '#string-content'
      - comment: Pattern section
        begin: (/)\s*
        end: \s*(/)(\p{L}*)
        name: string.regexp.pattern.hitori
        captures:
          1: {name: punctuation.definition.regexp.hitori}
          2: {name: keyword.other.flag.hitori}
        patterns:
          - include: '#regexp-patterns'

  regexps:
    applyEndPatternLast: true
    begin: |
      (?x)
      (?<=
        (?:
            # beginning of line
            ^
          | # separator
            [,;]
          | # opening bracket
            [({\[]
          | # postfix or infix operator
            [\p{S}\p{P}&&[^,;'"`({\[)}\]\p{Pc}]]+ \s
        ) \s*
        | # a keyword
        (?:
          (?:^|[,;'"({\[)}\]\s]) # beside a delimiter or space
          \b
            (?: # keywords
              [io]n|of|as|is|new|del
              |unset|ref|and|x?or|not
              |var|val|let|const|given|using
              |func|proc|method|type|class|actor
              |impl|enum|module|struct|field
              |union|iter|macro|query|elem
              |object|realm|trait|style|script
              |go|defer|do|with|from|where
              |if|else|then|guard|when
              |for|loop|while|goto|move
              |try|throw|catch|finally|switch
              |match|case|pass|def
              |break|skip|redo|retry
              |return|yield|await|scope
              |import|export|intern|extern
              |debug|assert|check
            )
          \b
        ) \s*
      ) \s*
      (?= />?)
    end: (?=)|$
    name: meta.regexp.hitori
    patterns:
      - applyEndPatternLast: true
        comment: Multi-line pattern section
        begin: (/>)\s*
        end: \s*(</)(\p{L}*)
        name: string.regexp.pattern.hitori
        captures:
          1: {name: punctuation.definition.regexp.hitori}
          2: {name: keyword.other.flag.hitori}
        patterns:
          - include: '#comments'
          - include: '#regexp-patterns'
          - comment: Multi-line replacement section
            begin: (:)\s*
            end: \s*(\|)|\s*(?=</)
            name: string.regexp.replace.hitori
            captures:
              1: {name: punctuation.definition.regexp.hitori}
            patterns:
              - include: '#back-references'
              - include: '#string-content'
      - comment: Single-line pattern section
        begin: (/)\s*(?=(?:[^\\/]|\\.)+/\p{L}*)
        end: \s*(/)(\p{L}*)
        name: string.regexp.pattern.hitori
        captures:
          1: {name: punctuation.definition.regexp.hitori}
          2: {name: keyword.other.flag.hitori}
        patterns:
          - include: '#regexp-patterns'
          - comment: Single-line replacement section
            begin: (:)\s*
            end: \s*(\|)|\s*(?=/)
            name: string.regexp.replace.hitori
            captures:
              1: {name: punctuation.definition.regexp.hitori}
            patterns:
              - include: '#back-references'
              - include: '#string-content'

  fuzzy-expression:
    patterns:
      - include: '#punctuation'
      - include: '#comments'
      - include: '#function-calls'
      - include: '#literals'
      - include: '#embedded'
      - include: '#operators'
      - include: '#clauses'
      - include: '#declarations'
      - include: '#keywords'
      - include: '#fuzzy-brackets'
      - match: \b[\p{Pc}\p{L}]\w*\b
        name: keyword.other.unit.hitori
      - include: '#space'

  fuzzy-brackets:
    patterns:
      - begin: (\{)\s*
        end: \s*(\})
        captures:
          1: {name: punctuation.definition.mapping.hitori}
        patterns:
          - match: ','
            name: punctuation.separator.mapping.hitori
          - include: '#labels'
          - include: '#fuzzy-expression'
          - include: $self
      - begin: (\[)\s*
        end: \s*(\])
        captures:
          1: {name: punctuation.definition.array.hitori}
        patterns:
          - match: ','
            name: punctuation.separator.sequence.hitori
          - include: '#fuzzy-expression'
          - include: $self
      - begin: (\()\s*
        end: \s*(\))
        captures:
          1: {name: punctuation.definition.expression.hitori}
        patterns:
          - match: ','
            name: punctuation.separator.arguments.hitori
          - include: '#fuzzy-expression'
          - include: $self

  back-references:
    patterns:
      - match: \$(\d+[+-]?|[+-]\d*)
        name: keyword.other.back-reference.hitori
      - begin: (\$<)\s*
        end: \s*(>)
        name: keyword.other.back-reference.hitori
        captures:
          1: {name: keyword.other.back-reference.hitori}
        patterns: &regex-back-references
          - include: '#variables'
          - include: '#numbers'
          - include: '#operators'
          - include: '#string-content'
      - begin: (\$(['"]))\s*
        end: \s*(\2)
        name: keyword.other.back-reference.hitori
        captures:
          1: {name: keyword.other.back-reference.hitori}
        patterns: *regex-back-references

  regexp-patterns:
    comment: |
      See https://gist.github.com/CMCDragonkai/6c933f4a7d713ef712145c5eb94a1816
      and https://www.regular-expressions.info/
    patterns:
      - include: '#comments'
      - include: '#embedded'
      - include: '#strings'
      - match: \|
        name: keyword.operator.or.hitori
      - match: \&
        name: keyword.operator.compose.hitori
      - match: \.
        name: constant.character.all.hitori
      - match: (?i)\\[by](?:{(?:[^\\{}]|\\.)+})?
        name: keyword.control.anchor.hitori
      - match: (\\[aAm<]|\^+)(?:{(?:[^\\{}]|\\.)+})?
        name: keyword.control.begin.hitori
      - match: (\\[zZM>]|\$+)(?:{(?:[^\\{}]|\\.)+})?
        name: keyword.control.end.hitori}
      - match: \\K
        name: keyword.control.keep-out.hitori
      - match: \\G
        name: keyword.control.search.hitori
      - match: \\R
        name: constant.character.control.hitori
      - match: \\[XO]
        name: constant.character.unicode.hitori
      - match: \\\d+
        name: keyword.other.back-reference.hitori
      - match: \{\s*(?:\d*\s*,){,2}\s*\d*\s*}\s*(?:(\?)|(\+)|(\*))?
        captures:
          0: {name: keyword.operator.quantifier.hitori}
          1: {name: keyword.operator.modifier.lazy.hitori}
          2: {name: keyword.operator.modifier.eager.hitori}
          3: {name: keyword.operator.modifier.greedy.hitori}
      - match: (?:(\?)|(\+)|(\*))\s*(?:(\?)|(\+)|(\*))?
        captures:
          1: {name: keyword.operator.quantifier.lazy.hitori}
          2: {name: keyword.operator.quantifier.eager.hitori}
          3: {name: keyword.operator.quantifier.greedy.hitori}
          4: {name: keyword.operator.modifier.lazy.hitori}
          5: {name: keyword.operator.modifier.eager.hitori}
          6: {name: keyword.operator.modifier.greedy.hitori}
      - begin: (\\k<)
        end: \s*(>)
        name: constant.other.back-reference.hitori
        captures:
          1: {name: keyword.other.back-reference.hitori}
        patterns: *regex-back-references
      - begin: (\\g<)
        end: \s*(>)
        name: constant.other.subroutine.hitori
        captures:
          1: {name: keyword.other.subroutine.hitori}
        patterns: *regex-back-references
      - begin: (\\k('''+|"""+|['"]))
        end: \s*(\2)
        name: constant.other.back-reference.hitori
        captures:
          1: {name: keyword.other.back-reference.hitori}
        patterns: *regex-back-references
      - begin: (\\g('''+|"""+|['"]))
        end: \s*(\2)
        name: constant.other.subroutine.hitori
        captures:
          1: {name: keyword.other.subroutine.hitori}
        patterns: *regex-back-references
      - begin: ({)
        end: \s*(})
        name: meta.fuzzy.hitori
        captures:
          1: {name: punctuation.definition.fuzzy.hitori}
        patterns:
          - applyEndPatternLast: true
            begin: (?<=^|\\.|[,;'"`({\[)}\]\w\s])(:)
            beginCaptures:
              1: {name: punctuation.separator.key-value.hitori}
            end: (?=[,;}]|)|$
            patterns: &regexp-patterns
              - include: '#regexp-patterns'
          - include: '#fuzzy-expression'
      - match: \\[abefrntv]
        name: constant.character.escape.hitori
      - match: \\[wsdhulqmji]
        name: constant.other.character-class.hitori
      - match: \\[WSDHULQMJI]
        name: constant.other.character-class.negated.hitori
      - include: '#regexp-groups'
      - include: '#regexp-character-set'
      - include: '#regexp-character-class'
      - include: '#space'

  regexp-groups:
    patterns:
      - comment: Backtracking control verb
        begin: (\(\*([\p{Pc}\p{L}]\w*)?(:)?)
        end: \s*(\))
        name: meta.group.backtrack.hitori
        captures:
          1: {name: punctuation.section.expression.hitori}
          2: {name: keyword.control.hitori}
          3: {name: punctuation.separator.colon.hitori}
        patterns:
          - include: '#regexp-patterns'
      - comment: Block comment
        begin: (\()(\?#)
        contentName: comment.block.regexp.hitori
        end: \s*(\))
        name: comment.block.regexp.hitori
        captures:
          1: {name: punctuation.definition.comment.hitori}
        patterns:
          - match: \\.
            name: comment.block.regexp.hitori
      - comment: Lookahead assertion
        begin: (\(\?=)
        end: \s*(\))
        name: meta.group.look-ahead.hitori
        captures:
          1: {name: punctuation.definition.group.look-ahead.hitori}
        patterns:
          - include: '#regexp-patterns'
      - comment: Lookbehind assertion
        begin: (\(\?<=)
        end: \s*(\))
        name: meta.group.look-behind.hitori
        captures:
          1: {name: punctuation.definition.group.look-behind.hitori}
        patterns:
          - include: '#regexp-patterns'
      - comment: Negative lookahead assertion
        begin: (\(\?!)
        end: \s*(\))
        name: meta.group.negative-look-ahead.hitori
        captures:
          1:
            name: punctuation.definition.group.negative-look-ahead.hitori
        patterns: *regexp-patterns
      - comment: Negative lookbehind assertion
        begin: (\(\?<!)
        end: \s*(\))
        name: meta.group.negative-look-behind.hitori
        captures:
          1:
            name: punctuation.definition.group.negative-look-behind.hitori
        patterns:
          - include: '#regexp-patterns'
      - comment: Match directive Oniguruma supports only 20 levels of recursion
        begin: (?x)(\(\?)(?=%)
        captures:
          1: {name: punctuation.definition.group.directive.hitori}
        end: \s*(\))
        name: meta.group.directive.hitori
        patterns:
          - include: '#format-syntax'
          - include: '#regexp-patterns'
      - comment: Longest match
        begin: (\(\?/=?)
        end: \s*(\))
        name: meta.group.longest.hitori
        captures:
          1: {name: punctuation.definition.group.longest.hitori}
        patterns:
          - include: '#regexp-patterns'
      - comment: Back-reference groups
        begin: \((\?&(?:([+-]?\d+)|([\p{Pc}\p{L}]\w*)))(:)?
        end: \s*\)
        name: meta.group.back-reference.hitori
        captures:
          0: {name: punctuation.definition.group.back-reference.hitori}
          1: {name: punctuation.definition.group.back-reference.hitori}
          2: {name: constant.numeric.index.hitori}
          3: {patterns: [include: '#variables']}
          4: {name: punctuation.separator.colon.hitori}
        patterns:
          - include: '#regexp-patterns'
      - comment: Back-reference groups
        begin: \((\?&)
        end: \s*\)
        name: meta.group.back-reference.hitori
        captures:
          0: {name: punctuation.definition.group.back-reference.hitori}
          1: {name: punctuation.definition.group.back-reference.hitori}
        patterns:
          - begin: (?<=\(\?&)('''+|"""+|['"])
            end: \s*(\1)
            name: constant.other.group.hitori
            captures:
              1: {name: punctuation.definition.group.back-reference.hitori}
            patterns: *regex-back-references
          - include: '#regexp-patterns'
      - comment: Flag modifier group
        begin: (\(\?\^?(?:([+-]?\d+?)|((?:[+-]\p{Lu}+)+|\p{Lu}+(?:[+-]\p{Lu}+)*)|((?:[+-]\p{Ll}+)+|\p{Ll}+(?:[+-]\p{Ll}+)*)))\s*(:)?
        end: \s*(\))
        name: meta.group.flag.hitori
        captures:
          0: {name: punctuation.definition.group.flag.hitori}
          1: {name: punctuation.definition.group.flag.hitori}
          2: {name: constant.numeric.index.hitori}
          3: {name: keyword.control.recursion.hitori}
          4: {name: keyword.other.flag.hitori}
          5: {name: punctuation.separator.colon.hitori}
        patterns:
          - include: '#regexp-patterns'
      - comment: Call-outs
        begin: (\(\?)(?={)
        end: \s*(\))
        name: meta.group.call-out.hitori
        captures:
          1: {name: punctuation.definition.group.call-out.hitori}
        patterns:
          - begin: (?<=\(\?)({)
            end: \s*(\})\s*([<*>])?(?:(\[)(.*?)(\]))?
            name: punctuation.definition.group.call-out.hitori
            captures:
              1: {name: punctuation.definition.group.call-out.hitori}
              2: {name: keyword.operator.range.hitori}
              3: {name: punctuation.definition.tag.hitori}
              4: {patterns: [include: '#function-names']}
              5: {name: punctuation.definition.tag.hitori}
            patterns:
              - include: $self
          - include: '#regexp-patterns'
      - comment: Atomic groups
        begin: (\(\?>)
        end: \s*(\))
        name: meta.group.atomic.hitori
        captures:
          1: {name: punctuation.definition.group.atomic.hitori}
        patterns:
          - include: '#regexp-patterns'
      - comment: Non-capturing groups
        begin: (\(\?:)
        end: \s*(\))
        name: meta.group.non-capturing.hitori
        captures:
          1: {name: punctuation.definition.group.non-capturing.hitori}
        patterns:
          - include: '#regexp-patterns'
      - comment: Branch groups
        begin: (\(\?)(?=[(|])
        end: \s*(\))
        name: meta.group.branch.hitori
        captures:
          1: {name: punctuation.definition.group.branch.hitori}
        patterns:
          - include: '#regexp-patterns'
      - comment: Absent groups
        begin: (\(\?~)
        end: \s*(\))
        name: meta.group.absent.hitori
        captures:
          1: {name: punctuation.definition.group.absent.hitori}
        patterns:
          - include: '#regexp-patterns'
      - comment: Named groups (angle brackets)
        begin: \(\?(?=<(?![!=]))
        end: \s*(\))
        name: meta.group.named.hitori
        captures:
          0: {name: punctuation.definition.group.named.hitori}
        patterns:
          - begin: (?<=\(\?)(<)
            end: \s*(>)
            name: constant.other.group.hitori
            captures:
              1: {name: punctuation.definition.group.named.hitori}
            patterns: *regex-back-references
          - include: '#regexp-patterns'
      - comment: Named groups (single or double-quotes)
        begin: \(\?(?=['"])
        end: \s*(\))
        name: meta.group.named.hitori
        captures:
          0: {name: punctuation.definition.group.named.hitori}
        patterns:
          - begin: (?<=\(\?)('''+|"""+|['"])
            end: \s*(\1)
            name: constant.other.group.hitori
            captures:
              1: {name: punctuation.definition.group.named.hitori}
            patterns: *regex-back-references
          - include: '#regexp-patterns'
      - comment: Unnamed groups
        begin: (\()
        end: (\s*\))
        name: meta.group.hitori
        captures:
          1: {name: punctuation.definition.group.hitori}
        patterns:
          - include: '#regexp-patterns'

  regexp-character-class:
    patterns:
      - include: '#embedded'
      - begin: (\\)(?=\s*$)
        end: ^\s*(?=\S)
        captures:
          1: {name: constant.character.escape.newline.hitori}
      - include: '#named-escapes'
      - include: '#numeric-escapes'
      - begin: (?i)\\p{
        end: \s*}
        name: constant.other.character-class.unicode.hitori
        patterns:
          - include: '#attribute-selectors'
      - match: (?i)\\([cm][a-z])
        name: constant.character.control.hitori
      - match: (?i)\\p[a-z]{1,2}
        name: constant.other.character-class.unicode.hitori
      - match: (?i)\\[ci]({\w+})?
        name: constant.other.character-class.xml.hitori
      - match: (?i)\\n{(?:[^\\{}]|\\.)+}
        name: constant.character.escape.unicode.name.hitori
      - match: \\[abefprntv]
        name: constant.character.escape.hitori
      - match: \\[a-z]
        name: constant.other.character-class.hitori
      - match: \\[A-Z]
        name: constant.other.character-class.negated.hitori
      - match: \\\p{S}
        name: constant.character.escape.symbol.hitori
      - match: \\\p{P}
        name: constant.character.escape.punctuation.hitori
      - match: \\[a-zA-Z\p{C}]
        name: invalid.illegal.escape.hitori
      - match: \\\s
        name: constant.character.escape.space.hitori
      - match: \\\p{L}
        name: constant.character.escape.letter.hitori
      - match: \\\p{N}
        name: constant.character.escape.number.hitori
      - match: \\.
        name: constant.character.escape.other.hitori

  regexp-character-operators:
    patterns:
      - match: |
          (?x)
          ( # from
              \\(?:d?\d+|d{[\d\s,;]+}) # decimal escape
            | \\[xu](?:\h+|{[\h\s,;]+}) # hex escape
            | \\z(?:[\d\u218a\u218babetx]+|{[\d\u218a\u218babetx\s,;]+}) # duodecimal escape
            | \\o(?:[0-7]+|{[0-7\s,;]+}) # octal escape
            | \\b(?:[01]+|{[01\s,;]+}) # binary escape
            | \\[cm][a-z] # meta-character
            | \\n{(?:[^\\{}]|\\.)+} # Unicode named character
            | \\(?:[abefprntv]|[^a-zA-Z]) # any escape character
            | [^-\\\[\]] # any unescaped character
          )
            \s*
              (-|->|>-|>>) # range
            \s*
          ( # to
              \\(?:d?\d+|d{[\d\s,;]+}) # decimal escape
            | \\[xu](?:\h+|{[\h\s,;]+}) # hex escape
            | \\z(?:[\d\u218a\u218babetx]+|{[\d\u218a\u218babetx\s,;]+}) # duodecimal escape
            | \\o(?:[0-7]+|{[0-7\s,;]+}) # octal escape
            | \\b(?:[01]+|{[01\s,;]+}) # binary escape
            | \\[cm][a-z] # meta-character
            | \\n{(?:[^\\{}]|\\.)+} # Unicode named character
            | \\(?:[abefprntv]|[^a-zA-Z]) # any escape character
            | [^-\\\[\]] # any unescaped character
          ) (?:
              \s*
                (:) # range
              \s*
            ( # to
                \d+ # number
              | \\(?:d?\d+|d{[\d\s,;]+}) # decimal escape
              | \\[xu](?:\h+|{[\h\s,;]+}) # hex escape
              | \\z(?:[\d\u218a\u218babetx]+|{[\d\u218a\u218babetx\s,;]+}) # duodecimal escape
              | \\o(?:[0-7]+|{[0-7\s,;]+}) # octal escape
              | \\b(?:[01]+|{[01\s,;]+}) # binary escape
              | \\[cm][a-z] # meta-character
              | \\n{(?:[^\\{}]|\\.)+} # Unicode named character
              | \\(?:[abefprntv]|[^a-zA-Z]) # any escape character
              | [^-\\\[\]] # any unescaped character
            )
          )?
        captures:
          1:
            name: constant.other.character-class.range.from.hitori
            patterns:
              - include: '#regexp-character-operators'
              - include: '#regexp-character-class'
          2:
            name: keyword.operator.range.hitori
          3:
            name: constant.other.character-class.range.to.hitori
            patterns:
              - include: '#regexp-character-operators'
              - include: '#regexp-character-class'
          4:
            name: keyword.operator.range.hitori
          5:
            name: constant.other.character-class.range.by.hitori
            patterns:
              - include: '#numbers'
              - include: '#regexp-character-operators'
              - include: '#regexp-character-class'
      - match: \|\|
        name: keyword.operator.union.hitori
      - match: \&&
        name: keyword.operator.intersection.hitori
      - match: \^\^
        name: keyword.operator.symmetric.hitori
      - match: ~~
        name: keyword.operator.negation.hitori
      - match: --
        name: keyword.operator.difference.hitori

  regexp-character-set:
    patterns:
      - begin: (\[:)
        end: \s*(:\])
        name: constant.other.character-set.posix.hitori
        captures:
          1: {name: punctuation.definition.character-class.posix.hitori}
        patterns:
          - include: '#attribute-selectors'
      - begin: (\[\^)
        end: \s*(\])
        name: constant.other.character-set.negated.hitori
        captures:
          1:
            name: punctuation.definition.character-class.negated.hitori
        patterns:
          - include: '#comments'
          - include: '#regexp-character-operators'
          - include: '#regexp-character-class'
          - include: '#regexp-character-set'
      - begin: (\[)
        end: \s*(\])
        name: constant.other.character-set.hitori
        captures:
          1: {name: punctuation.definition.character-class.hitori}
        patterns:
          - include: '#comments'
          - include: '#regexp-character-operators'
          - include: '#regexp-character-class'
          - include: '#regexp-character-set'

  attribute-selectors:
    name: meta.attribute-selector.hitori
    patterns:
      - match: '[:!=</>.^$%?*+|&~]?='
        name: keyword.operator.pattern.hitori
      - match: \&\&|\|\||\^\^|\!
        name: keyword.operator.logical.hitori
      - match: ','
        name: punctuation.separator.sequence.hitori
      - match: \b(is\s+not|is)\b
        name: keyword.operator.expression.is.hitori
      - match: \b(not\s+)?([io]n|of)\b
        name: keyword.operator.expression.$2.hitori
      - begin: \b([\p{Pc}\p{L}]\w*)\b([:!=</>.^$%?*+|&~]?=)
        beginCaptures:
          1: {name: entity.other.attribute-name.key.hitori}
          2: {name: keyword.operator.pattern.hitori}
        end: (?=\&\&|\|\||\^\^|[\s,:;'"`)}\]]|\\.)
        name: string.unquoted.attribute-name.hitori
        patterns:
          - include: '#regexp-patterns'
      - match: (?xi)\b[is]\b\s*(?=[)}\]]|([&|^])\1)
        name: storage.modifier.ignore-when.hitori
      - include: '#string-escapes'
      - comment: Attribute names
        match: \b([\p{Pc}\p{L}]\w*)\b
        captures:
          1: {name: entity.other.attribute-name.hitori}
          2: {name: keyword.operator.pattern.hitori}
      - include: '#comments'
      - include: '#operators'

  # XML (JSX) and Markdown

  xml:
    applyEndPatternLast: true
    comment: Only captured when next to opening brackets, commas, semicolons, keywords, and operators. XML also supports functional components, so we need to be careful to also match those.
    begin: |
      (?x)
      (?<=
        (?:
            # beginning of line
            ^
          | # separator
            [,;]
          | # opening bracket
            [({\[]
          | # postfix or infix operator
            [\p{S}\p{P}&&[^,;'"`({\[)}\]\p{Pc}]]+ \s
        ) \s*
        | # a keyword
        (?:
          (?:^|[,;'"({\[)}\]\s]) # beside a delimiter or space
          \b
            (?: # keywords
              [io]n|of|as|is|new|del
              |unset|ref|and|x?or|not
              |var|val|let|const|given|using
              |func|proc|method|type|class|actor
              |impl|enum|module|struct|field
              |union|iter|macro|query|elem
              |object|realm|trait|style|script
              |go|defer|do|with|from|where
              |if|else|then|guard|when
              |for|loop|while|goto|move
              |try|throw|catch|finally|switch
              |match|case|pass|def
              |break|skip|redo|retry
              |return|yield|await|scope
              |import|export|intern|extern
              |debug|assert|check
            )
          \b
        ) \s*
      ) \s*
      (?=<[>\p{Pc}\p{L}])
    end: (?=)|$
    patterns:
      - include: '#tag-component-name'

  tag-component-name:
    patterns:
      - comment: XML Fragment
        contentName: text.html.fragment.hitori
        begin: (<)(?=>)
        end: (?<=</)(>)
        beginCaptures:
          1: {name: punctuation.definition.tag.hitori}
        endCaptures:
          1: {name: punctuation.definition.tag.hitori}
        patterns:
          - include: '#tag-termination'
      - comment: Tags that end > are trapped in tag-termination
        contentName: text.html.hitori
        begin: |
          (?x)
          (<) # start tag begin
          (
            (?:
              \b
              [\p{Pc}\p{L}]\w* # identifier
              \b
              (?:[?!:]:|[?!]?\.) # qualified name separator
            )*
            [\p{Pc}\p{L}]\w* # last part of identifier
            \b
          )
          (?=[,;'"`({\[)}\]/>\s])
        end: |
          (?x) \s*
          (?:
              (?<=</)(\2)(>)
            | (<?/>)
            | ((?<=</).*?)>
          )
        beginCaptures:
          1: {name: punctuation.definition.tag.hitori}
          2: {patterns: [include: '#tag-names']}
        endCaptures:
          1: {patterns: [include: '#tag-names']}
          2: {name: punctuation.definition.tag.hitori}
          3: {name: punctuation.definition.tag.hitori}
          4: {name: invalid.illegal.termination.hitori}
        patterns:
          - include: '#tag-attributes'
          - include: '#tag-termination'

  xml-comments:
    begin: (<!--)
    end: (-->)
    captures:
      1: {name: punctuation.definition.comment.hitori}
    name: comment.block.html.hitori
    patterns:
      - include: '#xml-comments'

  tag-termination:
    comment: uses non consuming search for </ in </tag>
    contentName: meta.xml.children.hitori
    begin: (>)
    end: (</)
    captures:
      0: {name: punctuation.definition.tag.hitori}
    patterns:
      - include: '#evaluated-code'
      - include: '#xml-entities'
      - include: '#tag-component-name'
      - include: '#markdown'
      - include: '#xml-comments'

  tag-attributes:
    patterns:
      - match: \s*([@#&*|%.:~^?]|::)(?=[\w$'"`])
        name: punctuation.definition.entity.hitori
      - include: '#attribute-directive'
      - include: '#attribute-assignment'
      - include: '#attribute-names'
      - include: '#literals'
      - include: '#hex-colors'
      - include: '#embedded-expression'
      - include: '#embedded-format'
      - include: '#embedded-placeholder'
      - include: '#function-calls'
      - include: '#variables'
      - include: '#brackets'
      - include: '#comments'
      - include: '#punctuation'
      - include: '#space'

  attribute-directive:
    patterns:
      - match: \s*([@#&*%|:?])([\p{Pc}\p{L}][\p{Pd}\w]*)\b\s*
        name: meta.attribute.directive.hitori
        captures:
          1: {name: punctuation.definition.directive.hitori}
          2: {name: entity.other.attribute-name.directive.hitori}

  attribute-assignment:
    applyEndPatternLast: true
    begin: \s*([\p{Pc}\p{L}][\p{Pd}\w]*)\s*(=)
    beginCaptures:
      1: &attribute-name
        name: entity.other.attribute-name.hitori
        patterns:
          - match: \s*(?<=\@)[\p{Pc}\p{L}]\w*\b\s*
            name: keyword.control.at-rule.hitori
          - match: \s*(?<=\#)[\p{Pc}\p{L}]\w*\b\s*
            name: entity.other.attribute-name.id.hitori
          - match: \s*(?<=\.)[\p{Pc}\p{L}]\w*\b\s*
            name: entity.other.attribute-name.class.hitori
          - match: \s*(?<=::)[\p{Pc}\p{L}]\w*\b\s*
            name: entity.other.attribute-name.pseudo-component.hitori
          - match: \s*(?<=\~)[\p{Pc}\p{L}]\w*\b\s*
            name: entity.other.attribute-name.key.hitori
          - match: \s*(?<=\&)[\p{Pc}\p{L}]\w*\b\s*
            name: entity.other.attribute-name.hitori entity.name.type.anchor.hitori
          - match: \s*(?<=\*)[\p{Pc}\p{L}]\w*\b\s*
            name: entity.other.attribute-name.hitori entity.name.type.alias.hitori
          - match: \s*(?<=\%)[\p{Pc}\p{L}]\w*\b\s*
            name: entity.other.attribute-name.hitori entity.name.function.hitori
          - match: \s*(?<=\|)[\p{Pc}\p{L}]\w*\b\s*
            name: entity.other.attribute-name.hitori entity.name.method.hitori
          - match: \s*(?<=\:)[\p{Pc}\p{L}]\w*\b\s*
            name: entity.other.attribute-name.hitori entity.name.procedure.hitori
          - match: \s*(?<=\^)[\p{Pc}\p{L}]\w*\b\s*
            name: entity.other.attribute-name.hitori entity.name.property.hitori
          - match: \s*(?<=\?)[\p{Pc}\p{L}]\w*\b\s*
            name: entity.other.attribute-name.hitori entity.name.predicate.hitori
          - include: '#css-property-names'
      2: {name: punctuation.separator.key-value.hitori}
    end: (?=)|$
    name: meta.attribute.assignment.hitori
    patterns:
      - include: '#attribute-values'

  attribute-values:
    patterns:
      - include: '#literals'
      - include: '#embedded-expression'
      - include: '#brackets'

  attribute-names:
    match: \s*([\p{Pc}\p{L}][\p{Pd}\w]*)\b(?!\s*=)\s*
    name: meta.attribute.boolean.hitori
    captures:
      1: *attribute-name

  spread-attribute:
    comment: Spread *attribute
    match: (?<!\*)\*(?!\*)
    name: keyword.operator.spread.hitori

  xml-entities:
    patterns:
      - match: |
          (?xi)
          (&)(?:
              ([a-zA-Z][a-zA-Z0-9]+)
            | (\#\d+)
            | (\#x\h+)
            | (\#b[01]+)
            | (\#q[0-3]+)
            | (\#s[0-5]+)
            | (\#z[\d\u218a\u218babetx]+)
            | (\#o[0-7]+)
            | ((?:\\.|[^({\[)}\]\s;])+?)
          )(;)
        name: constant.other.entity.hitori
        captures: &xml-entities
          1: {name: punctuation.definition.entity.hitori}
          2: {name: constant.character.entity.named.hitori}
          3: {name: constant.character.escape.decimal.hitori}
          4: {name: constant.character.escape.hexadecimal.hitori}
          5: {name: constant.character.escape.binary.hitori}
          6: {name: constant.character.escape.quaternary.hitori}
          7: {name: constant.character.escape.senary.hitori}
          8: {name: constant.character.escape.duodecimal.hitori}
          9: {name: constant.character.escape.octal.hitori}
          10: {name: constant.character.entity.hitori}
          11: {name: punctuation.definition.entity.hitori}
      - match: '&(?=\w*;)'
        name: invalid.illegal.ambiguous-ampersand.hitori
      - comment: Entity with & and invalid name
        match: '&\s*+;'
        name: invalid.illegal.bad-ampersand.hitori

  inline-markdown:
    patterns:
      - include: '#ampersand'
      - include: '#bracket'
      - include: '#bold'
      - include: '#italic'
      - include: '#underline'
      - include: '#strikethrough'
      - include: '#superscript'
      - include: '#subscript'
      - include: '#spoiler'
      - include: '#highlight'
      - include: '#string-content'
      - include: '#raw'
      - include: '#escape'
      - include: '#image-inline'
      - include: '#image-ref'
      - include: '#link-email'
      - include: '#link-inet'
      - include: '#link-inline'
      - include: '#link-ref'
      - include: '#link-ref-literal'
      - include: '#link-ref-shortcut'

  ampersand:
    comment: Markdown will convert this for us. We match it so that the HTML grammar will not mark it up as invalid.
    match: '&(?!([a-zA-Z\d]+|#[\d]+|#x\h+);)'
    name: meta.other.valid-ampersand.markdown

  bold:
    begin: |
      (?x)
      (?<open>(\*\*(?=\w)|(?<!\w)\*\*|(?<!\w)\b__))(?=\S)
      (?=
        (
          <[^>]*+> # HTML tags
          | (?<raw>`+)([^`]|(?!(?<!`)\k<raw>(?!`))`)*+\k<raw>
          # Raw
          | \\[\\`*_{}\[\]() #.!+\->]?+ # Escapes
          | \[
          (
              (?<square> # Named group
                [^\[\]\\] # Match most chars
                | \\. # Escaped chars
                | \[ \g<square>*+ \] # Nested brackets
              )*+
            \]
            (
              ( # Reference Link
                [ ]? # Optional space
                \[[^\]]*+\] # Ref name
              )
              | ( # Inline Link
                \( # Opening paren
                  [ \t]*+ # Optional whitespace
                  <?(.*?)>? # URL
                  [ \t]*+ # Optional whitespace
                  ( # Optional Title
                    (?<title>['"])
                    (.*?)
                    \k<title>
                  )?
                \)
              )
            )
          )
          | (?!(?<=\S)\k<open>). # Everything besides
          # style closer
        )++
        (?<=\S)(?=__\b|\*\*)\k<open> # Close
      )
    captures:
      1: {name: punctuation.definition.bold.markdown}
    end: (?<=\S)(\1)
    name: markup.bold.markdown
    patterns:
      - include: '#ampersand'
      - include: '#bracket'
      - include: '#italic'
      - include: '#underline'
      - include: '#strikethrough'
      - include: '#superscript'
      - include: '#subscript'
      - include: '#spoiler'
      - include: '#highlight'
      - include: '#string-content'
      - include: '#raw'
      - include: '#escape'
      - include: '#image-inline'
      - include: '#image-ref'
      - include: '#link-email'
      - include: '#link-inet'
      - include: '#link-inline'
      - include: '#link-ref'
      - include: '#link-ref-literal'
      - include: '#link-ref-shortcut'

  italic:
    begin: |
      (?x) (?<open>(\*(?=\w)|(?<!\w)\*|(?<!\w)\b_))(?=\S) # Open
      (?=
        (
          <[^>]*+> # HTML tags
          | (?<raw>`+)([^`]|(?!(?<!`)\k<raw>(?!`))`)*+\k<raw>
          # Raw
          | \\[\\`*_{}\[\]() #.!+\->]?+ # Escapes
          | \[
          (
              (?<square> # Named group
                [^\[\]\\] # Match most chars
                | \\. # Escaped chars
                | \[ \g<square>*+ \] # Nested brackets
              )*+
            \]
            (
              ( # Reference Link
                [ ]? # Optional space
                \[[^\]]*+\] # Ref name
              )
              | ( # Inline Link
                \( # Opening paren
                  [ \t]*+ # Optional whitespace
                  <?(.*?)>? # URL
                  [ \t]*+ # Optional whitespace
                  ( # Optional Title
                    (?<title>['"])
                    (.*?)
                    \k<title>
                  )?
                \)
              )
            )
          )
          | \k<open>\k<open> # Must be bold closer
          | (?!(?<=\S)\k<open>). # Everything besides
          # style closer
        )++
        (?<=\S)(?=_\b|\*)\k<open> # Close
      )
    captures:
      1: {name: punctuation.definition.italic.markdown}
    end: (?<=\S)(\1)((?!\1)|(?=\1\1))
    name: markup.italic.markdown
    patterns:
      - include: '#ampersand'
      - include: '#bracket'
      - include: '#bold'
      - include: '#underline'
      - include: '#strikethrough'
      - include: '#superscript'
      - include: '#subscript'
      - include: '#spoiler'
      - include: '#highlight'
      - include: '#string-content'
      - include: '#raw'
      - include: '#escape'
      - include: '#image-inline'
      - include: '#image-ref'
      - include: '#link-email'
      - include: '#link-inet'
      - include: '#link-inline'
      - include: '#link-ref'
      - include: '#link-ref-literal'
      - include: '#link-ref-shortcut'

  strikethrough:
    begin: (~~)(?=\S)
    captures:
      1: {name: punctuation.definition.strikethrough.markdown}
    end: (?<=\S)(~~)
    name: markup.strikethrough.markdown
    patterns:
      - include: '#ampersand'
      - include: '#bracket'
      - include: '#bold'
      - include: '#italic'
      - include: '#underline'
      - include: '#superscript'
      - include: '#subscript'
      - include: '#spoiler'
      - include: '#highlight'
      - include: '#string-content'
      - include: '#raw'
      - include: '#escape'
      - include: '#image-inline'
      - include: '#image-ref'
      - include: '#link-email'
      - include: '#link-inet'
      - include: '#link-inline'
      - include: '#link-ref'
      - include: '#link-ref-literal'
      - include: '#link-ref-shortcut'

  underline:
    begin: (\+\+)(?=\S)
    captures:
      1: {name: punctuation.definition.underline.markdown}
    end: (?<=\S)(\+\+)
    name: markup.underline.markdown
    patterns:
      - include: '#ampersand'
      - include: '#bracket'
      - include: '#bold'
      - include: '#italic'
      - include: '#strikethrough'
      - include: '#superscript'
      - include: '#subscript'
      - include: '#spoiler'
      - include: '#highlight'
      - include: '#string-content'
      - include: '#raw'
      - include: '#escape'
      - include: '#image-inline'
      - include: '#image-ref'
      - include: '#link-email'
      - include: '#link-inet'
      - include: '#link-inline'
      - include: '#link-ref'
      - include: '#link-ref-literal'
      - include: '#link-ref-shortcut'

  spoiler:
    begin: (\|\|)(?=\S)
    captures:
      1: {name: punctuation.definition.spoiler.markdown}
    end: (?<=\S)(\|\|)
    name: markup.spoiler.markdown
    patterns:
      - include: '#ampersand'
      - include: '#bracket'
      - include: '#bold'
      - include: '#italic'
      - include: '#underline'
      - include: '#strikethrough'
      - include: '#superscript'
      - include: '#subscript'
      - include: '#highlight'
      - include: '#string-content'
      - include: '#raw'
      - include: '#escape'
      - include: '#image-inline'
      - include: '#image-ref'
      - include: '#link-email'
      - include: '#link-inet'
      - include: '#link-inline'
      - include: '#link-ref'
      - include: '#link-ref-literal'
      - include: '#link-ref-shortcut'

  highlight:
    begin: (==)(?=\S)
    captures:
      1: {name: punctuation.definition.highlight.markdown}
    end: (?<=\S)(==)
    name: markup.highlight.markdown
    patterns:
      - include: '#ampersand'
      - include: '#bracket'
      - include: '#bold'
      - include: '#italic'
      - include: '#underline'
      - include: '#strikethrough'
      - include: '#superscript'
      - include: '#subscript'
      - include: '#spoiler'
      - include: '#string-content'
      - include: '#raw'
      - include: '#escape'
      - include: '#image-inline'
      - include: '#image-ref'
      - include: '#link-email'
      - include: '#link-inet'
      - include: '#link-inline'
      - include: '#link-ref'
      - include: '#link-ref-literal'
      - include: '#link-ref-shortcut'

  superscript:
    begin: (\^)(?=\S)
    captures:
      1: {name: punctuation.definition.superscript.markdown}
    end: (?<=\S)(\^)
    name: markup.superscript.markdown
    patterns:
      - include: '#ampersand'
      - include: '#bracket'
      - include: '#bold'
      - include: '#italic'
      - include: '#underline'
      - include: '#strikethrough'
      - include: '#subscript'
      - include: '#spoiler'
      - include: '#highlight'
      - include: '#string-content'
      - include: '#raw'
      - include: '#escape'
      - include: '#image-inline'
      - include: '#image-ref'
      - include: '#link-email'
      - include: '#link-inet'
      - include: '#link-inline'
      - include: '#link-ref'
      - include: '#link-ref-literal'
      - include: '#link-ref-shortcut'

  subscript:
    begin: (~)(?=\S)
    captures:
      1: {name: punctuation.definition.subscript.markdown}
    end: (?<=\S)(~)
    name: markup.subscript.markdown
    patterns:
      - include: '#ampersand'
      - include: '#bracket'
      - include: '#bold'
      - include: '#italic'
      - include: '#underline'
      - include: '#strikethrough'
      - include: '#superscript'
      - include: '#spoiler'
      - include: '#highlight'
      - include: '#string-content'
      - include: '#raw'
      - include: '#escape'
      - include: '#image-inline'
      - include: '#image-ref'
      - include: '#link-email'
      - include: '#link-inet'
      - include: '#link-inline'
      - include: '#link-ref'
      - include: '#link-ref-literal'
      - include: '#link-ref-shortcut'

  bracket:
    comment: Markdown will convert this for us. We match it so that the HTML grammar will not mark it up as invalid.
    match: <(?![a-zA-Z/?\$!])
    name: meta.other.valid-bracket.markdown

  escape:
    match: \\[-`*_#+.!({\[)}\]\\>~|=]
    name: constant.character.escape.markdown

  image-inline:
    captures:
      1: {name: punctuation.definition.string.begin.markdown}
      2: {name: string.other.link.description.markdown}
      4: {name: punctuation.definition.string.end.markdown}
      5: {name: punctuation.definition.metadata.markdown}
      6: {name: punctuation.definition.link.markdown}
      7: {name: markup.underline.link.image.markdown}
      8: {name: punctuation.definition.link.markdown}
      9: {name: string.other.link.description.title.markdown}
      10: {name: punctuation.definition.string.markdown}
      11: {name: punctuation.definition.string.markdown}
      12: {name: string.other.link.description.title.markdown}
      13: {name: punctuation.definition.string.markdown}
      14: {name: punctuation.definition.string.markdown}
      15: {name: string.other.link.description.title.markdown}
      16: {name: punctuation.definition.string.markdown}
      17: {name: punctuation.definition.string.markdown}
      18: {name: punctuation.definition.metadata.markdown}
    match: |
      (?x)
      (\!\[)((?<square>[^\[\]\\]|\\.|\[\g<square>*+\])*+)(\])
      # Match the link text.
      (\() # Opening paren for url
        (<?)(\S+?)(>?) # The url
        [ \t]* # Optional whitespace
        (?:
            ((\().+?(\))) # Match title in parens...
          | ((").+?(")) # or in double quotes...
          | ((').+?(')) # or in single quotes.
        )? # Title is optional
        \s* # Optional whitespace
      (\))
    name: meta.image.inline.markdown

  image-ref:
    captures:
      1: {name: punctuation.definition.string.begin.markdown}
      2: {name: string.other.link.description.markdown}
      4: {name: punctuation.definition.string.begin.markdown}
      5: {name: punctuation.definition.constant.markdown}
      6: {name: constant.other.reference.link.markdown}
      7: {name: punctuation.definition.constant.markdown}
    match: (\!\[)((?<square>[^\[\]\\]|\\.|\[\g<square>*+\])*+)(\])[ ]?(\[)(.*?)(\])
    name: meta.image.reference.markdown
    patterns:
      - include: '#string-content'

  link-email:
    captures:
      1: {name: punctuation.definition.link.markdown}
      2: {name: markup.underline.link.markdown}
      4: {name: punctuation.definition.link.markdown}
    match: (<)((?:mailto:)?[a-zA-Z\d.!#$%&'*+/=?^_`{|}~-]+@[a-zA-Z\d-]+(?:\.[a-zA-Z\d-]+)*)(>)
    name: meta.link.email.lt-gt.markdown
    patterns:
      - include: '#string-content'

  link-inet:
    captures:
      1: {name: punctuation.definition.link.markdown}
      2: {name: markup.underline.link.markdown}
      3: {name: punctuation.definition.link.markdown}
    match: (<)((?:https?|ftp)://.*?)(>)
    name: meta.link.inet.markdown
    patterns:
      - include: '#string-content'

  link-inline:
    captures:
      1: {name: punctuation.definition.string.begin.markdown}
      2: {name: string.other.link.title.markdown}
      4: {name: punctuation.definition.string.end.markdown}
      5: {name: punctuation.definition.metadata.markdown}
      6: {name: punctuation.definition.link.markdown}
      7: {name: markup.underline.link.markdown}
      9: {name: punctuation.definition.link.markdown}
      10: {name: string.other.link.description.title.markdown}
      11: {name: punctuation.definition.string.begin.markdown}
      12: {name: punctuation.definition.string.end.markdown}
      13: {name: string.other.link.description.title.markdown}
      14: {name: punctuation.definition.string.begin.markdown}
      15: {name: punctuation.definition.string.end.markdown}
      16: {name: string.other.link.description.title.markdown}
      17: {name: punctuation.definition.string.begin.markdown}
      18: {name: punctuation.definition.string.end.markdown}
      19: {name: punctuation.definition.metadata.markdown}
    match: |
      (?x)
      (\[)((?<square>[^\[\]\\]|\\.|\[\g<square>*+\])*+)(\])
      # Match the link text.
      (\() # Opening paren for url
        (<?)((?<url>(?>[^\s()]+)|\(\g<url>*\))*)(>?) # The url
        [ \t]* # Optional whitespace
        (?:
            ((\().+?(\))) # Match title in parens...
          | ((").+?(")) # or in double quotes...
          | ((').+?(')) # or in single quotes.
        )? # Title is optional
        \s* # Optional whitespace
      (\))
    name: meta.link.inline.markdown
    patterns:
      - include: '#string-content'

  link-ref:
    captures:
      1: {name: punctuation.definition.string.begin.markdown}
      2: {name: string.other.link.title.markdown}
      4: {name: punctuation.definition.string.end.markdown}
      5: {name: punctuation.definition.constant.begin.markdown}
      6: {name: constant.other.reference.link.markdown}
      7: {name: punctuation.definition.constant.end.markdown}
    match: (\[)((?<square>[^\[\]\\]|\\.|\[\g<square>*+\])*+)(\])(\[)([^\]]*+)(\])
    name: meta.link.reference.markdown
    patterns:
      - include: '#string-content'

  link-ref-literal:
    captures:
      1: {name: punctuation.definition.string.begin.markdown}
      2: {name: string.other.link.title.markdown}
      4: {name: punctuation.definition.string.end.markdown}
      5: {name: punctuation.definition.constant.begin.markdown}
      6: {name: punctuation.definition.constant.end.markdown}
    match: (\[)((?<square>[^\[\]\\]|\\.|\[\g<square>*+\])*+)(\])[ ]?(\[)(\])
    name: meta.link.reference.literal.markdown
    patterns:
      - include: '#string-content'

  link-ref-shortcut:
    captures:
      1: {name: punctuation.definition.string.begin.markdown}
      2: {name: string.other.link.title.markdown}
      3: {name: punctuation.definition.string.end.markdown}
    match: (\[)(\S+?)(\])
    name: meta.link.reference.markdown
    patterns:
      - include: '#string-content'

  raw:
    captures:
      1: {name: punctuation.definition.raw.markdown}
      2: {patterns: [include: '#string-content']}
      3: {name: punctuation.definition.raw.markdown}
    match: (`+)([^`]|(?!(?<!`)\1(?!`))`)*+(\1)
    name: markup.inline.raw.string.markdown
    patterns:
      - include: '#string-content'

  markdown:
    patterns:
      - include: '#comments'
      - include: '#xml-entities'
      - include: '#html-tag'
      - include: '#string-content'
      - include: '#evaluated-code'
      - include: '#executed-code'
      - include: '#inline-styles'
      - include: '#blockquote'
      - include: '#unordered-list'
      - include: '#ordered-list'
      - include: '#inline-markdown'

    repository:
      blockquote:
        comment: '> blockquote'
        begin: ^\s*(\>)(\s+.*)\n*
        end: ^(?=\S)|(?!\G)
        beginCaptures:
          1: {name: punctuation.definition.quote.begin.markdown}
          2:
            name: markup.quote.markdown
            patterns: [include: '#markdown']
        name: markup.quote.markdown
        patterns:
          - begin: ^(\s+)(?!\s)
            end: ^(?!\1|\s*$)
            name: markup.quote.markdown
            patterns: [include: '#markdown']

      unordered-list:
        comment: '- unordered list'
        begin: ^\s*(\-)(?!>)\s+(.*)\n*
        end: ^(?=\S)|(?!\G)
        beginCaptures:
          1: {name: punctuation.definition.list.begin.markdown}
          2:
            name: markup.list.unnumbered.markdown
            patterns: [include: '#markdown']
        name: markup.list.unnumbered.markdown
        patterns:
          - begin: ^(\s+)(?!\s)
            end: ^(?!\1|\s*$)
            name: markup.list.unnumbered.markdown
            patterns: [include: '#markdown']

      ordered-list:
        comment: '+ ordered list'
        begin: ^\s*(\+)(?!>)\s+(.*)\n*
        end: ^(?=\S)|(?!\G)
        beginCaptures:
          1: {name: punctuation.definition.list.begin.markdown}
          2:
            name: markup.list.numbered.markdown
            patterns: [include: '#markdown']
        name: markup.list.numbered.markdown
        patterns:
          - begin: ^(\s+)(?!\s)
            end: ^(?!\1|\s*$)
            name: markup.list.numbered.markdown
            patterns: [include: '#markdown']

      evaluated-code:
        applyEndPatternLast: true
        comment: Evaluated code
        begin: (?<=^|[\w\s'"`])(=>)
        end: (?=|$)
        captures:
          1: {name: storage.type.method.hitori}
        patterns:
          - include: $self

      executed-code:
        applyEndPatternLast: true
        comment: Executed code
        begin: (?<=^|[\w\s'"`])(->)
        end: (?=|$)
        captures:
          1: {name: storage.type.subroutine.hitori}
        patterns:
          - include: $self

      html-tag:
        comment: <Tags
        applyEndPatternLast: true
        begin: (?<=^|[\w\s'"`])(<)\b
        end: (<?>?=?)|(?=)|$
        name: meta.tag.hitori
        captures:
          1: {name: punctuation.definition.tag.hitori}
        patterns:
          - comment: Tag name
            match: (?<=<)\b([\p{Pc}\p{L}]\w*\b(?:(?:[?!:]:|[?!]?\.)[\p{Pc}\p{L}]\w*)*)\b
            captures:
              1:
                name: entity.name.tag.hitori
                patterns: *html-tag-names
          - include: '#style-selectors'
          - begin: (\[)\s*
            end: \s*(\])\s*
            captures:
              1: {name: punctuation.definition.directive.hitori}
            patterns:
              - include: '#attribute-selectors'
              - include: $self
          - begin: (\{)\s*
            end: \s*(\})\s*
            captures:
              1: {name: punctuation.definition.mapping.hitori}
            patterns:
              - include: '#style-properties'
              - include: $self
          - begin: (\()\s*
            end: \s*(\))
            captures:
              1: {name: punctuation.definition.parameters.hitori}
            patterns:
              - include: '#tag-attributes'
              - include: $self
          - include: '#literals'
          - include: '#regexps'
          - include: '#punctuation'
          - include: '#comments'
          - include: '#space'

      inline-styles:
        begin: (?<=^|[\w\s'"`])(\+>)(.*)\n*
        beginCaptures:
          1:
            name: storage.type.style.hitori
          2:
            patterns:
              - match: (?<=^|\s)([?:]?=)(?=\s+|$)
                captures:
                  1: {name: keyword.operator.assignment.hitori}
              - include: '#comments'
              - include: '#style-pair'
              - include: '#style-rules'
              - include: '#declaration-clause'
              - match: *entity-name
                name: entity.name.style.hitori
        end: ^(?=\S)|(?!\G)
        patterns:
          - begin: ^(\s+)(?!\s)
            end: ^(?!\1|\s*$)
            name: meta.style.yaml
            patterns: [include: '#style-properties']

  # Special code blocks

  html-builtins:
    patterns:
      - include: source.css.scss#constant_functions
      - include: source.css.scss#constant_sass_functions
      - include: source.css.scss#constant_important
      - include: source.css.scss#constant_default
      - include: source.css.scss#constant_optional

  property-name:
    match: \b([\p{Pc}\p{L}]\w*\b(?:(?:(?:[?!:]:|[?!]?\.)?[\p{Pc}\p{L}]\w*)*)\b
    name: meta.property-name.hitori
    captures:
      1:
        patterns:
          - include: '#css-value-names'
          - match: ([\p{Pc}\p{L}]\w*)\b(?=[.:])
            name: constant.other.hitori
          - match: ([\p{Pc}\p{L}]\w*)\b
            name: constant.language.hitori
          - match: '[?!:]:|[?!]?\.'
            name: punctuation.separator.namespace.hitori

  style-list:
    begin: \s*(\[)\s*
    end: \s*(\])
    name: meta.brace.square.hitori
    captures:
      1: {name: punctuation.definition.expression.hitori}
    patterns:
      - include: '#punctuation'
      - include: '#style-property-values'
      - include: $self

  style-property-values:
    patterns:
      - include: '#hex-colors'
      - include: '#embedded-expression'
      - include: '#embedded-format'
      - include: '#embedded-placeholder'
      - include: '#css-value-names'
      - include: $self

  hex-colors:
    match: \s*(#)\b(?:\h{3,4}|\h{6}|\h{8})\b\s*
    name: constant.other.color.rgb-value.hex.css
    captures:
      1: {name: punctuation.definition.constant.css}

  tag-names:
    match: \s*\b([\p{Pc}\p{L}]\w*\b(?:(?:[?!:]:|[?!]?\.)?[\p{Pc}\p{L}]\w*)*)\b\s*
    name: entity.name.tag.hitori
    captures:
      1:
        name: entity.name.tag.hitori
        patterns: *html-tag-names

  script-block:
    begin: \s*(\{)\s*
    end: \s*(\})\s*
    name: meta.brace.script.hitori
    captures:
      1: {name: punctuation.definition.block.script.hitori}
    patterns:
      - include: '#interpolated-code'
      - include: source.js
      - include: $self

  style-block:
    begin: \s*(\{)\s*
    end: \s*(\})\s*
    name: meta.brace.style.hitori
    captures:
      1: {name: punctuation.section.property-list.hitori}
    patterns:
      - include: '#style-properties'

  style-pair:
    applyEndPatternLast: true
    begin: \s*([\p{Pd}\w]+)\b(:)\s*
    end: (?=|)$
    name: meta.property.css.hitori
    beginCaptures:
      1:
        name: support.type.property-name.hitori
        patterns: [include: '#css-property-names']
      2:
        name: punctuation.separator.key-value.hitori
    patterns:
      - include: '#style-property-values'
      - match: \s+
        name: meta.var.expr.hitori

  style-properties:
    patterns:
      - include: '#comments'
      - include: '#embedded'
      - include: '#clauses'
      - include: '#declarations'
      - include: '#keywords'
      - include: '#style-pair'
      - include: '#style-rules'
      - include: '#style-block'
      - include: $self

  style-rules:
    patterns:
      - comment: CSS operators
        match: \s*(?:(\+)|(\-)|(\*)|(/)|(\%)|(\!)|(\?)|(\&)|(\|)|(\^)|(\~)|(\$)|(\#)|([<>]))\s*
        captures:
          1: {name: keyword.operator.sum.hitori}
          2: {name: keyword.operator.difference.hitori}
          3: {name: keyword.operator.product.hitori}
          4: {name: keyword.operator.quotient.hitori}
          5: {name: keyword.operator.remainder.hitori}
          6: {name: keyword.operator.only.hitori}
          7: {name: keyword.operator.maybe.hitori}
          8: {name: keyword.operator.intersection.hitori}
          9: {name: keyword.operator.union.hitori}
          10: {name: keyword.operator.symmetric.hitori}
          11: {name: keyword.operator.negation.hitori}
          12: {name: keyword.operator.macro.dollar.hitori}
          13: {name: keyword.operator.private.hitori}
          14: {name: keyword.operator.class.hitori}
      - begin: \s*(\()\s*
        end: \s*(\))
        captures:
          1: {name: punctuation.definition.parameters.hitori}
        patterns:
          - match: \s*(?<!(?:(?<!\.)\.|[?!:]:)=?)\b(as)\b\s*
            name: keyword.operator.expression.as.hitori
          - include: '#clauses'
          - include: '#constants'
          - include: '#declarations'
          - include: '#expression-keywords'
          - include: '#style-pair'
          - include: '#parameter-variables'
          - include: $self
      - begin: \s*(\[)\s*
        end: \s*(\])\s*
        captures:
          1: {name: punctuation.definition.selector.hitori}
        patterns:
          - include: '#attribute-selectors'
          - include: $self
      - match: \s*(?<!(?:(?<!\.)\.|[?!:]:)=?)\b(from|to|except|only|as)\b\s*
        name: keyword.operator.expression.hitori
      - include: '#style-selectors'
      - include: '#format-syntax'
      - include: '#tag-names'

  style-selectors:
    patterns:
      - match: \s*([@#&*|%.:~^?]|::)(?=[\w$'"`])
        name: punctuation.definition.entity.hitori
      - match: \s*(?<=\@)[\p{Pc}\p{L}]\w*\b\s*
        name: keyword.control.at-rule.hitori
      - match: \s*(?<=\#)[\p{Pc}\p{L}]\w*\b\s*
        name: entity.other.attribute-name.id.hitori
      - match: \s*(?<=\.)[\p{Pc}\p{L}]\w*\b\s*
        name: entity.other.attribute-name.class.hitori
      - match: \s*(?<=::)[\p{Pc}\p{L}]\w*\b\s*
        name: entity.other.attribute-name.pseudo-component.hitori
      - match: \s*(?<=\~)[\p{Pc}\p{L}]\w*\b\s*
        name: entity.other.attribute-name.key.hitori
      - match: \s*(?<=\&)[\p{Pc}\p{L}]\w*\b\s*
        name: entity.other.attribute-name.hitori entity.name.type.anchor.hitori
      - match: \s*(?<=\*)[\p{Pc}\p{L}]\w*\b\s*
        name: entity.other.attribute-name.hitori entity.name.type.alias.hitori
      - match: \s*(?<=\%)[\p{Pc}\p{L}]\w*\b\s*
        name: entity.other.attribute-name.hitori entity.name.function.hitori
      - match: \s*(?<=\|)[\p{Pc}\p{L}]\w*\b\s*
        name: entity.other.attribute-name.hitori entity.name.method.hitori
      - match: \s*(?<=\:)[\p{Pc}\p{L}]\w*\b\s*
        name: entity.other.attribute-name.hitori entity.name.procedure.hitori
      - match: \s*(?<=\^)[\p{Pc}\p{L}]\w*\b\s*
        name: entity.other.attribute-name.hitori entity.name.property.hitori
      - match: \s*(?<=\?)[\p{Pc}\p{L}]\w*\b\s*
        name: entity.other.attribute-name.hitori entity.name.predicate.hitori

  # Comments

  comments:
    patterns:
      - include: '#block-comments'
      - include: '#line-comments'
      - include: '#nested-comments'

  block-comments:
    patterns:
      - begin: \s*(/\*\*)(?![\p{S}\p{P}&&[^,;'"`({\[)}\]\p{Pc}]]+)
        end: \s*(\*/)
        name: comment.block.documentation.hitori
        captures:
          1: {name: punctuation.definition.comment.hitori}
        patterns:
          - include: '#jsdoc'
          - include: text.html.markdown#inline
          - include: '#nested-jsdoc'
      - begin: \s*(/\*)(?![\p{S}\p{P}&&[^,;'"`({\[)}\]\p{Pc}]]+)
        end: \s*(\*/)
        name: comment.block.hitori
        captures:
          1: {name: punctuation.definition.comment.hitori}
        patterns:
          - include: text.html.markdown#inline
          - include: '#nested-block'

  line-comments:
    patterns:
      - begin: \s*(///)(?![\p{S}\p{P}&&[^,;'"`({\[)}\]\p{Pc}]]+)
        end: \s*$
        name: comment.line.documentation.hitori
        captures:
          1: {name: punctuation.definition.comment.hitori}
        patterns:
          - include: '#jsdoc'
          - include: text.html.markdown#inline
      - begin: \s*(//)(?![\p{S}\p{P}&&[^,;'"`({\[)}\]\p{Pc}]]+)
        end: \s*$
        name: comment.line.number-sign.hitori
        captures:
          1: {name: punctuation.definition.comment.hitori}
        patterns:
          - include: text.html.markdown#inline

  nested-jsdoc:
    begin: (/\*\*?)(?![\p{S}\p{P}&&[^,;'"`({\[)}\]\p{Pc}]]+)
    end: \s*(\*/)
    name: comment.block.documentation.nested.hitori
    captures:
      1: {name: punctuation.definition.comment.hitori}
    patterns:
      - include: '#jsdoc'
      - include: text.html.markdown#inline
      - include: '#nested-jsdoc'

  nested-block:
    begin: (/\*)(?![\p{S}\p{P}&&[^,;'"`({\[)}\]\p{Pc}]]+)
    end: \s*(\*/)
    name: comment.block.nested.hitori
    captures:
      1: {name: punctuation.definition.comment.hitori}
    patterns:
      - include: text.html.markdown#inline
      - include: '#nested-block'

  # JSDoc

  jsdoc:
    patterns:
      - include: '#jsdoc-inline-tags'
      - include: '#jsdoc-access'
      - include: '#jsdoc-as-name-path'
      - include: '#jsdoc-simple'
      - include: '#jsdoc-simple-name-path'
      - include: '#jsdoc-module'
      - include: '#jsdoc-type-name'
      - include: '#jsdoc-type-no-name'
      - comment: additional jsdoc V2 keywords
        match: (?<!\w)@(add|api|body|codeend|codestart|demo|download|group|hide|iframe|image|inherits|option|outline|page|parent|signature|tag)\b
        name: storage.type.class.jsdoc
      - comment: additional jsdoc keywords
        match: (?<!\w)@(accessor|alternateClassName|aside|cfg|chainable|docauthor|evented|experimental|ftype|hide|inheritable|localdoc|markdown|mixins|new|override|preventable|ptype|removed|scss mixin|object|template|uses|xtype)\b
        name: storage.type.class.jsdoc

  jsdoc-access:
    comment: '@tag protected....'
    match: (@(access))\s*(private|protected|public)?(?=\s|$)
    captures:
      1: {name: storage.type.class.jsdoc}
      3: {name: storage.modifier.jsdoc}

  jsdoc-module:
    comment: '@tag {optional type} module:file'
    begin: (@(exports|module|listens|requires)\b)\s*(?=({(?:(?>(?:[^\\{}]|\\.)+)|\g<-1>)*\})?\s*(\S*)([\S\s]*))
    end: ^|(?=\*/)|(?=\5$)
    beginCaptures:
      1: {name: storage.type.class.jsdoc}
    patterns:
      - include: '#jsdoc-typedef-scopes'
      - match: (?:(module)(:))?(((?!\*/)\S)+)
        captures:
          1: {name: keyword.module.jsdoc}
          2: {name: punctuation.jsdoc}
          3: {name: string.modulename.jsdoc}

  jsdoc-as-name-path:
    comment: to terminate the block
    begin: (@(borrows|lends)\b)\s*(?=(?!\*/)\S+(?:(?:\s*\bas\b\s*(?!\*/)\S+)?)?([\S\s]*))
    end: ^|(?=\*/)|(?=\3$)
    beginCaptures:
      1: {name: storage.type.class.jsdoc}
    patterns:
      - include: '#jsdoc-name-path-scopes'

  jsdoc-simple:
    comment: '@tag'
    match: (@(abs|author|classdesc|copyright|default|defaultvalue|deprecated|description|desc|example|external|fileoverview|file|global|host|ignore|inheritdoc|inner|instance|license|override|overview|readonly|see|since|stat|summary|todo|tutorial|virtual|variation|version)\b)(?=$|\s)
    captures:
      1: {name: storage.type.class.jsdoc}

  jsdoc-simple-name-path:
    comment: '@tag {opt type} Class#xxx or Class#Event:aaaa etc'
    begin: (@(alias|augments|callback|extends|emits|event|fires|impl|memberof|mixes|name|property|property|this|typedef)\b)\s*(?=({(?:(?>(?:[^\\{}]|\\.)+)|\g<-1>)*\})?\s*\S*([\S*\s]*))
    end: ^|(?=\*/)|(?=\4$)
    beginCaptures:
      1: {name: storage.type.class.jsdoc}
    patterns:
      - include: '#jsdoc-typedef-scopes'
      - include: '#jsdoc-name-path-scopes'

  jsdoc-type-name:
    comment: '@tag {optional type} name'
    begin: (@(arg|argument|class|constant|constructor|constructs|const|function|fn|kind|member|method|mixin|actor|param|var)\b)\s*(?=({(?:(?>(?:[^\\{}]|\\.)+)|\g<-1>)*\})?\s*(((\[(?:(?>[^\[\]]+)|\g<-1>)*\])|\S)+)?([\S\s]*))
    end: ^|(?=\*/)|(?=\7$)
    beginCaptures:
      1: {name: storage.type.class.jsdoc}
    patterns:
      - include: '#jsdoc-typedef-scopes'
      - include: '#jsdoc-name-scopes'

  jsdoc-type-no-name:
    comment: '@tag {types}'
    begin: (@(enum|exception|implements|private|protected|public|returns|return|throws|type)\b)\s*(?=({(?:(?>(?:[^\\{}]|\\.)+)|\g<-1>)*\})?\s*([\S\s]*))
    end: ^|(?=\*/)|(?=\4$)
    beginCaptures:
      1: {name: storage.type.class.jsdoc}
    patterns:
      - include: '#jsdoc-typedef-scopes'

  jsdoc-inline-tags:
    name: meta.tag.inline.jsdoc
    begin: (\[(?:(?>[^\[\]]+)|\g<-1>)*\])?({)(?=@)
    end: \s*(})
    beginCaptures:
      1: {name: string.linktext.jsdoc}
      2: {name: meta.brace.curly.jsdoc}
    endCaptures:
      1: {name: meta.brace.curly.jsdoc}
    patterns:
      - match: (@(link|tutorial))\b([^}]*)
        captures:
          1: {name: storage.type.class.jsdoc}
          3: {name: string.jsdoc}

  jsdoc-typedef-scopes:
    name: entity.name.type.instance.jsdoc
    begin: '{'
    end: '}|^'
    captures:
      0: {name: meta.brace.curly.jsdoc}
    patterns:
      - include: '#jsdoc-typedef-primitives'
      - include: '#jsdoc-name-path-scopes'
      - include: '#jsdoc-typedef-obj'

  jsdoc-typedef-primitives:
    match: \b(null|undefined|boolean|string|number)\b
    captures:
      1: {name: support.type.builtin.primitive.jsdoc}

  jsdoc-typedef-obj:
    comment: typedef object
    begin: '{'
    end: '}|^'
    captures:
      0: {name: meta.brace.curly.jsdoc}
    patterns:
      - include: '#jsdoc-typedef-primitives'
      - match: \b([\p{Pc}\p{L}]\w*)\b\s*(:)
        captures:
          1: {name: variable.other.readwrite.jsdoc}
      - include: '#jsdoc-name-path-scopes'
      - include: '#jsdoc-typedef-obj'

  jsdoc-name-scopes:
    patterns:
      - match: ((?!\*/)[\S&&[^\[\]"']])+
        captures:
          0: {name: variable.other.jsdoc}
      - name: variable.other.jsdoc
        begin: \[
        end: \]|^
        patterns:
          - include: '#jsdoc-string'
          - include: '#jsdoc-name-scopes'

  jsdoc-name-path-scopes:
    patterns:
      - match: \s*(?<!(?:(?<!\.)\.|[?!:]:)=?)\b(as)\b\s*(?=[\p{Pc}\p{L}])
        captures:
          1: {name: keyword.as.jsdoc}
      - match: \s*(?:([\p{Pc}\p{L}&&\P{Ll}]+\w*)|([\p{Pc}\p{L}]\w*))(?=[\s\-~.#]|$)
        captures:
          1: {name: entity.name.class.jsdoc}
          2: {name: entity.name.function.jsdoc}
      - match: (\.)([\p{Pc}\p{L}]\w*)\b(?=\s|$|\")
        captures:
          1: {name: keyword.operator.accessor.jsdoc}
          2: {name: entity.name.function.method.stat.jsdoc}
      - match: (\#)([\p{Pc}\p{L}]\w*)\b(?=\s|$|\")
        captures:
          1: {name: keyword.operator.accessor.jsdoc}
          2: {name: entity.name.function.method.instance.jsdoc}
      - match: (~|-)([\p{Pc}\p{L}]\w*)\b(?=\s|$|\")
        captures:
          1: {name: keyword.operator.accessor.jsdoc}
          2: {name: entity.name.function.method.inner.jsdoc}
      - match: (\#)(event)(:)
        captures:
          1: {name: keyword.operator.accessor.jsdoc}
          2: {name: keyword.event.jsdoc}
          3: {name: keyword.operator.jsdoc}
      - name: string.method.jsdoc
        begin: \.(?="|')
        end: (?=.)
        applyEndPatternLast: true
        patterns:
          - include: '#jsdoc-string'

  jsdoc-string:
    name: string.jsdoc
    match: \"(\\"|[^"])*"|'(\\'|[^'])*'

  # Function and method calls

  sigil-function-calls:
    name: meta.function.arguments.hitori
    match: |
      (?x)
      \b
      (
        (?:
          \b
          [\p{Pc}\p{L}]\w* # identifier
          \b
          (?:[!?]?\.=?|[?!:]:=?) # qualified name separator
        )*
        [\p{Pc}\p{L}]\w* # last part of identifier
      )
      \b
      (?=
        \s*
        (?: # function application, composition and piping
            (?: [$@] | <\|{1,3} | <[+-]) ['"`({\[\w\s]
          | # C-style function call
            (?:[?!:]:=?|[?!]?\.=?)? \#? [({]
          | # generics
            (?:[?!:]:=?|[?!]?\.=?)? < ['"`({\[\w]
          | # macro calls
            ! \#? [({]
          | # strings and symbols
            (?:\w*|[\\$#%]*)['"] | `\s*(?=\N) | :[\p{Pc}\p{L}]\w*
        )
      )
    captures:
      1: {patterns: [include: '#function-names']}

  function-calls:
    patterns:
      - name: meta.function.arguments.hitori
        match: |
          (?x)
          \b
          (
            # ignore all keywords
            (?!
              (?<!(?:(?<!\.)\.|[?!:]:)=?)\b
              (?: # keywords
                [io]n|of|as|is|new|del
                |unset|ref|and|x?or|not
                |var|val|let|const|given|using
                |func|proc|method|type|class|actor
                |impl|enum|module|struct|field
                |union|iter|macro|query|elem
                |object|realm|trait|style|script
                |go|defer|do|with|from|where
                |if|else|then|guard|when
                |for|loop|while|goto|move
                |try|throw|catch|finally|switch
                |match|case|pass|def
                |break|skip|redo|retry
                |return|yield|await|scope
                |import|export|intern|extern
                |debug|assert|check
              )
              \b
            )
            (?:
              \b
              [\p{Pc}\p{L}]\w* # identifier
              \b
              (?:[!?]?\.=?|[?!:]:=?) # qualified name separator
            )*
            [\p{Pc}\p{L}]\w* # last part of identifier
          )
          \b
          (?=
            (?: # function application, composition and piping
                (?: [$@] | <\|{1,3} | <[+-]) ['"`({\[\w\s]
              | # C-style function call
                (?:[?!:]:=?|[?!]?\.=?)? \#? [({]
              | # generics
                (?:[?!:]:=?|[?!]?\.=?)? < ['"`({\[\w]
              | # macro calls
                ! \#? [({]
              | # strings
                (?:\w*|[\\$#%]*)['"] | `\s*(?=\N) | :[\p{Pc}\p{L}]\w*
            )
          )
        captures:
          1: {patterns: [include: '#function-names']}
      - name: meta.function.arguments.hitori
        match: |
          (?x)
          (?<=
            \s* # opening
            (?:\|{1,3}> | [+-]>) # operator
            \s*
          )
          \b
          (
            # ignore all keywords
            (?!
              (?<!(?:(?<!\.)\.|[?!:]:)=?)\b
              (?: # keywords
                [io]n|of|as|is|new|del
                |unset|ref|and|x?or|not
                |var|val|let|const|given|using
                |func|proc|method|type|class|actor
                |impl|enum|module|struct|field
                |union|iter|macro|query|elem
                |object|realm|trait|style|script
                |go|defer|do|with|from|where
                |if|else|then|guard|when
                |for|loop|while|goto|move
                |try|throw|catch|finally|switch
                |match|case|pass|def
                |break|skip|redo|retry
                |return|yield|await|scope
                |import|export|intern|extern
                |debug|assert|check
              )
              \b
            )
            (?:
              \b
              [\p{Pc}\p{L}]\w* # identifier
              \b
              (?:[!?]?\.=?|[?!:]:=?) # qualified name separator
            )*
            [\p{Pc}\p{L}]\w* # last part of identifier
          )
          \b
        captures:
          1: {patterns: [include: '#function-names']}

  embedded-function-calls:
    name: meta.function.name.hitori
    match: |
      (?x)
      (?:
        (?<=(?:^|[,;'"`(){}\[\]\w\s]|\\.)(?:[!?]?\.=?|[?!:]:=?)) \b
          (?: # Properties
            # Leading underscore
            (\p{Pc}+\w*\b(?!\p{Pc}+))
          | # Train case
            ([\p{L}&&\P{Ll}][\w&&\P{Ll}]*)
          | # Pascal case
            ((?:[\p{Pc}\p{L}&&\P{Ll}][\w&&\P{Lu}]*)+)
          | # Camel or kebab case
            ([\p{Pc}\p{L}]\w*)
          )
        \b
          (?= # opening bracket
              \#? [({]
            | generics
              [?!:]: < | [?!]?\. < | <
            | # macro calls
              ! \#? [({]
          )
        |
        (?<= ^ # beginning of line
          | ['"`({\[)}\]\w\s] # literal
          (?: # operators
            [\p{S}\p{P}&&[^,;'"`({\[)}\]\p{Pc}]]+
          )?
        ) \b
          (?: # Regular variables
            # Leading underscore
            (\p{Pc}+\w*\b(?!\p{Pc}+))
          | # Train case
            ([\p{L}&&\P{Ll}][\w&&\P{Ll}]*)
          | # Pascal case
            ((?:[\p{Pc}\p{L}&&\P{Ll}][\w&&\P{Lu}]*)+)
          | # Camel or kebab case
            ([\p{Pc}\p{L}]\w*)
          )
        \b
          (?= # opening bracket
              \#? [({]
            | generics
              [?!:]: < | [?!]?\. < | <
            | # macro calls
              ! \#? [({]
          )
      )
    captures:
      1:
        patterns: &builtin-names
          - include: '#type-names'
          - include: '#support-functions'
        name: entity.name.tag.hitori
      2:
        patterns: *builtin-names
        name: entity.name.tag.hitori support.class.component.hitori
      3:
        patterns: *builtin-names
        name: entity.name.class.builtin.hitori
      4:
        patterns: *builtin-names
        name: entity.name.function.member.hitori
      5:
        patterns: *builtin-names
        name: entity.name.function.tagged-template.hitori
      6:
        patterns: *builtin-names
        name: entity.name.type.hitori
      7:
        patterns: *builtin-names
        name: entity.name.class.hitori
      8:
        patterns: *builtin-names
        name: entity.name.function.hitori

  function-names:
    patterns:
      - &function-names
        name: meta.function.name.hitori
        match: |
          (?x)
          (?:
            (?<=(?:^|[,;'"`(){}\[\]\w\s]|\\.)(?:[!?]?\.=?|[?!:]:=?)) \b
              (?: # Properties
                # Leading underscore
                (\p{Pc}+\w*\b(?!\p{Pc}+))
              | # Train case
                ([\p{L}&&\P{Ll}][\w&&\P{Ll}]*)
              | # Pascal case
                ((?:[\p{Pc}\p{L}&&\P{Ll}][\w&&\P{Lu}]*)+)
              | # Camel or kebab case
                ([\p{Pc}\p{L}]\w*)
              )
            \b
              (?=
                  $ # end of line
                | (?: # operators
                    <\|{1,3} | <[-+] | \|{1,3}> | [-+]> | [$@]
                  )?
                  ['"`({\[)}\]\w\s]
              )
            |
            (?<=
              (?: ^ | [,;'"`({\[)}\]\w\s] | \\. ) # literal
              (?: # operators
                [\p{S}\p{P}&&[^,;'"`({\[)}\]\p{Pc}]]+
              )?
            ) \b
              (?: # Regular variables
                # Leading underscore
                (\p{Pc}+\w*\b(?!\p{Pc}+))
              | # Train case
                ([\p{L}&&\P{Ll}][\w&&\P{Ll}]*)
              | # Pascal case
                ((?:[\p{Pc}\p{L}&&\P{Ll}][\w&&\P{Lu}]*)+)
              | # Camel or kebab case
                ([\p{Pc}\p{L}]\w*)
              )
            \b
              (?=
                  $ # end of line
                | (?: # operators
                    <\|{1,3} | <[-+] | \|{1,3}> | [-+]> | [$@]
                  )?
                  ['"`({\[)}\]\w\s]
              )
          )
        captures:
          1:
            patterns: &builtin-names
              - include: '#type-names'
              - include: '#support-functions'
            name: entity.name.tag.hitori
          2:
            patterns: *builtin-names
            name: entity.name.tag.hitori support.class.component.hitori
          3:
            patterns: *builtin-names
            name: entity.name.class.builtin.hitori
          4:
            patterns: *builtin-names
            name: entity.name.function.member.hitori
          5:
            patterns: *builtin-names
            name: entity.name.function.tagged-template.hitori
          6:
            patterns: *builtin-names
            name: entity.name.type.hitori
          7:
            patterns: *builtin-names
            name: entity.name.class.hitori
          8:
            patterns: *builtin-names
            name: entity.name.function.hitori
      - include: '#variables'
      - include: '#primary-operators'

  # Variables

  parameter-variables:
    patterns:
      - match: |
          (?x)
          (?<=
            (?:
              ^ # SOL
              | (?:^ | [^|]) \| # open pipe
              | [({\[] # open bracket
              | [;,] # separator
              | [(|]\. \s # uncurried function
              | (?:^|[,;'"({\[)}\]|\s])
                \b (?:
                  var|val|let|const|given|using
                  |func|proc|method|type|class|actor
                  |impl|enum|module|struct|field
                  |union|iter|macro|query|elem
                  |object|realm|trait|style|script|as
                  |given|using
                ) \b
                (?:$|[,;'"({\[)}\]\s]) # var/val/as/given/using keyword
            ) \s*
          )
            \s*
            [?!] # optional or required
            \b [\p{Pc}\p{L}]\w* \b
            \s*
          (?=
            $ # EOL
            | # close bracket or pipe
              \s* [)}\]] | \s* \|:? [\w\s'"`({\[)}\]]
            | # separator
              \s* [;,]
            | # as keyword (aliasing)
              \s*
              (?<!(?:(?<!\.)\.|[?!:]:)=?)\b(as)\b
              \s*
            | # type specifier and assignment
              (?::|[?:]?=) \s* [\w'"`({\[]
            | \s+ (?::|[?:]?=) \s+ [\w'"`({\[]
          )
        name: variable.parameter.optional.hitori
      - match: |
          (?x)
          (?<=
            (?:
              ^ # SOL
              | (?:^ | [^|]) \| # open pipe
              | [({\[] # open bracket
              | [;,] # separator
              | [(|]\. \s # uncurried function
              | (?:^|[,;'"({\[)}\]|\s])
                \b (?:
                  var|val|let|const|given|using
                  |func|proc|method|type|class|actor
                  |impl|enum|module|struct|field
                  |union|iter|macro|query|elem
                  |object|realm|trait|style|script|as
                  |given|using
                ) \b
                (?:$|[,;'"({\[)}\]\s]) # var/val/as/given/using keyword
            ) \s*
          )
            \s*
            \*\*? # spread
            [?!]? # optional or required
            \b [\p{Pc}\p{L}]\w* \b
          (?=
            $ # EOL
            | # close bracket or pipe
              \s* [)}\]] | \s* \|:? [\w\s'"`({\[)}\]]
            | # separator
              \s* [;,]
            | # as keyword (aliasing)
              \s*
              (?<!(?:(?<!\.)\.|[?!:]:)=?)\b(as)\b
              \s*
            | # type specifier and assignment
              (?::|[?:]?=) \s* [\w'"`({\[]
            | \s+ (?::|[?:]?=) \s+ [\w'"`({\[]
          )
        name: variable.parameter.spread.hitori
      - match: |
          (?x)
          (?<=
            (?:
              ^ # SOL
              | (?:^ | [^|]) \| # open pipe
              | [({\[] # open bracket
              | [;,] # separator
              | [(|]\. \s # uncurried function
              | (?:^|[,;'"({\[)}\]|\s])
                \b (?:
                  var|val|let|const|given|using
                  |func|proc|method|type|class|actor
                  |impl|enum|module|struct|field
                  |union|iter|macro|query|elem
                  |object|realm|trait|style|script|as
                  |given|using
                ) \b
                (?:$|[,;'"({\[)}\]\s]) # var/val/as/given/using keyword
            ) \s*
          )
            \s*
            ~~? # named
            [?!]? # optional or required
            \b [\p{Pc}\p{L}]\w* \b
          (?=
            $ # EOL
            | # close bracket or pipe
              \s* [)}\]] | \s* \|:? [\w\s'"`({\[)}\]]
            | # separator
              \s* [;,]
            | # as keyword (aliasing)
              \s*
              (?<!(?:(?<!\.)\.|[?!:]:)=?)\b(as)\b
              \s*
            | # type specifier and assignment
              (?::|[?:]?=) \s* [\w'"`({\[]
            | \s+ (?::|[?:]?=) \s+ [\w'"`({\[]
          )
        name: variable.parameter.name.hitori
      - match: |
          (?x)
          (?<=
            (?:
              ^ # SOL
              | (?:^ | [^|]) \| # open pipe
              | [({\[] # open bracket
              | [;,] # separator
              | [(|]\. \s # uncurried function
              | (?:^|[,;'"({\[)}\]|\s])
                \b (?:
                  var|val|let|const|given|using
                  |func|proc|method|type|class|actor
                  |impl|enum|module|struct|field
                  |union|iter|macro|query|elem
                  |object|realm|trait|style|script|as
                  |given|using
                ) \b
                (?:$|[,;'"({\[)}\]\s]) # var/val/as/given/using keyword
            ) \s*
          )
            \s*
            \& # reference
            [?!]? # optional or required
            \b [\p{Pc}\p{L}]\w* \b
          (?=
            $ # EOL
            | # close bracket or pipe
              \s* [)}\]] | \s* \|:? [\w\s'"`({\[)}\]]
            | # separator
              \s* [;,]
            | # as keyword (aliasing)
              \s*
              (?<!(?:(?<!\.)\.|[?!:]:)=?)\b(as)\b
              \s*
            | # type specifier and assignment
              (?::|[?:]?=) \s* [\w'"`({\[]
            | \s+ (?::|[?:]?=) \s+ [\w'"`({\[]
          )
        name: variable.parameter.reference.hitori
      - match: |
          (?x)
          (?<=
            (?:
              ^ # SOL
              | (?:^ | [^|]) \| # open pipe
              | [({\[] # open bracket
              | [;,] # separator
              | [(|]\. \s # uncurried function
              | (?:^|[,;'"({\[)}\]|\s])
                \b (?:
                  var|val|let|const|given|using
                  |func|proc|method|type|class|actor
                  |impl|enum|module|struct|field
                  |union|iter|macro|query|elem
                  |object|realm|trait|style|script|as
                  |given|using
                ) \b
                (?:$|[,;'"({\[)}\]\s]) # var/val/as/given/using keyword
            ) \s*
          )
            \s*
            \% # other
            [?!]? # optional or required
            \b [\p{Pc}\p{L}]\w* \b
          (?=
            $ # EOL
            | # close bracket or pipe
              \s* [)}\]] | \s* \|:? [\w\s'"`({\[)}\]]
            | # separator
              \s* [;,]
            | # as keyword (aliasing)
              \s*
              (?<!(?:(?<!\.)\.|[?!:]:)=?)\b(as)\b
              \s*
            | # type specifier and assignment
              (?::|[?:]?=) \s* [\w'"`({\[]
            | \s+ (?::|[?:]?=) \s+ [\w'"`({\[]
          )
        name: variable.parameter.other.hitori
      - match: |
          (?x)
          (?<=
            (?:
              ^ # SOL
              | (?:^ | [^|]) \| # open pipe
              | [({\[] # open bracket
              | [;,] # separator
              | [(|]\. \s # uncurried function
              | (?:^|[,;'"({\[)}\]|\s])
                \b (?:
                  var|val|let|const|given|using
                  |func|proc|method|type|class|actor
                  |impl|enum|module|struct|field
                  |union|iter|macro|query|elem
                  |object|realm|trait|style|script|as
                  |given|using
                ) \b
                (?:$|[,;'"({\[)}\]\s]) # var/val/as/given/using keyword
            ) \s*
          )
            \s*
            \b [\p{Pc}\p{L}]\w* \b
          (?=
            $ # EOL
            | # close bracket or pipe
              \s* [)}\]] | \s* \|:? [\w\s'"`({\[)}\]]
            | # separator
              \s* [;,]
            | # as keyword (aliasing)
              \s*
              (?<!(?:(?<!\.)\.|[?!:]:)=?)\b(as)\b
              \s*
            | # type specifier and assignment
              (?::|[?:]?=) \s* [\w'"`({\[]
            | \s+ (?::|[?:]?=) \s+ [\w'"`({\[]
          )
        name: variable.parameter.hitori

  placeholder-variables:
    patterns:
      - match: (?i)\s*[?!][\p{Pc}\p{L}]\w*\b\s*
        name: variable.parameter.optional.hitori
      - match: (?i)\s*\*\*?[?!]?[\p{Pc}\p{L}]\w*\b\s*
        name: variable.parameter.spread.hitori
      - match: (?i)\s*~~?[?!]?[\p{Pc}\p{L}]\w*\b\s*
        name: variable.parameter.name.hitori
      - match: (?i)\s*&[?!]?[\p{Pc}\p{L}]\w*\b\s*
        name: variable.parameter.reference.hitori
      - match: (?i)\s*%[?!]?[\p{Pc}\p{L}]\w*\b\s*
        name: variable.parameter.other.hitori
      - match: (?i)\s*\b[\p{Pc}\p{L}]\w*\b\s*
        name: variable.parameter.hitori

  variables:
    patterns:
      - match: |
          (?x)
          (?<=
            \b # qualified name
              [\p{Pc}\p{L}]\w* # identifier
              (?:(?:[?!]?\.|[?!:]:)=?)
            \b
          )
          (?:\d\w*)
        name: variable.other.index.hitori
      - &variable-name
        comment: |
          Four types of variables:
          - _lead_underscore
          - UPPERCASE
          - PascalCase
          - camelCase
        match: |
          (?x) \b

          (?:
            (?<=(?:^|[,;'"`(){}\[\]\w\s]|\\.)(?:[!?]?\.=?|[?!:]:=?))
            (?: # Properties
                # Leading underscore
                (\p{Pc}+\w*\b(?!\p{Pc}+))
              | # Train case
                ([\p{L}&&\P{Ll}][\w&&\P{Ll}]*)
              | # Pascal case
                ((?:[\p{Pc}\p{L}&&\P{Ll}][\w&&\P{Lu}]*)+)
              | # Camel or kebab case
                ([\p{Pc}\p{L}]\w*)
            )
            |
            (?: # Objects
                # Leading underscore
                (\p{Pc}+\w*\b(?!\p{Pc}+))
              | # Train case
                ([\p{L}&&\P{Ll}][\w&&\P{Ll}]*)
              | # Pascal case
                ((?:[\p{Pc}\p{L}&&\P{Ll}][\w&&\P{Lu}]*)+)
              | # Camel or kebab case
                ([\p{Pc}\p{L}]\w*)
            )
            (?=(?:[!?]?\.=?|[?!:]:=?|\s*\#?\[)(?:[,;'"`(){}\[\]\w\s]|$))
            |
            (?: # Regular variables
                # Leading underscore
                (\p{Pc}+\w*\b(?!\p{Pc}+))
              | # Train case
                ([\p{L}&&\P{Ll}][\w&&\P{Ll}]*)
              | # Pascal case
                ((?:[\p{Pc}\p{L}&&\P{Ll}][\w&&\P{Lu}]*)+)
              | # Camel or kebab case
                ([\p{Pc}\p{L}]\w*)
            )
          ) \b
        captures:
          1: {name: variable.other.property.dynamic.hitori}
          2: {name: variable.other.constant.property.hitori}
          3: {name: variable.other.property.stat.hitori}
          4: {name: variable.other.property.hitori}
          5: {name: variable.other.global.hitori}
          6: {name: variable.other.constant.object.hitori}
          7: {name: variable.other.class.stat.hitori}
          8: {name: variable.other.object.hitori}
          9: {name: variable.other.dollar.hitori}
          10: {name: variable.other.constant.hitori}
          11: {name: variable.other.class.hitori}
          12: {name: variable.other.readwrite.hitori}

  # Operators

  operators:
    patterns:
      - include: '#special-operators'
      - include: '#infix-operators'
      - include: '#primary-operators'
      - include: '#suffix-operators'
      - include: '#prefix-operators'

  special-operators:
    patterns:
      - match: (?<=>|\w)(!)(?=#?[({])
        captures:
          1: {name: keyword.operator.macro.hitori}
      - comment: '? ternary operator'
        begin: (?<=^|[\s({\[])(\?)(?=$|[)}\]\s])|(?<=['"`)}\]\w]|\\.)(\?)(?=['"`({\[\w])
        end: (?<=^|[\s({\[])(\:)(?=$|[)}\]\s])|(?<=['"`)}\]\w]|\\.)(\:)(?=['"`({\[\w])
        captures:
          1: {name: keyword.operator.conditional.hitori}
          2: {name: keyword.operator.conditional.hitori}
        patterns:
          - include: $self
      - comment: '! ternary operator'
        begin: (?<=^|[\s({\[])(\!)(?=$|[)}\]\s])|(?<=['"`)}\]\w]|\\.)(\!)(?=['"`({\[\w])
        end: (?<=^|[\s({\[])(\:)(?=$|[)}\]\s])|(?<=['"`)}\]\w]|\\.)(\:)(?=['"`({\[\w])
        captures:
          1: {name: keyword.operator.ternary.hitori}
          2: {name: keyword.operator.ternary.hitori}
        patterns:
          - include: $self

  infix-operators:
    name: keyword.operator.infix.hitori
    match: |
      (?xi)
      (?<=^|[\s({\[]) # opening
      (?:
        ( # 1: optional accessor
        \?[.:]=?
        ) |
        ( # 2: assertion/call operator
          ![.:]=?
        ) |
        ( # 3: accessor operator
          (?:::|\.)=?
        ) |
        ( # 4: compound assignment operators
          # all operators except ~ < = > . : !
          [\p{S}\p{P}&&[^~<=>.,:;!'"`({\[)}\]\p{Pc}]]
          # operator character
          [\p{S}\p{P}&&[^,;'"`({\[)}\]\p{Pc}]]*
          = # ending equal sign
        ) |
        ( # 5: arithmetic operator
          [+-][\%\|]? | \*{1,3}[\%\|]? | ~?/ | %%?
        ) |
        ( # 6: string/regex/array/set
          \+\+ | \-\-
        ) |
        ( # 7: logical operator
          \&\& | \|\| | \^\^ | ! | /\\ | \\/
        ) |
        ( # 8: bitwise and set
          \& | \| | \^ | ~
        ) |
        ( # 9: bitwise shift/rotate
          <<[<>]? | [<>]?>>
        ) |
        ( # 10: pipeline
          <\|+ | \|+>
        ) |
        ( # 11: composition
          <\+ | \+>
        ) |
        ( # 12: membership
          [<>][:!] | [:!][<>]
        ) |
        ( # 13: comparison
          < | > | <= | >= | <> | <=>
        ) |
        ( # 14: equality
          == | != | === | !==
        ) |
        ( # 15: similarity
          ~[=!] | [=!]~ | =<
        ) |
        ( # 16: functional
          <[/*|+$:]> | [/*|+$:]> | <[/*|+$:]
        ) |
        ( # 17: null coalescing
          \?+
        ) |
        ( # 18: non null coalescing
          !+
        ) |
        ( # 19: falsy coalescing
          \?:
        ) |
        ( # 20: truthy coalescing
          !:
        ) |
        ( # 21: function application
          [.$]
        ) |
        ( # 22: assignment
          :?=
        ) |
        ( # 23: range
          [>.]\.[.<] | \.\. | [=.]\.[.=]
        ) |
        ( # 24: fat arrow
            =+> # right side
          | <=+ # left side
        ) |
        ( # 25: skinny arrow
            -+> # right side
          | <-+ # left side
        ) |
        ( # 26: wavy arrow
            ~+> # right side
          | <~+ # left side
        ) |
        ( # 27: custom logical
          [&|^~] # leading chars
          [\p{S}\p{P}&&[^,;'"`({\[)}\]\p{Pc}]]+
        ) |
        ( # 28: custom arithmetic
          [-+*/%] # leading chars
          [\p{S}\p{P}&&[^,;'"`({\[)}\]\p{Pc}]]+
        ) |
        ( # 29: custom prototype
          [@:] # leading chars
          [\p{S}\p{P}&&[^,;'"`({\[)}\]\p{Pc}]]+
        ) |
        ( # 30: custom accessor
          [.] # leading chars
          [\p{S}\p{P}&&[^,;'"`({\[)}\]\p{Pc}]]+
        ) |
        ( # 31: custom comparison
          [=!] # leading chars
          [\p{S}\p{P}&&[^,;'"`({\[)}\]\p{Pc}]]+
        ) |
        ( # 32: custom relational
          [<>] # leading chars
          [\p{S}\p{P}&&[^,;'"`({\[)}\]\p{Pc}]]+
        ) |
        ( # 33: custom private
          [?\#] # leading chars
          [\p{S}\p{P}&&[^,;'"`({\[)}\]\p{Pc}]]+
        ) |
        ( # 34: custom math
          \p{Sm} # leading chars
          [\p{S}\p{P}&&[^,;'"`({\[)}\]\p{Pc}]]+
        ) |
        ( # 35: custom currency
          \p{Sc} # leading chars
          [\p{S}\p{P}&&[^,;'"`({\[)}\]\p{Pc}]]+
        ) |
        ( # 36: custom ascii
          [\p{S}\p{P}&&[\x80-\xFF]] # leading chars
          [\p{S}\p{P}&&[^,;'"`({\[)}\]\p{Pc}]]+
        ) |
        ( # 37: catch all
          [\p{S}\p{P}&&[^,;'"`({\[)}\]\p{Pc}]]+
        )
      )
      (?=$|[)}\]\s]) # closing
    captures:
      1: {name: keyword.operator.optional.hitori}
      2: {name: keyword.operator.assert.hitori}
      3: {name: keyword.operator.accessor.hitori}
      4: {name: keyword.operator.assignment.augmented.hitori}
      5: {name: keyword.operator.arithmetic.hitori}
      6: {name: keyword.operator.successor.hitori}
      7: {name: keyword.operator.logical.hitori}
      8: {name: keyword.operator.bitwise.hitori}
      9: {name: keyword.operator.bitwise.shift.hitori}
      10: {name: keyword.operator.pipeline.hitori}
      11: {name: keyword.operator.compose.hitori}
      12: {name: keyword.operator.class.hitori}
      13: {name: keyword.operator.relational.hitori}
      14: {name: keyword.operator.comparison.hitori}
      15: {name: keyword.operator.similarity.hitori}
      16: {name: keyword.operator.function.hitori}
      17: {name: keyword.operator.null-coalescing.hitori}
      18: {name: keyword.operator.coalescing.hitori}
      19: {name: keyword.operator.conditional.hitori}
      20: {name: keyword.operator.ternary.hitori}
      21: {name: keyword.operator.macro.hitori}
      22: {name: keyword.operator.assignment.hitori}
      23: {name: keyword.operator.range.hitori}
      24: {name: keyword.operator.arrow.fat.hitori}
      25: {name: keyword.operator.arrow.skinny.hitori}
      26: {name: keyword.operator.arrow.wavy.hitori}
      27: {name: keyword.operator.logical.custom.hitori}
      28: {name: keyword.operator.arithmetic.custom.hitori}
      29: {name: keyword.operator.prototype.custom.hitori}
      30: {name: keyword.operator.accessor.custom.hitori}
      31: {name: keyword.operator.comparison.custom.hitori}
      32: {name: keyword.operator.relational.custom.hitori}
      33: {name: keyword.operator.private.custom.hitori}
      34: {name: keyword.operator.math.custom.hitori}
      35: {name: keyword.operator.currency.custom.hitori}
      36: {name: keyword.operator.ascii.custom.hitori}
      37: {name: keyword.operator.primary.hitori}

  primary-operators:
    name: keyword.operator.primary.hitori
    match: |
      (?x)
      (?<=['"`)}\]\w]|\\.) # closing
      (?:
        ( # 1: optional accessor
        \?[.:]=?
        ) |
        ( # 2: assertion/call operator
          ![.:]=?
        ) |
        ( # 3: accessor operator
          (?:::|\.)=?
        ) |
        ( # 4: compound assignment operators
          # all operators except ~ < = > . : !
          [\p{S}\p{P}&&[^~<=>.,:;!'"`({\[)}\]\p{Pc}]]
          # operator character
          [\p{S}\p{P}&&[^,;'"`({\[)}\]\p{Pc}]]*
          = # ending equal sign
        ) |
        ( # 5: arithmetic operator
          [+-][\%\|]? | \*{1,3}[\%\|]? | ~?/ | %%?
        ) |
        ( # 6: string/regex/array/set
          \+\+ | \-\-
        ) |
        ( # 7: logical operator
          \&\& | \|\| | \^\^ | ! | /\\ | \\/
        ) |
        ( # 8: bitwise and set
          \& | \| | \^ | ~
        ) |
        ( # 9: bitwise shift/rotate
          <<[<>]? | [<>]?>>
        ) |
        ( # 10: pipeline
          <\|+ | \|+>
        ) |
        ( # 11: composition
          <\+ | \+>
        ) |
        ( # 12: membership
          [<>][:!] | [:!][<>]
        ) |
        ( # 13: comparison
          < | > | <= | >= | <> | <=>
        ) |
        ( # 14: equality
          == | != | === | !==
        ) |
        ( # 15: similarity
          ~[=!] | [=!]~ | =<
        ) |
        ( # 16: functional
          <[/*|+$:]> | [/*|+$:]> | <[/*|+$:]
        ) |
        ( # 17: null coalescing
          \?+
        ) |
        ( # 18: non null coalescing
          !+
        ) |
        ( # 19: falsy coalescing
          \?:
        ) |
        ( # 20: truthy coalescing
          !:
        ) |
        ( # 21: function application
          [.$]
        ) |
        ( # 22: assignment
          :?=
        ) |
        ( # 23: range
          [>.]\.[.<] | \.\. | [=.]\.[.=]
        ) |
        ( # 24: fat arrow
            =+> # right side
          | <=+ # left side
        ) |
        ( # 25: skinny arrow
            -+> # right side
          | <-+ # left side
        ) |
        ( # 26: wavy arrow
            ~+> # right side
          | <~+ # left side
        ) |
        ( # 27: custom logical
          [&|^~] # leading chars
          [\p{S}\p{P}&&[^,;'"`({\[)}\]\p{Pc}]]+
        ) |
        ( # 28: custom arithmetic
          [-+*/%] # leading chars
          [\p{S}\p{P}&&[^,;'"`({\[)}\]\p{Pc}]]+
        ) |
        ( # 29: custom prototype
          [@:] # leading chars
          [\p{S}\p{P}&&[^,;'"`({\[)}\]\p{Pc}]]+
        ) |
        ( # 30: custom accessor
          [.] # leading chars
          [\p{S}\p{P}&&[^,;'"`({\[)}\]\p{Pc}]]+
        ) |
        ( # 31: custom comparison
          [=!] # leading chars
          [\p{S}\p{P}&&[^,;'"`({\[)}\]\p{Pc}]]+
        ) |
        ( # 32: custom relational
          [<>] # leading chars
          [\p{S}\p{P}&&[^,;'"`({\[)}\]\p{Pc}]]+
        ) |
        ( # 33: custom private
          [?\#] # leading chars
          [\p{S}\p{P}&&[^,;'"`({\[)}\]\p{Pc}]]+
        ) |
        ( # 34: custom math
          \p{Sm} # leading chars
          [\p{S}\p{P}&&[^,;'"`({\[)}\]\p{Pc}]]+
        ) |
        ( # 35: custom currency
          \p{Sc} # leading chars
          [\p{S}\p{P}&&[^,;'"`({\[)}\]\p{Pc}]]+
        ) |
        ( # 36: custom ascii
          [\p{S}\p{P}&&[\x80-\xFF]] # leading chars
          [\p{S}\p{P}&&[^,;'"`({\[)}\]\p{Pc}]]+
        ) |
        ( # 37: catch all
          [\p{S}\p{P}&&[^,;'"`({\[)}\]\p{Pc}]]+
        )
      )
      (?=['"`({\[\w]) # opening
    captures:
      1: {name: keyword.operator.optional.hitori}
      2: {name: keyword.operator.assert.hitori}
      3: {name: keyword.operator.accessor.hitori}
      4: {name: keyword.operator.assignment.augmented.hitori}
      5: {name: keyword.operator.arithmetic.hitori}
      6: {name: keyword.operator.successor.hitori}
      7: {name: keyword.operator.logical.hitori}
      8: {name: keyword.operator.bitwise.hitori}
      9: {name: keyword.operator.bitwise.shift.hitori}
      10: {name: keyword.operator.pipeline.hitori}
      11: {name: keyword.operator.compose.hitori}
      12: {name: keyword.operator.class.hitori}
      13: {name: keyword.operator.relational.hitori}
      14: {name: keyword.operator.comparison.hitori}
      15: {name: keyword.operator.similarity.hitori}
      16: {name: keyword.operator.function.hitori}
      17: {name: keyword.operator.null-coalescing.hitori}
      18: {name: keyword.operator.coalescing.hitori}
      19: {name: keyword.operator.conditional.hitori}
      20: {name: keyword.operator.ternary.hitori}
      21: {name: keyword.operator.macro.hitori}
      22: {name: keyword.operator.assignment.hitori}
      23: {name: keyword.operator.range.hitori}
      24: {name: keyword.operator.arrow.fat.hitori}
      25: {name: keyword.operator.arrow.skinny.hitori}
      26: {name: keyword.operator.arrow.wavy.hitori}
      27: {name: keyword.operator.logical.custom.hitori}
      28: {name: keyword.operator.arithmetic.custom.hitori}
      29: {name: keyword.operator.prototype.custom.hitori}
      30: {name: keyword.operator.accessor.custom.hitori}
      31: {name: keyword.operator.comparison.custom.hitori}
      32: {name: keyword.operator.relational.custom.hitori}
      33: {name: keyword.operator.private.custom.hitori}
      34: {name: keyword.operator.math.custom.hitori}
      35: {name: keyword.operator.currency.custom.hitori}
      36: {name: keyword.operator.ascii.custom.hitori}
      37: {name: keyword.operator.primary.hitori}

  prefix-operators:
    comment: Prefix operators
    match: |
      (?x)
      (?:
        ([*/]) # 1
        |(\+) # 2
        |(\-) # 3
        |(\&) # 4
        |(\|) # 5
        |(\^) # 6
        |(\!) # 7
        |(\$) # 8
        |(\@) # 9
        |(\~) # 10
        |(\?) # 11
        |(\=) # 12
        |(\$) # 13
        |(\#) # 14
        |[\p{S}\p{P}&&[^,;'"`({\[)}\]\p{Pc}]]
      ) # 15
      (?=[\p{S}\p{P}&&[^,;'"`({\[)}\]\p{Pc}]]*
      ['"`({\[\w])
    name: keyword.operator.prefix.hitori
    captures:
      1: {name: keyword.operator.module.all.hitori}
      2: {name: keyword.operator.increment.hitori}
      3: {name: keyword.operator.decrement.hitori}
      4: {name: keyword.operator.intersection.hitori}
      5: {name: keyword.operator.union.hitori}
      6: {name: keyword.operator.symmetric.hitori}
      7: {name: keyword.operator.logical.hitori}
      8: {name: keyword.operator.private.hitori}
      9: {name: keyword.operator.decorator.hitori}
      10: {name: keyword.operator.bitwise.not.hitori}
      11: {name: keyword.operator.existential.hitori}
      12: {name: keyword.operator.assignment.hitori}
      13: {name: keyword.operator.pipeline.hitori}
      14: {name: keyword.operator.private.hitori}
      15: {name: keyword.operator.prefix.hitori}

  suffix-operators:
    comment: Suffix operators
    match: |
      (?x)
      (?<=(?:['"`)}\]\w]|\\.)
        [\p{S}\p{P}&&[^,;'"`({\[)}\]\p{Pc}]]*)
      (?:
        ([*/]) # 1
        |(\+) # 2
        |(\-) # 3
        |(\&) # 4
        |(\|) # 5
        |(\^) # 6
        |(\!) # 7
        |(\$) # 8
        |(\@) # 9
        |(\~) # 10
        |(\?) # 11
        |(\=) # 12
        |(\$) # 13
        |(\#) # 14
        |[\p{S}\p{P}&&[^,;'"`({\[)}\]\p{Pc}]]
      ) # 15
    name: keyword.operator.suffix.hitori
    captures:
      1: {name: keyword.operator.module.all.hitori}
      2: {name: keyword.operator.increment.hitori}
      3: {name: keyword.operator.decrement.hitori}
      4: {name: keyword.operator.intersection.hitori}
      5: {name: keyword.operator.union.hitori}
      6: {name: keyword.operator.symmetric.hitori}
      7: {name: keyword.operator.assert.hitori}
      8: {name: keyword.operator.private.hitori}
      9: {name: keyword.operator.decorator.hitori}
      10: {name: keyword.operator.bitwise.hitori}
      11: {name: keyword.operator.optional.hitori}
      12: {name: keyword.operator.assignment.hitori}
      13: {name: keyword.operator.pipeline.hitori}
      14: {name: keyword.operator.private.hitori}
      15: {name: keyword.operator.suffix.hitori}

  # Clauses and Keywords

  parameter-brackets:
    begin: (\()\s*
    end: \s*(\))
    captures:
      1: {name: punctuation.definition.parameters.hitori}
    patterns:
      - include: '#binding-pattern'
      - include: $self

  modifier-keywords:
    name: storage.modifier.hitori
    match: |
      (?x)
      (
        (?:
          (?:
            \s*
            (?<!(?:(?<!\.)\.|[?!:]:)=?)
            \b
              (?:
                pub|priv|prot|final|readonly|override
                |global|local|intern|extern|mut|immut
                |post|[gs]et|put|del|req|opt
                |safe|unsafe|virtual|sealed|abs|friend|enemy
                |pure|impure|early|late|covar|contra
                |in|out|inout|inplace|ref|defer|a?sync
                |stat|dyn|lazy|eager|bound|free|unique
                |union|open|closed?|rec|oper|curry|opaque
                |inline|prefix|infix|suffix|unary|left|right
              )
            )
            \b
          \s*
        )*
      )
      (?=
        \s*(?<!(?:(?<!\.)\.|[?!:]:)=?)\b
        (?:
          var|val|let|const|given|using
          |func|proc|method|type|class|actor
          |impl|enum|module|struct|field
          |union|iter|macro|query|elem
          |object|realm|trait|style|script
          |import|export|intern|extern
        )
        \b\s*
      )
    captures:
      1:
        patterns:
          - include: '#modifiers'

  modifiers:
    patterns:
      - comment: Visibility modifiers
        match: |
          (?x) \s*
          \b
          (?:
            pub|priv|prot|final|readonly|override
            |global|local|intern|extern|mut|immut
            |post|[gs]et|put|del|req|opt
            |safe|unsafe|virtual|sealed|abs|friend|enemy
          )
          \b
          \s*
        name: storage.modifier.hitori
      - comment: Visibility modifiers
        match: |
          (?x) \s*
          \b
          (?:
            in|out|inout|inplace|ref|defer|a?sync
            |stat|dyn|lazy|eager|bound|free|unique
            |union|open|closed?
          )
          \b
          \s*
        name: storage.modifier.declaration.hitori
      - comment: Functional modifiers
        match: |
          (?x) \s*
          \b
          (?:
            rec|oper|curry|opaque|inline|prefix
            |infix|suffix|unary|left|right
          )
          \b
          \s*
        name: storage.modifier.function.hitori

  declaration-keywords:
    patterns:
      - match: \s*(?<!(?:(?<!\.)\.|[?!:]:)=?)\b(declare)\b\s*
        name: keyword.other.declare.hitori
      - match: \s*(?<!(?:(?<!\.)\.|[?!:]:)=?)\b(var|val|let|const|given|using)\b\s*
        name: storage.type.hitori
      - match: |
          (?x)
          \s*
            (?<!(?:(?<!\.)\.|[?!:]:)=?)\b
            (
              func|func|proc|method|type|class|actor
              |impl|enum|module|struct|field
              |union|iter|macro|query|elem
              |object|realm|trait|style|script
            )
            \b
          \s*
        name: storage.type.$1.hitori

  general-keywords:
    comment: general keywords
    patterns:
      - match: \s*(?<!(?:(?<!\.)\.|[?!:]:)=?)\b(if|else|guard|when)\b\s*
        name: keyword.control.conditional.hitori
      - match: \s*(?<!(?:(?<!\.)\.|[?!:]:)=?)\b(for|loop|while)\b\s*
        name: keyword.control.loop.hitori
      - match: \s*(?<!(?:(?<!\.)\.|[?!:]:)=?)\b(try|throw|catch|finally|then)\b\s*
        name: keyword.control.trycatch.hitori
      - match: \s*(?<!(?:(?<!\.)\.|[?!:]:)=?)\b(switch|case|def)\b\s*
        name: keyword.control.switch.hitori
      - match: \s*(?<!(?:(?<!\.)\.|[?!:]:)=?)\b(match)\b\s*
        name: keyword.control.match.hitori
      - match: \s*(?<!(?:(?<!\.)\.|[?!:]:)=?)\b(break|skip|redo|retry|return|await|scope|yield|goto|move|pass)\b\s*
        name: keyword.control.flow.hitori
      - match: \s*(?<!(?:(?<!\.)\.|[?!:]:)=?)\b(import|export|intern|extern)\b\s*
        name: keyword.control.module.hitori
      - match: \s*(?<!(?:(?<!\.)\.|[?!:]:)=?)\b(with|do|from|ref|go|defer)\b\s*
        name: keyword.control.$1.hitori
      - match: \s*(?<!(?:(?<!\.)\.|[?!:]:)=?)\b(debug|assert|check|where)\b\s*
        name: keyword.other.$1.hitori

  expression-keywords:
    comment: expression keywords
    patterns:
      - match: \s*(?<!(?:(?<!\.)\.|[?!:]:)=?)\b(as|new)\b\s*
        name: keyword.operator.expression.$1.hitori
      - match: \s*(?<!(?:(?<!\.)\.|[?!:]:)=?)\b(not\s+)?([io]n|of)\b\s*
        name: keyword.operator.expression.$2.hitori
      - match: \s*(?<!(?:(?<!\.)\.|[?!:]:)=?)\b(is\s+not|is)\b\s*
        name: keyword.operator.expression.is.hitori
      - match: \s*(?<!(?:(?<!\.)\.|[?!:]:)=?)\b(delete)\b\s*
        name: keyword.operator.expression.delete.hitori
      - match: \s*(?<!(?:(?<!\.)\.|[?!:]:)=?)\b(unset)\b\s*
        name: keyword.operator.expression.void.hitori
      - match: \s*(?<!(?:(?<!\.)\.|[?!:]:)=?)\b(and|x?or|not)\b\s*
        name: keyword.operator.expression.logical.hitori

  keywords:
    patterns:
      - include: '#module-expression'
      - include: '#control-expression'
      - include: '#query-expression'
      - include: '#constraint-expression'
      - include: '#modifier-keywords'
      - include: '#declaration-keywords'
      - include: '#expression-keywords'
      - include: '#general-keywords'

  control-expression:
    applyEndPatternLast: true
    begin: \s*(?<!(?:(?<!\.)\.|[?!:]:)=?)\b(break|skip|redo|retry|scope|goto|move|pass)\b\s*
    end: (?=)|$
    beginCaptures:
      1: {name: keyword.control.flow.hitori}
    patterns:
      - match: *entity-name
        name: constant.other.label.hitori

  module-expression:
    patterns:
      - applyEndPatternLast: true
        begin: \s*(?<!(?:(?<!\.)\.|[?!:]:)=?)\b(import|export|intern|extern)\b\s*
        end: (?=)|$
        beginCaptures:
          1: {name: keyword.control.module.hitori}
        patterns:
          - match: \s*(?<!(?:(?<!\.)\.|[?!:]:)=?)\b(from|to|as|only|except|def)\b\s*
            name: keyword.control.module.hitori
          - include: '#module-content'

    repository:
      module-content:
        patterns:
          - begin: ({)\s*
            end: \s*(})
            captures:
              1: {name: punctuation.definition.block.hitori}
            patterns:
              - include: '#module-content'
              - include: '#illegal'
          - match: \s*(?<!(?:(?<!\.)\.|[?!:]:)=?)\b(as)\b\s*
            name: keyword.control.module.hitori
          - include: '#type-keywords'
          - include: '#strings'
          - include: '#regexps'
          - include: '#symbols'
          - match: \s*(?<!\*)\*(?!\*)\s*
            name: constant.language.import-export-all.js
          - include: '#modifiers'
          - include: '#comma'
          - include: '#line-continuation'
          - match: *entity-name
            name: variable.other.readwrite.alias.hitori

  constraint-expression:
    comment: most of the keywords come from Dafny
    begin: \s*(?<!(?:(?<!\.)\.|[?!:]:)=?)\b(where)\b\s*
    beginCaptures:
      1: {name: keyword.control.validate.hitori}
    end: (?=[,;)}\]])
    patterns:
      - match: &constraint-keyword |
          (?x)
          \s*
            (?<!(?:(?<!\.)\.|[?!:]:)=?)\b(
              (?:
                require|ensure|(de|in)(crease|crement)|throw|read|assume
                |return|yield|varie|change|create|alter|delete|drop|rename
                |reveal|write|name|permit|allow|grant|revoke|deny|disallow
                |modifie|renew|transfer|postpone|suspend|resume|abort|reject
                |cancel|post|put|get|set|patch|delete|trace|connect|disconnect
                |accept|receive|send|open|close|lock|unlock|flush|reboot|reload
                |restart|start|stop|kill|spawn|invoke|execute|derive|connect
                |extend|implement|use|borrow|lend
              )s
            )
            \b\s*
          \s*
        name: keyword.control.validate.hitori
      - include: $self

  query-expression:
    begin: \s*(?<!(?:(?<!\.)\.|[?!:]:)=?)\b(from)\b\s*
    beginCaptures:
      1: {name: keyword.control.query.hitori}
    end: (?=[,;)}\]])
    patterns:
      - include: '#query-body'
      - include: $self

  query-body:
    patterns:
      - include: '#in-clause'
      - include: '#where-clause'
      - include: '#join-clause'
      - include: '#sort-clause'
      - include: '#select-clause'
      - include: '#group-clause'
      - include: '#limit-clause'
      - include: '#reduce-clause'

    repository:
      in-clause:
        begin: |
          (?x)
          \s*
          (?<!(?:(?<!\.)\.|[?!:]:)=?)\b
            (
              [io]n|of
            )
          \b
          \s*
        beginCaptures:
          1: {name: keyword.control.query.hitori}
          2: {patterns: [include: $self]}
          3: {name: keyword.control.query.hitori}
        end: (?=[,;)}\]])
        patterns:
          - include: '#query-body'
          - include: $self

      join-clause:
        begin: |
          (?x)
          \s*
          (?<!(?:(?<!\.)\.|[?!:]:)=?)\b
            (
              \b (?:full|part|self|cross)? \b \s*
              \b (?:inner|outer|left|right)? \b \s*
              \b (?:join)
            )
          \b
          \s*
        beginCaptures:
          1: {name: keyword.control.query.hitori}
          2: {patterns: [include: $self]}
          3: {name: keyword.control.query.hitori}
        end: (?=[,;)}\]])
        patterns:
          - match: \s*(?<!(?:(?<!\.)\.|[?!:]:)=?)\b([io]nto|equal|[io]n|of)\b\s*
            name: keyword.control.query.hitori
          - include: '#query-body'
          - include: $self

      where-clause:
        begin: |
          (?x)
          \s*
          (?<!(?:(?<!\.)\.|[?!:]:)=?)\b
            (
              where|having|filter|reject
            )
          \b
          \s*
        beginCaptures:
          1: {name: keyword.control.query.hitori}
        end: (?=[,;)}\]])
        patterns:
          - include: '#query-body'
          - include: $self

      sort-clause:
        begin: |
          (?x)
          \s*
          (?<!(?:(?<!\.)\.|[?!:]:)=?)\b
            (
              \b (?:sort|order|then) \b \s*
              \b (?:asc|desc)? \b \s*
              \b (?:by|with)?
            )
          \b
          \s*
        beginCaptures:
          1: {name: keyword.control.query.hitori}
        end: (?=[,;)}\]])
        patterns:
          - include: '#query-body'
          - include: $self

      select-clause:
        begin: |
          (?x)
          \s*
          (?<!(?:(?<!\.)\.|[?!:]:)=?)\b
            (
              \b (?:select|map) \b \s*
              \b (?:unique|any|all|some|every)?
            )
          \b
          \s*
        beginCaptures:
          1: {name: keyword.control.query.hitori}
        end: (?=[,;)}\]])
        patterns:
          - match: \s*(?<!(?:(?<!\.)\.|[?!:]:)=?)\b(by|while|with)\b\s*
            name: keyword.control.query.hitori
          - include: '#query-body'
          - include: $self

      limit-clause:
        begin: |
          (?x)
          \s*
          (?<!(?:(?<!\.)\.|[?!:]:)=?)\b
            (
              \b (?:take|drop|limit|offset) \b \s*
              \b (?:first|last|head|tail)?
            )
          \b
          \s*
        beginCaptures:
          1: {name: keyword.control.query.hitori}
        end: (?=[,;)}\]])
        patterns:
          - match: \s*(?<!(?:(?<!\.)\.|[?!:]:)=?)\b(by|while|with)\b\s*
            name: keyword.control.query.hitori
          - include: '#query-body'
          - include: $self

      reduce-clause:
        begin: |
          (?x)
          \s*
          (?<!(?:(?<!\.)\.|[?!:]:)=?)\b
            (
              \b (?:fold|reduce|scan) \b \s*
              \b (?:first|last|left|right)?
            )
          \b
          \s*
        beginCaptures:
          1: {name: keyword.control.query.hitori}
        end: (?=[,;)}\]])
        patterns:
          - match: \s*(?<!(?:(?<!\.)\.|[?!:]:)=?)\b(by|while|with)\b\s*
            name: keyword.control.query.hitori
          - include: '#query-body'
          - include: $self

      group-clause:
        begin: |
          (?x)
          \s*
          (?<!(?:(?<!\.)\.|[?!:]:)=?)\b
            (
              group
            )
          \b
          \s*
        beginCaptures:
          1: {name: keyword.control.query.hitori}
        end: (?=[,;)}\]])
        patterns:
          - match: \s*(?<!(?:(?<!\.)\.|[?!:]:)=?)\b(by|[io]nto)\b\s*
            name: keyword.control.query.hitori
          - include: '#query-body'
          - include: $self

  declarations:
    patterns:
      - include: '#variable'
      - include: '#declare'
      - include: '#style'
      - include: '#script'
      - include: '#markup'
      - include: '#function'
      - include: '#procedure'
      - include: '#method'
      - include: '#class'
      - include: '#interface'
      - include: '#enum'
      - include: '#module'
      - include: '#iterator'
      - include: '#macro'
      - include: '#query'
      - include: '#object'
      - include: '#trait'
      - include: '#component'
      - include: '#field'
      - include: '#realm'
      - include: '#struct'
      - include: '#union'
      - include: '#model'
      - include: '#namespace'

    repository:
      style:
        applyEndPatternLast: true
        begin: \s*(?<!(?:(?<!\.)\.|[?!:]:)=?)\b(style)\b\s*
        end: (?=)|$
        beginCaptures:
          1: {name: storage.type.style.hitori}
        name: meta.style.hitori
        patterns:
          - include: '#style-rules'
          - include: '#style-pair'
          - include: '#style-block'
          - include: '#declaration-clause'
          - match: *entity-name
            name: entity.name.style.hitori

      script:
        applyEndPatternLast: true
        begin: \s*(?<!(?:(?<!\.)\.|[?!:]:)=?)\b(script)\b\s*
        end: (?=)|$
        beginCaptures:
          1: {name: storage.type.script.hitori}
        name: meta.script.hitori
        patterns:
          - include: '#script-block'
          - include: '#declaration-clause'
          - match: *entity-name
            name: entity.name.script.hitori

      component:
        applyEndPatternLast: true
        begin: \s*(?<!(?:(?<!\.)\.|[?!:]:)=?)\b(elem)\b\s*
        end: (?=)|$
        beginCaptures:
          1: {name: storage.type.component.hitori}
        patterns:
          - include: '#declaration-clause'
          - match: *entity-name
            name: entity.name.component.hitori
            patterns: *html-tag-names

      variable:
        applyEndPatternLast: true
        begin: \s*(?<!(?:(?<!\.)\.|[?!:]:)=?)\b(var|val|let|const|given|using)\b\s*
        end: (?=)|$
        beginCaptures:
          1: {name: storage.type.variable.hitori}

      declare:
        applyEndPatternLast: true
        begin: \s*(?<!(?:(?<!\.)\.|[?!:]:)=?)\b(declare)\b\s*
        end: (?=)|$
        beginCaptures:
          1: {name: keyword.other.declare.hitori}

      function:
        applyEndPatternLast: true
        begin: \s*(?<!(?:(?<!\.)\.|[?!:]:)=?)\b(func)\b\s*
        end: (?=)|$
        beginCaptures:
          1: {name: storage.type.function.hitori}
        patterns:
          - include: '#declaration-clause'
          - match: *entity-name
            name: entity.name.function.hitori

      namespace:
        applyEndPatternLast: true
        begin: \s*(?<!(?:(?<!\.)\.|[?!:]:)=?)\b(actor)\b\s*
        end: (?=)|$
        beginCaptures:
          1: {name: storage.type.namespace.hitori}
        patterns:
          - include: '#declaration-clause'
          - match: *entity-name
            name: entity.name.namespace.hitori

      method:
        applyEndPatternLast: true
        begin: \s*(?<!(?:(?<!\.)\.|[?!:]:)=?)\b(method)\b\s*
        end: (?=)|$
        beginCaptures:
          1: {name: storage.type.method.hitori}
        patterns:
          - include: '#declaration-clause'
          - match: *entity-name
            name: entity.name.method.hitori

      procedure:
        applyEndPatternLast: true
        begin: \s*(?<!(?:(?<!\.)\.|[?!:]:)=?)\b(proc)\b\s*
        end: (?=)|$
        beginCaptures:
          1: {name: storage.type.procedure.hitori}
        patterns:
          - include: '#declaration-clause'
          - match: *entity-name
            name: entity.name.procedure.hitori

      class:
        applyEndPatternLast: true
        begin: \s*(?<!(?:(?<!\.)\.|[?!:]:)=?)\b(class)\b\s*
        end: (?=)|$
        beginCaptures:
          1: {name: storage.type.class.hitori}
        patterns:
          - include: '#declaration-clause'
          - match: *entity-name
            name: entity.name.class.hitori

      interface:
        applyEndPatternLast: true
        begin: \s*(?<!(?:(?<!\.)\.|[?!:]:)=?)\b(impl)\b\s*
        end: (?=)|$
        beginCaptures:
          1: {name: storage.type.interface.hitori}
        patterns:
          - include: '#declaration-clause'
          - match: *entity-name
            name: entity.name.interface.hitori

      enum:
        applyEndPatternLast: true
        begin: \s*(?<!(?:(?<!\.)\.|[?!:]:)=?)\b(enum)\b\s*
        end: (?=)|$
        beginCaptures:
          1: {name: storage.type.enum.hitori}
        patterns:
          - include: '#declaration-clause'
          - match: *entity-name
            name: entity.name.enum.hitori

      module:
        applyEndPatternLast: true
        begin: \s*(?<!(?:(?<!\.)\.|[?!:]:)=?)\b(module)\b\s*
        end: (?=)|$
        beginCaptures:
          1: {name: storage.type.module.hitori}
        patterns:
          - include: '#declaration-clause'
          - match: *entity-name
            name: entity.name.module.hitori

      iterator:
        applyEndPatternLast: true
        begin: \s*(?<!(?:(?<!\.)\.|[?!:]:)=?)\b(iter)\b\s*
        end: (?=)|$
        beginCaptures:
          1: {name: storage.type.iterator.hitori}
        patterns:
          - include: '#declaration-clause'
          - match: *entity-name
            name: entity.name.iterator.hitori

      model:
        applyEndPatternLast: true
        begin: \s*(?<!(?:(?<!\.)\.|[?!:]:)=?)\b(model)\b\s*
        end: (?=)|$
        beginCaptures:
          1: {name: storage.type.model.hitori}
        patterns:
          - include: '#declaration-clause'
          - match: *entity-name
            name: entity.name.model.hitori

      macro:
        applyEndPatternLast: true
        begin: \s*(?<!(?:(?<!\.)\.|[?!:]:)=?)\b(macro)\b\s*
        end: (?=)|$
        beginCaptures:
          1: {name: storage.type.macro.hitori}
        patterns:
          - include: '#declaration-clause'
          - match: *entity-name
            name: entity.name.macro.hitori

      query:
        applyEndPatternLast: true
        begin: \s*(?<!(?:(?<!\.)\.|[?!:]:)=?)\b(query)\b\s*
        end: (?=)|$
        beginCaptures:
          1: {name: storage.type.query.hitori}
        patterns:
          - include: '#declaration-clause'
          - match: *entity-name
            name: entity.name.query.hitori

      object:
        applyEndPatternLast: true
        begin: \s*(?<!(?:(?<!\.)\.|[?!:]:)=?)\b(object)\b\s*
        end: (?=)|$
        beginCaptures:
          1: {name: storage.type.object.hitori}
        patterns:
          - include: '#declaration-clause'
          - match: *entity-name
            name: entity.name.object.hitori

      trait:
        applyEndPatternLast: true
        begin: \s*(?<!(?:(?<!\.)\.|[?!:]:)=?)\b(trait)\b\s*
        end: (?=)|$
        beginCaptures:
          1: {name: storage.type.trait.hitori}
        patterns:
          - include: '#declaration-clause'
          - match: *entity-name
            name: entity.name.trait.hitori

      realm:
        applyEndPatternLast: true
        begin: \s*(?<!(?:(?<!\.)\.|[?!:]:)=?)\b(realm)\b\s*
        end: (?=)|$
        beginCaptures:
          1: {name: storage.type.realm.hitori}
        patterns:
          - include: '#declaration-clause'
          - match: *entity-name
            name: entity.name.realm.hitori

      union:
        applyEndPatternLast: true
        begin: \s*(?<!(?:(?<!\.)\.|[?!:]:)=?)\b(union)\b\s*
        end: (?=)|$
        beginCaptures:
          1: {name: storage.type.union.hitori}
        patterns:
          - include: '#declaration-clause'
          - match: *entity-name
            name: entity.name.union.hitori

      struct:
        applyEndPatternLast: true
        begin: \s*(?<!(?:(?<!\.)\.|[?!:]:)=?)\b(struct)\b\s*
        end: (?=)|$
        beginCaptures:
          1: {name: storage.type.struct.hitori}
        patterns:
          - include: '#declaration-clause'
          - match: *entity-name
            name: entity.name.struct.hitori

      field:
        applyEndPatternLast: true
        begin: \s*(?<!(?:(?<!\.)\.|[?!:]:)=?)\b(field)\b\s*
        end: (?=)|$
        beginCaptures:
          1: {name: storage.type.field.hitori}
        patterns:
          - include: '#declaration-clause'
          - match: *entity-name
            name: entity.name.field.hitori

  declaration-clause:
    name: meta.declaration.hitori
    patterns:
      - match: *constraint-keyword
        name: keyword.other.$1.hitori
      - match: \b([\p{Pc}\p{L}]\w*)\b(?=::|\.)
        name: entity.name.namespace.hitori
      - include: '#type-square-brackets'
      - include: '#type-signature'
      - include: '#decorators'
      - include: '#type-keywords'
      - match: \s*(?<!\*)\*(?!\*)\s*
        name: keyword.generator.asterisk.hitori
      - include: '#comments'
      - include: '#comma'
      - include: '#line-continuation'
      - begin: (\()\s*
        end: \s*(\))
        captures:
          1: {name: punctuation.definition.parameters.hitori}
        patterns:
          - include: '#binding-pattern'
          - include: $self
      - begin: (\#\{)\s*
        end: \s*(\})
        name: meta.brace.curly.hitori
        captures:
          1: {name: punctuation.section.class.hitori}
        patterns:
          - include: $self
      - begin: (\{)\s*
        end: \s*(\})
        name: meta.brace.curly.hitori
        captures:
          1: {name: punctuation.definition.block.hitori}
        patterns:
          - include: $self
      - include: '#brackets'
      - include: '#literals'
      - match: ::|\.
        name: punctuation.separator.namespace.hitori
      - match: \s+
        name: meta.block.hitori

  function-clause:
    patterns:
      - comment: |
          Function def before function keyword
          x = def()
        match: |
          (?x)

          \s*

          (?<=[?!:]:|\b\.|[?!]\.)

          \s*

          # Label
          \b([\p{Pc}\p{L}]\w*)\b\s+

          # Assignment operator
          (:?=)\s+

          (
            (?:
              \s*
              \b
              (?: # Modifier keywords
                pub|priv|prot|final|readonly|override
                |global|local|intern|extern|mut|immut
                |post|[gs]et|put|del|req|opt
                |safe|unsafe|virtual|sealed|abs|friend|enemy
                |pure|impure|early|late|covar|contra
                |in|out|inout|inplace|ref|defer|a?sync
                |stat|dyn|lazy|eager|bound|free|unique
                |union|open|closed?|rec|oper|curry|opaque
                |inline|prefix|infix|suffix|unary|left|right
              )
              \b
              \s*
            )*
          )

          (?=
            \s*
            \b
            (?: # Function types
              function|proc|method|type
              |class|impl|enum|module|struct|field|union
              |iter|macro|query|object|realm
              |trait|style|script|elem|field|model|actor
            )
            \b
          )
        name: meta.function.declaration.hitori
        captures:
          1: {name: entity.name.method.hitori}
          2: {name: keyword.operator.assignment.hitori}
          3: {patterns: [include: '#modifiers']}
      - begin: |
          (?x)

          (?<=[?!:]:|\b\.|[?!]\.)

          \s*

          # Label
          \b([\p{Pc}\p{L}]\w*)\b\s+

          # Assignment operator
          (:?=)\s+

          (
            (?:
              \s*
              \b
              (?: # Modifier keywords
                pub|priv|prot|final|readonly|override
                |global|local|intern|extern|mut|immut
                |post|[gs]et|put|del|req|opt
                |safe|unsafe|virtual|sealed|abs|friend|enemy
                |pure|impure|early|late|covar|contra
                |in|out|inout|inplace|ref|defer|a?sync
                |stat|dyn|lazy|eager|bound|free|unique
                |union|open|closed?|rec|oper|curry|opaque
                |inline|prefix|infix|suffix|unary|left|right
              )
              \b
              \s*
            )*
          )

          \s*
          (\|)(?!\|)
        end: (?<!\|)(\|)(?!\|)
        name: meta.function.declaration.hitori
        captures:
          1: {name: entity.name.method.hitori}
          2: {name: keyword.operator.assignment.hitori}
          3: {patterns: [include: '#modifiers']}
          4: {name: punctuation.separator.arguments.hitori}
        endCaptures:
          1: {name: punctuation.separator.arguments.hitori}
        patterns:
          - include: '#argument-list-content'
      - comment: |
          Function def before function keyword
          x = def()
        match: |
          (?x)

          \s*

          # Label
          \b([\p{Pc}\p{L}]\w*)\b\s+

          # Assignment operator
          (:?=)\s+

          (
            (?:
              \s*
              \b
              (?: # Modifier keywords
                pub|priv|prot|final|readonly|override
                |global|local|intern|extern|mut|immut
                |post|[gs]et|put|del|req|opt
                |safe|unsafe|virtual|sealed|abs|friend|enemy
                |pure|impure|early|late|covar|contra
                |in|out|inout|inplace|ref|defer|a?sync
                |stat|dyn|lazy|eager|bound|free|unique
                |union|open|closed?|rec|oper|curry|opaque
                |inline|prefix|infix|suffix|unary|left|right
              )
              \b
              \s*
            )*
          )

          (?=
            \s*
            \b
            (?: # Function types
              function|proc|method|type
              |class|impl|enum|module|struct|field|union
              |iter|macro|query|object|realm
              |trait|style|script|elem|field|model|actor
            )
            \b
          )
        name: meta.function.declaration.hitori
        captures:
          1: {name: entity.name.hitori}
          2: {name: keyword.operator.assignment.hitori}
          3: {patterns: [include: '#modifiers']}
      - begin: |
          (?x)

          \s*

          # Label
          \b([\p{Pc}\p{L}]\w*)\b\s+

          # Assignment operator
          (:?=)\s+

          \s*

          (
            (?:
              \s*
              \b
              (?: # Modifier keywords
                pub|priv|prot|final|readonly|override
                |global|local|intern|extern|mut|immut
                |post|[gs]et|put|del|req|opt
                |safe|unsafe|virtual|sealed|abs|friend|enemy
                |pure|impure|early|late|covar|contra
                |in|out|inout|inplace|ref|defer|a?sync
                |stat|dyn|lazy|eager|bound|free|unique
                |union|open|closed?|rec|oper|curry|opaque
                |inline|prefix|infix|suffix|unary|left|right
              )
              \b
              \s*
            )*
          )

          \s*
          (\|)(?!\|)
        end: (?<!\|)(\|)(?!\|)
        name: meta.function.declaration.hitori
        captures:
          1: {name: entity.name.hitori}
          2: {name: keyword.operator.assignment.hitori}
          3: {patterns: [include: '#modifiers']}
          4: {name: punctuation.separator.arguments.hitori}
        endCaptures:
          1: {name: punctuation.separator.arguments.hitori}
        patterns:
          - include: '#argument-list-content'

  argument-list:
    name: meta.function.arguments.hitori
    begin: |
      (?x)
      (?<=
        (?:
            # beginning of line
            ^
          | # separator
            [,;]
          | # opening bracket
            [({\[]
          | # postfix or infix operator
            [\p{S}\p{P}&&[^,;'"`({\[)}\]\p{Pc}]]+ \s
        ) \s*
        | # a keyword
        (?:
          (?:^|[,;'"({\[)}\]\s]) # beside a delimiter or space
          \b
            (?: # keywords
              [io]n|of|as|is|new|del
              |unset|ref|and|x?or|not
              |var|val|let|const|given|using
              |func|proc|method|type|class|actor
              |impl|enum|module|struct|field
              |union|iter|macro|query|elem
              |object|realm|trait|style|script
              |go|defer|do|with|from|where
              |if|else|then|guard|when
              |for|loop|while|goto|move
              |try|throw|catch|finally|switch
              |match|case|pass|def
              |break|skip|redo|retry
              |return|yield|await|scope
              |import|export|intern|extern
              |debug|assert|check
            )
          \b
        ) \s*
      ) \s*
      (\|)(?!\|)
    captures:
      1: {name: punctuation.separator.arguments.hitori}
    end: (?<!\|)(\|)(?!\|)
    patterns:
      - include: '#argument-list-content'

  argument-list-content:
    patterns:
      - match: \s*(?<!(?:(?<!\.)\.|[?!:]:)=?)\b(as)\b\s*
        name: keyword.operator.expression.as.hitori
      - match: (?<=[\w\s][(|])\.
        name: punctuation.definition.metadata.hitori
      - match: ','
        name: punctuation.separator.arguments.hitori
      - include: '#binding-pattern'

  clauses:
    patterns:
      - include: '#for-clause'
      - include: '#if-clause'
      - include: '#match-clause'
      - include: '#switch-clause'
      - include: '#try-clause'
      - include: '#catch-clause'
      - include: '#with-clause'
      - include: '#do-clause'
      - include: '#type-clause'
      - include: '#new-clause'

    repository:
      new-clause:
        applyEndPatternLast: true
        begin: \s*(?<!(?:(?<!\.)\.|[?!:]:)=?)\b(new)\b
        end: (?=)|$
        beginCaptures:
          1: {name: keyword.operator.expression.$1.hitori}
        patterns:
          - match: *entity-name
            name: entity.name.instance.hitori
          - include: '#type-clause'
          - include: '#type-keywords'
          - include: '#type-square-brackets'
          - include: '#parameter-brackets'
          - include: '#round-brackets'

      type-clause:
        patterns:
          - applyEndPatternLast: true
            begin: \s*(?<!(?:(?<!\.)\.|[?!:]:)=?)\b(as)\b\s*
            end: (?=)|$
            beginCaptures:
              1: {name: keyword.operator.expression.as.hitori}
            patterns:
              - include: '#types'
          - applyEndPatternLast: true
            begin: \s*(?<!(?:(?<!\.)\.|[?!:]:)=?)\b(is\s+not|is)\b\s*
            end: (?=)|$
            beginCaptures:
              1: {name: keyword.operator.expression.is.hitori}
            patterns:
              - include: '#types'
          - applyEndPatternLast: true
            begin: \s*(?<!(?:(?<!\.)\.|[?!:]:)=?)\b(type)\b\s*
            end: (?=)|$
            captures:
              1: {name: keyword.other.typedef.hitori}
            patterns:
              - include: '#types'
              - match: \s*([:!=</>.^$%?*+|&~]?=)\s*
                captures:
                  1: {name: keyword.operator.assignment.hitori}

      try-clause:
        applyEndPatternLast: true
        begin: \s*(?<!(?:(?<!\.)\.|[?!:]:)=?)\b(try|then|finally)\b\s*(?=\()
        end: (?=)|$
        name: meta.if.hitori
        captures:
          1: {name: keyword.control.error.hitori}
          2: {name: keyword.operator.logical.hitori}
        patterns:
          - begin: \s*(\()\s*
            end: \s*(\))
            captures:
              1: {name: punctuation.definition.expression.hitori}
            patterns:
              - match: \s*(?<!(?:(?<!\.)\.|[?!:]:)=?)\b(await)\b\s*
                name: keyword.control.error.hitori
              - include: $self

      catch-clause:
        applyEndPatternLast: true
        begin: \s*(?<!(?:(?<!\.)\.|[?!:]:)=?)\b(catch)\b\s*(?=\()
        end: (?=)|$
        name: meta.catch.hitori
        captures:
          1: {name: keyword.control.error.hitori}
        patterns:
          - begin: \s*(\()\s*
            end: \s*(\))
            captures:
              1: {name: punctuation.definition.expression.hitori}
            patterns:
              - match: \s*(?<!(?:(?<!\.)\.|[?!:]:)=?)\b(as)\b\s*
                name: keyword.control.error.hitori
              - include: $self
          - begin: \s*(\{)\s*
            end: \s*(\})\s*
            captures:
              1: {name: punctuation.definition.block.hitori}
            patterns:
              - include: '#catch-case-clause'
              - include: $self

      catch-case-clause:
        patterns:
          - match: \s*(?<!(?:(?<!\.)\.|[?!:]:)=?)\b(def)\b\s*(:)
            captures:
              1: {name: keyword.control.error.hitori}
              2:
                name: punctuation.definition.case-statement.hitori
          - begin: \s*(?<!(?:(?<!\.)\.|[?!:]:)=?)\b(case)\b\s*
            end: \s*(:)(?=['"`({\[)}\]\w\s])|$
            beginCaptures:
              1: {name: keyword.control.error.hitori}
            endCaptures:
              1:
                name: punctuation.definition.case-statement.hitori
            patterns:
              - include: '#argument-list'
              - applyEndPatternLast: true
                begin: \s*(?<!(?:(?<!\.)\.|[?!:]:)=?)\b(is\s+not|is)\b\s*
                end: (?=)|$
                beginCaptures:
                  1: {name: keyword.control.error.hitori}
                patterns:
                  - include: '#types'
              - match: \s*(?<!(?:(?<!\.)\.|[?!:]:)=?)\b(if\s+not|if|guard|when|as)\b\s*
                name: keyword.control.error.hitori
              - include: '#type-keywords'
              - include: $self

      for-clause:
        applyEndPatternLast: true
        begin: \s*(?<!(?:(?<!\.)\.|[?!:]:)=?)\b(for|while\s+not|while)\b\s*(?=\()
        end: (?=)|$
        name: meta.for.hitori
        captures:
          1: {name: keyword.control.loop.hitori}
        patterns:
          - begin: \s*(\()\s*
            end: \s*(\))
            captures:
              1: {name: punctuation.definition.expression.hitori}
            patterns:
              - match: \s*(?<!(?:(?<!\.)\.|[?!:]:)=?)\b([io]n|of)\b\s*
                name: keyword.control.loop.hitori
              - include: $self

      if-clause:
        applyEndPatternLast: true
        begin: \s*(?<!(?:(?<!\.)\.|[?!:]:)=?)\b(if\s+not|if|guard|when)\b\s*(?=\()
        end: (?=)|$
        name: meta.if.hitori
        captures:
          1: {name: keyword.control.conditional.hitori}
          2: {name: keyword.operator.logical.hitori}
        patterns:
          - begin: \s*(\()\s*
            end: \s*(\))
            captures:
              1: {name: punctuation.definition.expression.hitori}
            patterns:
              - match: \s*(?<!(?:(?<!\.)\.|[?!:]:)=?)\b(await)\b\s*
                name: keyword.control.conditional.hitori
              - include: $self

      match-clause:
        applyEndPatternLast: true
        begin: \s*(?<!(?:(?<!\.)\.|[?!:]:)=?)\b(match)\b\s*(?=[({])
        end: (?=)|$
        name: meta.match.hitori
        captures:
          1: {name: keyword.control.match.hitori}
        patterns:
          - begin: \s*(\()\s*
            end: \s*(\))
            captures:
              1: {name: punctuation.definition.expression.hitori}
            patterns:
              - match: \s*(?<!(?:(?<!\.)\.|[?!:]:)=?)\b(await)\b\s*
                name: keyword.control.match.hitori
              - include: $self
          - begin: \s*(\{)\s*
            end: \s*(\})\s*
            captures:
              1: {name: punctuation.definition.block.hitori}
            patterns:
              - include: '#match-case-clause'
              - include: $self

      match-case-clause:
        patterns:
          - match: \s*(?<!(?:(?<!\.)\.|[?!:]:)=?)\b(def)\b\s*(:)
            captures:
              1: {name: keyword.control.match.hitori}
              2:
                name: punctuation.definition.case-statement.hitori
          - begin: \s*(?<!(?:(?<!\.)\.|[?!:]:)=?)\b(case)\b\s*
            end: \s*(:)(?=['"`({\[)}\]\w\s])|$
            beginCaptures:
              1: {name: keyword.control.match.hitori}
            endCaptures:
              1:
                name: punctuation.definition.case-statement.hitori
            patterns:
              - include: '#argument-list'
              - applyEndPatternLast: true
                begin: \s*(?<!(?:(?<!\.)\.|[?!:]:)=?)\b(is\s+not|is)\b\s*
                end: (?=)|$
                beginCaptures:
                  1: {name: keyword.control.match.hitori}
                patterns:
                  - include: '#types'
              - match: \s*(?<!(?:(?<!\.)\.|[?!:]:)=?)\b(if\s+not|if|guard|when|as)\b\s*
                name: keyword.control.match.hitori
              - include: '#type-keywords'
              - include: $self

      switch-clause:
        applyEndPatternLast: true
        begin: \s*(?<!(?:(?<!\.)\.|[?!:]:)=?)\b(switch)\b\s*(?=[({])
        end: (?=)|$
        name: meta.switch.hitori
        captures:
          1: {name: keyword.control.switch.hitori}
        patterns:
          - begin: \s*(\()\s*
            end: \s*(\))
            captures:
              1: {name: punctuation.definition.expression.hitori}
            patterns:
              - match: \s*(?<!(?:(?<!\.)\.|[?!:]:)=?)\b(await)\b\s*
                name: keyword.control.switch.hitori
              - include: $self
          - begin: \s*(\{)\s*
            end: \s*(\})\s*
            captures:
              1: {name: punctuation.definition.block.hitori}
            patterns:
              - include: '#switch-case-clause'
              - include: $self

      switch-case-clause:
        patterns:
          - match: \s*(?<!(?:(?<!\.)\.|[?!:]:)=?)\b(def)\b\s*(:)
            captures:
              1: {name: keyword.control.switch.hitori}
              2:
                name: punctuation.definition.case-statement.hitori
          - begin: \s*(?<!(?:(?<!\.)\.|[?!:]:)=?)\b(case)\b\s*
            end: \s*(:)(?=['"`({\[)}\]\w\s])|$
            beginCaptures:
              1: {name: keyword.control.switch.hitori}
            endCaptures:
              1:
                name: punctuation.definition.case-statement.hitori
            patterns:
              - include: '#argument-list'
              - applyEndPatternLast: true
                begin: \s*(?<!(?:(?<!\.)\.|[?!:]:)=?)\b(is\s+not|is)\b\s*
                end: (?=)|$
                beginCaptures:
                  1: {name: keyword.control.switch.hitori}
                patterns:
                  - include: '#types'
              - match: \s*(?<!(?:(?<!\.)\.|[?!:]:)=?)\b(if\s+not|if|guard|when|as)\b\s*
                name: keyword.control.switch.hitori
              - include: '#type-keywords'
              - include: $self

      with-clause:
        applyEndPatternLast: true
        begin: \s*(?<!(?:(?<!\.)\.|[?!:]:)=?)\b(with)\b\s*(?=\()
        end: (?=)|$
        name: meta.with.hitori
        captures:
          1: {name: keyword.control.with.hitori}
        patterns:
          - begin: \s*(\()\s*
            end: \s*(\))
            captures:
              1: {name: punctuation.definition.expression.hitori}
            patterns:
              - match: \s*(?<!(?:(?<!\.)\.|[?!:]:)=?)\b(await|as)\b\s*
                name: keyword.control.with.hitori
              - include: $self

  # Binding patterns

  object-key:
    begin: (?<=^|{|;|,)\s*
    end: \s*(?=,|;|}|$)|\s*(:)
    name: meta.object-key.hitori
    endCaptures:
      1: {name: punctuation.separator.key-value.hitori}
    patterns:
      - include: '#literals'
      - include: '#embedded-expression'
      - include: '#brackets'
      - match: (?<=^|{|;|,)\s*\b[\p{Pc}\p{L}]\w*\b\s*(?=,|;|}|:|$)
        name: constant.other.object.key.hitori
      - include: '#space'
      - include: '#comments'
      - include: '#line-continuation'
      - include: $self

  object-value:
    patterns:
      - match: (?<=(?:^|{|;|,)\s*)\b[\p{Pc}\p{L}]\w*\b(?=\s*(?:,|;|}|=['"`({\[\w\s]|$))
        name: variable.other.constant.hitori
      - match: (?<=^|{|;|,)\s*\b[\p{Pc}\p{L}]\w*\b\s*(?=,|;|}|=['"`({\[\w\s]|$)
        name: variable.other.constant.hitori

  object-argument:
    patterns:
      - match: (?<=(?:^|{|;|,)\s*)\b[\p{Pc}\p{L}]\w*\b(?=\s*(?:,|;|}|=['"`({\[\w\s]|$))
        name: variable.parameter.named.hitori
      - match: (?<=^|{|;|,)\s*\b[\p{Pc}\p{L}]\w*\b\s*(?=,|;|}|=['"`({\[\w\s]|$)
        name: variable.parameter.named.hitori

  as-keyword:
    match: \s*(?<!(?:(?<!\.)\.|[?!:]:)=?)\b(as)\b\s*
    name: keyword.operator.expression.as.hitori

  given-using-keyword:
    match: \s*(?<!(?:(?<!\.)\.|[?!:]:)=?)\b(given|using)\b\s*
    name: keyword.operator.expression.$1.hitori

  binding-pattern-object:
    begin: (#?{)\s*
    end: \s*(})
    name: meta.brace.curly.hitori
    captures:
      1: {name: punctuation.definition.binding-pattern.object.hitori}
    patterns:
      - include: '#object-argument'
      - include: '#labels'
      - include: '#object-key'
      - match: ;|,
        name: punctuation.separator.mapping.hitori
      - include: '#binding-pattern'
      - include: '#illegal'

  binding-pattern-tuple:
    begin: (#?\()\s*
    end: \s*(\))
    name: meta.brace.curly.hitori
    captures:
      1: {name: punctuation.definition.binding-pattern.tuple.hitori}
    patterns:
      - include: '#labels'
      - match: ;|,
        name: punctuation.separator.arguments.hitori
      - include: '#binding-pattern'
      - include: '#illegal'

  binding-pattern-array:
    begin: (#?\[)\s*
    end: \s*(])
    name: meta.brace.curly.hitori
    captures:
      1: {name: punctuation.definition.binding-pattern.array.hitori}
    patterns:
      - include: '#labels'
      - match: ;|,
        name: punctuation.separator.sequence.hitori
      - include: '#binding-pattern'
      - include: '#illegal'

  default-value:
    begin: (?<=^|[\s({\[])(\=)(?=$|[)}\]\s])|(?<=['"`)}\]\w]|\\.)(\=)(?=['"`({\[\w])
    captures:
      1: {name: keyword.operator.assignment.hitori}
      2: {name: keyword.operator.assignment.hitori}
    end: (?=\|(?:$|[^|])|[,;)}\]])
    patterns:
      - include: $self

  binding-pattern:
    patterns:
      - include: '#default-value'
      - include: '#as-keyword'
      - include: '#given-using-keyword'
      - include: '#binding-pattern-object'
      - include: '#binding-pattern-tuple'
      - include: '#binding-pattern-array'
      - include: '#illegal-identifiers'
      - include: '#parameter-variables'
      - include: '#type-operators'
      - include: '#type-signature'
      - include: '#space'
      - include: '#comments'
      - include: '#calls'

  # Object labels

  labels:
    patterns:
      - comment: |
          Function def before function keyword
          x = def()
        match: |
          (?x)
          (?<=^\s*|[{;,]\s*)

          \s*

          # Label
          (\b[\p{Pc}\p{L}][\p{Pd}\w]*\b)
          # Key value separator
          (:)\s*

          (
            (?:
              \s*
              \b
              (?: # Modifier keywords
                pub|priv|prot|final|readonly|override
                |global|local|intern|extern|mut|immut
                |post|[gs]et|put|del|req|opt
                |safe|unsafe|virtual|sealed|abs|friend|enemy
                |pure|impure|early|late|covar|contra
                |in|out|inout|inplace|ref|defer|a?sync
                |stat|dyn|lazy|eager|bound|free|unique
                |union|open|closed?|rec|oper|curry|opaque
                |inline|prefix|infix|suffix|unary|left|right
              )
              \b
              \s*
            )*
          )

          (?=
            \s*
            \b
            (?: # Function types
              function|proc|method|type
              |class|impl|enum|module|struct|field|union
              |iter|macro|query|object|realm
              |trait|style|script|elem|field|model|actor
            )
            \b
          )
        name: meta.object-literal.key.hitori
        captures:
          1: {name: entity.name.hitori}
          2: {name: punctuation.separator.key-value.hitori}
          3: {patterns: [include: '#modifiers']}
      - begin: |
          (?x)
          (?<=^\s*|[{;,]\s*)

          \s*

          # Label
          (\b[\p{Pc}\p{L}][\p{Pd}\w]*\b)
          # Key value separator
          (:)

          \s*

          (
            (?:
              \s*
              \b
              (?: # Modifier keywords
                pub|priv|prot|final|readonly|override
                |global|local|intern|extern|mut|immut
                |post|[gs]et|put|del|req|opt
                |safe|unsafe|virtual|sealed|abs|friend|enemy
                |pure|impure|early|late|covar|contra
                |in|out|inout|inplace|ref|defer|a?sync
                |stat|dyn|lazy|eager|bound|free|unique
                |union|open|closed?|rec|oper|curry|opaque
                |inline|prefix|infix|suffix|unary|left|right
              )
              \b
              \s*
            )*
          )

          \s*
          (\|)(?!\|)
        end: (?<!\|)(\|)(?!\|)
        name: meta.object-literal.key.hitori
        beginCaptures:
          1: {name: entity.name.hitori}
          2: {name: punctuation.separator.key-value.hitori}
          3: {patterns: [include: '#modifiers']}
          4: {name: punctuation.separator.arguments.hitori}
        endCaptures:
          1: {name: punctuation.separator.arguments.hitori}
        patterns:
          - include: '#argument-list-content'
      - match: |
          (?x)
          (?<=^\s*|[{;,]\s*)

          \s*

          # label
          (\b[\p{Pc}\p{L}][\p{Pd}\w]*\b)

          (?=: ['"`({\[)}\]\w\s])
        name: meta.object-literal.key.hitori
        captures:
          1:
            name: constant.other.object.key.hitori
            patterns:
              - include: '#constants'
              - include: '#numbers'
              - include: '#symbols'
              - include: '#string-content'

  # Punctuation

  punctuation:
    patterns:
      - include: '#line-continuation'
      - include: '#comma'
      - include: '#double-semicolon'
      - include: '#semicolon'

  line-continuation:
    begin: \s*(`)\s*(?=/[/*](?![\p{S}\p{P}&&[^,;'"`({\[)}\]\p{Pc}]]+)|$)
    end: ^\s*(?=\S)
    captures:
      1: {name: punctuation.separator.continuation.line.hitori}
    patterns:
      - include: '#comments'

  comma:
    match: \s*(,)
    name: punctuation.separator.expression.hitori

  double-semicolon:
    match: \s*(;;)
    name: punctuation.terminator.expression.hitori

  semicolon:
    match: \s*(;)
    name: punctuation.terminator.statement.hitori

  brackets:
    patterns:
      - include: '#angle-brackets'
      - include: '#curly-brackets'
      - include: '#square-brackets'
      - include: '#round-brackets'

  generics:
    comment: Support for Turbofish syntax
    name: meta.type-arguments
    begin: (?<=^|['"`)}\]>\w\s])([?!:]:|[?!]?\.)(<)(?=['"`({\[\w])
    end: (?<=^|['"`)}\]>\w])()(>)(!\b)?
    captures:
      1:
        name: punctuation.type.arguments.hitori
        patterns: [include: '#generic-operators']
      2: {name: punctuation.type.arguments.hitori}
      3: {name: keyword.operator.macro.hitori}
    patterns:
      - include: '#punctuation'
      - include: '#brackets'
      - include: '#types'
      - include: '#type-signature'

  generic-operators:
    name: punctuation.type.arguments.hitori
    match: |
      (?x)
      (?:
        ( # 1: optional accessor
          \?[.:]=?
        ) |
        ( # 2: assertion/call operator
          ![.:]=?
        ) |
        ( # 3: accessor operator
          (?:::|\.)=?
        )
      )
    captures:
      1: {name: keyword.operator.optional.hitori}
      2: {name: keyword.operator.assert.hitori}
      3: {name: keyword.operator.accessor.hitori}

  accessor-operators:
    name: punctuation.type.arguments.hitori
    match: |
      (?x)
      (?<=\b|>)
      (?:
        ( # 1: optional accessor
          \?[.:]=?
        ) |
        ( # 2: assertion/call operator
          ![.:]=?
        ) |
        ( # 3: accessor operator
          (?:::|\.)=?
        )
      )
      (?=\b|<)
    captures:
      1: {name: keyword.operator.optional.hitori}
      2: {name: keyword.operator.assert.hitori}
      3: {name: keyword.operator.accessor.hitori}

  angle-brackets:
    patterns:
      - comment: Type arguments. This is complicated since we don't want to match things like foo < 123 || bar > baz
        name: meta.type-arguments
        begin: (?<=^|['"`)}\]>\w\s])(<)(?=['"`({\[\w])
        end: (?<=^|['"`)}\]>\w])(>)
        captures:
          1: {name: punctuation.type.arguments.hitori}
        patterns:
          - include: '#punctuation'
          - include: '#brackets'
          - include: '#types'
          - include: '#type-signature'

  curly-brackets:
    repository:
      punctuation:
        patterns:
          - match: ','
            name: punctuation.separator.mapping.hitori
          - match: (?<=(?:['"`)}\]\w]|\\.)[\p{S}\p{P}&&[^,;'"`({\[)}\]\p{Pc}]]*):(?=['"`({\[\w\s]|$)
            name: punctuation.separator.key-value.hitori

    patterns:
      - begin: |
          (?x)
          (?<=
            (?:
                (?:^|[\s\p{P}\p{S}]):\|\s*\| # beside a lambda pipe
              | (?:^|[,;'"`)}\]\w\s]|\\.)\|
              | ^\s*\|
            )
          )
          \s*
          (\#\{)
          \s*
        end: \s*(\})
        name: meta.brace.curly.hitori
        captures:
          1: {name: punctuation.section.class.hitori}
        patterns:
          - include: $self
      - begin: |
          (?x)
          (?<=
            (?:
                (?:^|[\s\p{P}\p{S}]):\|\s*\| # beside a lambda pipe
              | (?:^|[,;'"`)}\]\w\s]|\\.)\|
              | ^\s*\|
            )
          )
          \s*
          (\{)
          \s*
        end: \s*(\})
        name: meta.brace.curly.hitori
        captures:
          1: {name: punctuation.definition.block.hitori}
        patterns:
          - include: $self
      - begin: |
          (?x)
          (?<=
            (?:^|[,;'"({\[)}\]\s]) # beside a delimiter or space
            \b
              (?: # destructuring keywords
                var|val|let|const|given|using|case
              )
            \b
            (?:$|[,;'"({\[)}\]\s]) # beside a delimiter or space
            \s*
          )
          (\#?\{)\s*
        end: \s*(\})
        name: meta.brace.curly.hitori
        captures:
          1:
            name: punctuation.definition.binding-pattern.object.hitori
        patterns:
          - include: '#labels'
          - include: '#punctuation'
          - include: '#object-value'
          - include: '#object-key'
          - include: '#as-keyword'
          - include: $self
      - begin: |
          (?x)
          (?<=
            (?:^|[,;'"({\[)}\]\s]) # beside a delimiter or space
            \b
              (?: # expression keywords
                [io]n|of|as|is|new|del
                |unset|ref|and|x?or|not
              )
            \b
            (?:$|[,;'"({\[)}\]\s]) # beside a delimiter or space
            \s*
          )
          (\#\{)\s*
        end: \s*(\})
        name: meta.brace.curly.hitori
        captures:
          1: {name: punctuation.definition.mapping.hitori}
        patterns:
          - include: '#labels'
          - include: '#punctuation'
          - include: '#object-value'
          - include: '#object-key'
          - include: $self
      - begin: |
          (?x)
          (?<=
            (?:^|[,;'"({\[)}\]\s]) # beside a delimiter or space
            \b
              (?: # expression keywords
                [io]n|of|as|is|new|del
                |unset|ref|and|x?or|not
              )
            \b
            (?:$|[,;'"({\[)}\]\s]) # beside a delimiter or space
            \s*
          )
          (\{)\s*
        end: \s*(\})
        name: meta.brace.curly.hitori
        captures:
          1: {name: punctuation.definition.dictionary.hitori}
        patterns:
          - include: '#labels'
          - include: '#punctuation'
          - include: '#object-value'
          - include: '#object-key'
          - include: $self
      - begin: |
          (?x)
          (?<=
            (?:
                ^
              | [,;({\[]
              | (?:^|[,;({\[)}\]\w'"`]|\\.):\s*
              | [\p{S}\p{P}&&[^,;'"`({\[)}\]\p{Pc}]]+
            )
            \s*
          )
          (\#\{)\s*
        end: \s*(\})
        name: meta.brace.curly.hitori
        captures:
          1: {name: punctuation.definition.mapping.hitori}
        patterns:
          - include: '#labels'
          - include: '#punctuation'
          - include: '#object-value'
          - include: '#object-key'
          - include: $self
      - begin: |
          (?x)
          (?<=
            (?:
                ^
              | [,;({\[]
              | (?:^|[,;({\[)}\]\w'"`]|\\.):\s*
              | [\p{S}\p{P}&&[^,;'"`({\[)}\]\p{Pc}]]+
            )
            \s*
          )
          (\{)\s*
        end: \s*(\})
        name: meta.brace.curly.hitori
        captures:
          1: {name: punctuation.definition.dictionary.hitori}
        patterns:
          - include: '#labels'
          - include: '#punctuation'
          - include: '#object-value'
          - include: '#object-key'
          - include: $self
      - begin: (\#\{)\s*
        end: \s*(\})
        name: meta.brace.curly.hitori
        captures:
          1: {name: punctuation.section.class.hitori}
        patterns:
          - include: $self
      - begin: (\{)\s*
        end: \s*(\})
        name: meta.brace.curly.hitori
        captures:
          1: {name: punctuation.definition.block.hitori}
        patterns:
          - include: $self

  round-brackets:
    repository:
      punctuation:
        patterns:
          - match: ','
            name: punctuation.separator.arguments.hitori
          - match: \s*(?<!(?:(?<!\.)\.|[?!:]:)=?)\b(as)\b\s*
            name: keyword.operator.expression.as.hitori
          - match: (?<=[\w\s][(|])\.
            name: punctuation.definition.metadata.hitori

    patterns:
      - begin: |
          (?x)
          (?<=
            (?:^|[,;'"({\[)}\]\s]) # beside a delimiter or space
            \b
              (?: # destructuring keywords
                var|val|let|const|given|using|case
              )
            \b
            (?:$|[,;'"({\[)}\]\s]) # beside a delimiter or space
            \s*
          )
          (\#?\()\s*
        end: \s*(\))
        name: meta.brace.round.hitori
        captures:
          1: {name: punctuation.definition.binding-pattern.tuple.hitori}
        patterns:
          - include: '#as-keyword'
          - include: '#punctuation'
          - include: $self
      - begin: |
          (?x)
          (?<= # literal
              (?: [\w'"`)}\]] | \\.) >* !?
            | [^.]\.=?|[?!:]:=?
          )
          (\#?\()\s*
        end: \s*(\))
        name: meta.brace.round.hitori
        captures:
          1: {name: punctuation.definition.parameters.hitori}
        patterns:
          - include: '#parameter-variables'
          - include: $self
      - begin: (\#\()\s*
        end: \s*(\))
        name: meta.brace.round.hitori
        captures:
          1: {name: punctuation.definition.tuple.hitori}
        patterns:
          - include: '#s-expression'
          - include: $self
      - begin: (\()\s*
        end: \s*(\))
        name: meta.brace.round.hitori
        captures:
          1: {name: punctuation.definition.expression.hitori}
        patterns:
          - include: '#s-expression'
          - include: $self

  square-brackets:
    repository:
      punctuation:
        patterns:
          - match: ','
            name: punctuation.separator.sequence.hitori

    patterns:
      - begin: |
          (?x)
          (?<=
            (?:^|[,;'"({\[)}\]\s]) # beside a delimiter or space
            \b
              (?: # destructuring keywords
                var|val|let|const|given|using|case
              )
            \b
            (?:$|[,;'"({\[)}\]\s]) # beside a delimiter or space
            \s*
          )
          (\#?\[)\s*
        end: \s*(\])
        name: meta.brace.square.hitori
        captures:
          1: {name: punctuation.definition.binding-pattern.array.hitori}
        patterns:
          - include: '#punctuation'
          - include: '#as-keyword'
          - include: $self
      - begin: |
          (?x)
          (?<=
            (?:^|[,;'"({\[)}\]\s]) # beside a delimiter or space
            \b
              (?: # destructuring keywords
                [io]n|of|as|is|new|del
                |unset|ref|and|x?or|not
              )
            \b
            (?:$|[,;'"({\[)}\]\s]) # beside a delimiter or space
            \s*
          )
          (\[)\s*
        end: \s*(\])
        name: meta.brace.square.hitori
        captures:
          1: {name: punctuation.definition.sequence.hitori}
        patterns:
          - include: '#punctuation'
          - include: $self
      - begin: |
          (?x)
          (?<=
            (?:^|[,;'"({\[)}\]\s]) # beside a delimiter or space
            \b
              (?: # destructuring keywords
                [io]n|of|as|is|new|del
                |unset|ref|and|x?or|not
              )
            \b
            (?:$|[,;'"({\[)}\]\s]) # beside a delimiter or space
            \s*
          )
          (\[)\s*
        end: \s*(\])
        name: meta.brace.square.hitori
        captures:
          1: {name: punctuation.definition.array.hitori}
        patterns:
          - include: '#punctuation'
          - include: $self
      - begin: |
          (?x)
          (?<= # literal
              (?: [\w'"`)}\]] | \\.)
            | [^.]\.=?|[?!:]:=?
          )
          (\#?\[)\s*
        end: \s*(\])
        name: meta.brace.square.hitori
        captures:
          1: {name: punctuation.definition.attribute-selector.hitori}
        patterns:
          - include: '#message'
          - include: '#punctuation'
          - include: $self
      - begin: (\#\[)\s*
        end: \s*(\])
        name: meta.brace.square.hitori
        captures:
          1: {name: punctuation.definition.sequence.hitori}
        patterns:
          - include: '#message'
          - include: '#punctuation'
          - include: $self
      - begin: (\[)\s*
        end: \s*(\])
        name: meta.brace.square.hitori
        captures:
          1: {name: punctuation.definition.array.hitori}
        patterns:
          - include: '#message'
          - include: '#punctuation'
          - include: $self

  # Sub-expressions
  s-expression:
    patterns:
      - include: '#function-calls'
      - include: '#literals'
      - match: |
          (?x)
          (?<=\()
          \s*
          ( # Function name
            \b
            # ignore all keywords
            (?!
              (?<!(?:(?<!\.)\.|[?!:]:)=?)\b
              (?: # keywords
                [io]n|of|as|is|new|del
                |unset|ref|and|x?or|not
                |var|val|let|const|given|using
                |func|proc|method|type|class|actor
                |impl|enum|module|struct|field
                |union|iter|macro|query|elem
                |object|realm|trait|style|script
                |go|defer|do|with|from|where
                |if|else|then|guard|when
                |for|loop|while|goto|move
                |try|throw|catch|finally|switch
                |match|case|pass|def
                |break|skip|redo|retry
                |return|yield|await|scope
                |import|export|intern|extern
                |debug|assert|check
              )
              \b
            )
            (?:
              \b
              [\p{Pc}\p{L}]\w* # identifier
              \b
              (?:[!?]?\.=?|[?!:]:=?) # qualified name separator
            )*
            [\p{Pc}\p{L}]\w* # last part of identifier
            \b
          )
          \s*
          (?= 
              \s[({\[\w] # opening brackets
            | (?:\w*|[\\$#%]*)['"] | `\s*(?=\N) # string literals 
            | :[\p{Pc}\p{L}]\w* # symbol literals
            | $ # end of line
          )
        name: meta.function-call.hitori
        captures:
          1:
            patterns:
              - include: '#function-names'
              - include: '#accessor-operators'
      - include: $self

  # Objective-C-style messages
  message:
    patterns:
      - include: '#function-calls'
      - applyEndPatternLast: true
        begin: |
          (?x)
          (?<= # literal
            (?: 
                [\w'"`)}\]] # literals and closing brackets
              | [?!:]:[\p{Pc}\p{L}]\w* # identifiers
              | [?!][\p{Pc}\p{L}]\w* # identifiers
              | \\. # escape sequences
            ) 
            \s*
          )
          \s*
          ([?!:]:|[?!])?
          ( # Message name
            \b
            # ignore all keywords
            (?!
              (?<!(?:(?<!\.)\.|[?!:]:)=?)\b
              (?: # keywords
                [io]n|of|as|is|new|del
                |unset|ref|and|x?or|not
                |var|val|let|const|given|using
                |func|proc|method|type|class|actor
                |impl|enum|module|struct|field
                |union|iter|macro|query|elem
                |object|realm|trait|style|script
                |go|defer|do|with|from|where
                |if|else|then|guard|when
                |for|loop|while|goto|move
                |try|throw|catch|finally|switch
                |match|case|pass|def
                |break|skip|redo|retry
                |return|yield|await|scope
                |import|export|intern|extern
                |debug|assert|check
              )
              \b
            )
            \b
            [\p{Pc}\p{L}]\w* # identifier
            \b
          )
          (:)
        end: (?=)|$
        name: meta.message.hitori
        beginCaptures:
          1:
            patterns:
              - match: |
                  (?x)
                  (?:
                    ( # 1: optional accessor
                      \?:?
                    ) |
                    ( # 2: assertion/call operator
                      !:?
                    ) |
                    ( # 3: accessor operator
                      ::
                    )
                  )
                captures:
                  1: {name: keyword.operator.optional.hitori}
                  2: {name: keyword.operator.assert.hitori}
                  3: {name: keyword.operator.accessor.hitori}
          2:
            patterns:
              - match: |
                  (?x)
                  (?: # Regular variables
                    # Leading underscore
                    (\p{Pc}+\w*\b(?!\p{Pc}+))
                  | # Train case
                    ([\p{L}&&\P{Ll}][\w&&\P{Ll}]*)
                  | # Pascal case
                    ((?:[\p{Pc}\p{L}&&\P{Ll}][\w&&\P{Lu}]*)+)
                  | # Camel or kebab case
                    ([\p{Pc}\p{L}]\w*)
                  )
                captures:
                  1:
                    patterns: *builtin-names
                    name: entity.name.tag.hitori
                  2:
                    patterns: *builtin-names
                    name: entity.name.tag.hitori support.class.component.hitori
                  3:
                    patterns: *builtin-names
                    name: entity.name.class.builtin.hitori
                  4:
                    patterns: *builtin-names
                    name: entity.name.function.member.hitori
          3: {name: punctuation.separator.arguments.hitori}
        patterns:
          - include: '#brackets'
      - match: |
          (?x)
          (?<= # literal
            (?: 
                [\w'"`)}\]] # literals and closing brackets
              | [?!:]:[\p{Pc}\p{L}]\w* # identifiers
              | [?!][\p{Pc}\p{L}]\w* # identifiers
              | \\. # escape sequences
            ) 
            \s*
          )
          \s*
          ([?!:]:|[?!])?
          ( # Message name
            \b
            # ignore all keywords
            (?!
              (?<!(?:(?<!\.)\.|[?!:]:)=?)\b
              (?: # keywords
                [io]n|of|as|is|new|del
                |unset|ref|and|x?or|not
                |var|val|let|const|given|using
                |func|proc|method|type|class|actor
                |impl|enum|module|struct|field
                |union|iter|macro|query|elem
                |object|realm|trait|style|script
                |go|defer|do|with|from|where
                |if|else|then|guard|when
                |for|loop|while|goto|move
                |try|throw|catch|finally|switch
                |match|case|pass|def
                |break|skip|redo|retry
                |return|yield|await|scope
                |import|export|intern|extern
                |debug|assert|check
              )
              \b
            )
            \b
            [\p{Pc}\p{L}]\w* # identifier
            \b
          )
        name: meta.message.hitori
        captures:
          1:
            patterns:
              - match: |
                  (?x)
                  (?:
                    ( # 1: optional accessor
                      \?:?
                    ) |
                    ( # 2: assertion/call operator
                      !:?
                    ) |
                    ( # 3: accessor operator
                      ::
                    )
                  )
                captures:
                  1: {name: keyword.operator.optional.hitori}
                  2: {name: keyword.operator.assert.hitori}
                  3: {name: keyword.operator.accessor.hitori}
          2:
            patterns:
              - match: |
                  (?x)
                  (?: # Regular variables
                    # Leading underscore
                    (\p{Pc}+\w*\b(?!\p{Pc}+))
                  | # Train case
                    ([\p{L}&&\P{Ll}][\w&&\P{Ll}]*)
                  | # Pascal case
                    ((?:[\p{Pc}\p{L}&&\P{Ll}][\w&&\P{Lu}]*)+)
                  | # Camel or kebab case
                    ([\p{Pc}\p{L}]\w*)
                  )
                captures:
                  1: {name: variable.other.property.dynamic.hitori}
                  2: {name: variable.other.constant.property.hitori}
                  3: {name: variable.other.property.stat.hitori}
                  4: {name: variable.other.property.hitori}

  # Support

  css-property-names:
    patterns:
      - match: (?x)\b(additiveSymbols|alignContent|alignItems|alignSelf|all|animation|animationDelay|animationDirection|animationDuration|animationFillMode|animationIterationCount|animationName|animationPlayState|animationTimingFunction|backdropFilter|backfaceVisibility|background|backgroundAttachment|backgroundBlendMode|backgroundClip|backgroundColor|backgroundImage|backgroundOrigin|backgroundPosition|backgroundPosition[XY]|backgroundRepeat|backgroundSize|bleed|blockSize|border|borderBlockEnd|borderBlockEndColor|borderBlockEndStyle|borderBlockEndWidth|borderBlockStart|borderBlockStartColor|borderBlockStartStyle|borderBlockStartWidth|borderBottom|borderBottomColor|borderBottomLeftRadius|borderBottomRightRadius|borderBottomStyle|borderBottomWidth|borderCollapse|borderColor|borderEndEndRadius|borderEndStartRadius|borderImage|borderImageOutset|borderImageRepeat|borderImageSlice|borderImageSource|borderImageWidth|borderInlineEnd|borderInlineEndColor|borderInlineEndStyle|borderInlineEndWidth|borderInlineStart|borderInlineStartColor|borderInlineStartStyle|borderInlineStartWidth|borderLeft|borderLeftColor|borderLeftStyle|borderLeftWidth|borderRadius|borderRight|borderRightColor|borderRightStyle|borderRightWidth|borderSpacing|borderStartEndRadius|borderStartStartRadius|borderStyle|borderTop|borderTopColor|borderTopLeftRadius|borderTopRightRadius|borderTopStyle|borderTopWidth|borderWidth|bottom|boxDecorationBreak|boxShadow|boxSizing|breakAfter|breakBefore|breakInside|captionSide|caretColor|clear|clip|clipPath|clipRule|color|colorAdjust|colorInterpolationFilters|columnCount|columnFill|columnGap|columnRule|columnRuleColor|columnRuleStyle|columnRuleWidth|columnSpan|columnWidth|columns|contain|content|counterIncrement|counterReset|cursor|direction|display|emptyCells|enableBackground|fallback|fill|fillOpacity|fillRule|filter|flex|flexBasis|flexDirection|flexFlow|flexGrow|flexShrink|flexWrap|float|floodColor|floodOpacity|font|fontDisplay|fontFamily|fontFeatureSettings|fontKerning|fontLanguageOverride|fontOpticalSizing|fontSize|fontSizeAdjust|fontStretch|fontStyle|fontSynthesis|fontVariant|fontVariantAlternates|fontVariantCaps|fontVariantEastAsian|fontVariantLigatures|fontVariantNumeric|fontVariantPosition|fontVariationSettings|fontWeight|gap|glyphOrientationHorizontal|glyphOrientationVertical|grid|gridArea|gridAutoColumns|gridAutoFlow|gridAutoRows|gridColumn|gridColumnEnd|gridColumnGap|gridColumnStart|gridGap|gridRow|gridRowEnd|gridRowGap|gridRowStart|gridTemplate|gridTemplateAreas|gridTemplateColumns|gridTemplateRows|hangingPunctuation|height|hyphens|imageOrientation|imageRendering|imageResolution|imeMode|initialLetter|initialLetterAlign|inlineSize|inset|insetBlock|insetBlockEnd|insetBlockStart|insetInline|insetInlineEnd|insetInlineStart|isolation|justifyContent|justifyItems|justifySelf|kerning|left|letterSpacing|lightingColor|lineBreak|lineClamp|lineHeight|listStyle|listStyleImage|listStylePosition|listStyleType|margin|marginBlockEnd|marginBlockStart|marginBottom|marginInlineEnd|marginInlineStart|marginLeft|marginRight|marginTop|markerEnd|markerMid|markerStart|marks|mask|maskBorder|maskBorderMode|maskBorderOutset|maskBorderRepeat|maskBorderSlice|maskBorderSource|maskBorderWidth|maskClip|maskComposite|maskImage|maskMode|maskOrigin|maskPosition|maskRepeat|maskSize|maskType|maxBlockSize|maxHeight|maxInlineSize|maxLines|maxWidth|maxZoom|minBlockSize|minHeight|minInlineSize|minWidth|minZoom|mixBlendMode|negative|objectFit|objectPosition|offset|offsetAnchor|offsetDistance|offsetPath|offsetPosition|offsetRotation|opacity|order|orientation|orphans|outline|outlineColor|outlineOffset|outlineStyle|outlineWidth|overflow|overflowAnchor|overflowBlock|overflowInline|overflowWrap|overflow-[xy]|overscrollBehavior|overscrollBehaviorBlock|overscrollBehaviorInline|overscrollBehavior-[xy]|pad|padding|paddingBlockEnd|paddingBlockStart|paddingBottom|paddingInlineEnd|paddingInlineStart|paddingLeft|paddingRight|paddingTop|pageBreakAfter|pageBreakBefore|pageBreakInside|paintOrder|perspective|perspectiveOrigin|placeContent|placeItems|placeSelf|pointerEvents|position|prefix|quotes|range|resize|right|rotate|rowGap|rubyAlign|rubyMerge|rubyPosition|scale|scrollBehavior|scrollMargin|scrollMarginBlock|scrollMarginBlockEnd|scrollMarginBlockStart|scrollMarginBottom|scrollMarginInline|scrollMarginInlineEnd|scrollMarginInlineStart|scrollMarginLeft|scrollMarginRight|scrollMarginTop|scrollPadding|scrollPaddingBlock|scrollPaddingBlockEnd|scrollPaddingBlockStart|scrollPaddingBottom|scrollPaddingInline|scrollPaddingInlineEnd|scrollPaddingInlineStart|scrollPaddingLeft|scrollPaddingRight|scrollPaddingTop|scrollSnapAlign|scrollSnapCoordinate|scrollSnapDestination|scrollSnapStop|scrollSnapType|scrollbarColor|scrollbarGutter|scrollbarWidth|shapeImageThreshold|shapeMargin|shapeOutside|shapeRendering|size|speakAs|src|stopColor|stopOpacity|stroke|strokeDashArray|strokeDashOffset|strokeLineCap|strokeLineJoin|strokeMiterLimit|strokeOpacity|strokeWidth|suffix|symbols|system|tabSize|tableLayout|textAlign|textAlignLast|textAnchor|textCombineUpright|textDecoration|textDecorationColor|textDecorationLine|textDecorationSkip|textDecorationSkipInk|textDecorationStyle|textEmphasis|textEmphasisColor|textEmphasisPosition|textEmphasisStyle|textIndent|textJustify|textOrientation|textOverflow|textRendering|textShadow|textSizeAdjust|textTransform|textUnderlinePosition|top|touchAction|transform|transformBox|transformOrigin|transformStyle|transition|transitionDelay|transitionDuration|transitionProperty|transitionTimingFunction|translate|unicodeBidi|unicodeRange|userSelect|userZoom|verticalAlign|visibility|whiteSpace|widows|width|willChange|wordBreak|wordSpacing|wordWrap|writingMode|zIndex|zoom|alignmentBaseline|baselineShift|clipRule|colorInterpolation|colorInterpolationFilters|colorProfile|colorRendering|cx|cy|dominantBaseline|enableBackground|fill|fillOpacity|fillRule|floodColor|floodOpacity|glyphOrientationHorizontal|glyphOrientationVertical|height|kerning|lightingColor|markerEnd|markerMid|markerStart|r|rx|ry|shapeRendering|stopColor|stopOpacity|stroke|strokeDashArray|strokeDashOffset|strokeLineCap|strokeLineJoin|strokeMiterLimit|strokeOpacity|strokeWidth|textAnchor|width|x|y|adjust|after|align|alignLast|alignment|alignmentAdjust|appearance|attachment|azimuth|backgroundBreak|balance|baseline|before|bidi|binding|bookmark|bookmarkLabel|bookmarkLevel|bookmarkTarget|borderLength|bottomColor|bottomLeftRadius|bottomRightRadius|bottomStyle|bottomWidth|box|boxAlign|boxDirection|boxFlex|boxFlexGroup|boxLines|boxOrdinalGroup|boxOrient|boxPack|break|character|collapse|column|columnBreakAfter|columnBreakBefore|count|counter|crop|cue|cueAfter|cueBefore|decoration|decorationBreak|delay|displayModel|displayRole|down|drop|dropInitialAfterAdjust|dropInitialAfterAlign|dropInitialBeforeAdjust|dropInitialBeforeAlign|dropInitialSize|dropInitialValue|duration|elevation|emphasis|family|fit|fitPosition|flexGroup|floatOffset|gap|gridColumns|gridRows|hangingPunctuation|header|hyphenate|hyphenateAfter|hyphenateBefore|hyphenateCharacter|hyphenateLines|hyphenateResource|icon|image|increment|indent|index|initialAfterAdjust|initialAfterAlign|initialBeforeAdjust|initialBeforeAlign|initialSize|initialValue|inlineBoxAlign|iterationCount|justify|label|leftColor|leftStyle|leftWidth|length|level|line|lineStacking|lineStackingRuby|lineStackingShift|lineStackingStrategy|lines|list|mark|markAfter|markBefore|marks|marquee|marqueeDirection|marqueePlayCount|marqueeSpeed|marqueeStyle|max|min|model|moveTo|name|nav|navDown|navIndex|navLeft|navRight|navUp|new|numeral|offset|ordinalGroup|orient|origin|overflowStyle|overhang|pack|page|pagePolicy|pause|pauseAfter|pauseBefore|phonemes|pitch|pitchRange|playCount|playDuring|playState|point|presentation|presentationLevel|profile|property|punctuation|punctuationTrim|radius|rate|renderingIntent|repeat|replace|reset|resolution|resource|respondTo|rest|restAfter|restBefore|richness|rightColor|rightStyle|rightWidth|role|rotation|rotationPoint|rows|ruby|rubyOverhang|rubySpan|rule|ruleColor|ruleStyle|ruleWidth|shadow|size|sizeAdjust|sizing|space|spaceCollapse|spacing|span|speak|speakHeader|speakNumeral|speakPunctuation|speech|speechRate|speed|stacking|stackingRuby|stackingShift|stackingStrategy|stress|stretch|stringSet|style|styleImage|stylePosition|styleType|target|targetName|targetNew|targetPosition|text|textHeight|textJustify|textOutline|textReplace|textWrap|timingFunction|topColor|topLeftRadius|topRightRadius|topStyle|topWidth|trim|unicode|up|userSelect|variant|voice|voiceBalance|voiceDuration|voiceFamily|voicePitch|voicePitchRange|voiceRate|voiceStress|voiceVolume|volume|weight|white|whiteSpaceCollapse|word|wrap)\b
        name: support.type.property-name.css.hitori
      - match: (?x)\b(?:ah|apple|atsc|epub|hp|khtml|moz|ms|o|rim|ro|tc|wap|webkit|xv|mso|prince)(?:[\p{Pc}\p{L}&&\P{Ll}][\w&&\P{Lu}]*)+\b
        name: support.type.vendored.property-name.css.hitori

  css-value-names:
    comment: TODO
    patterns:
      - match: (?x)\b(aqua|black|blue|fuchsia|gray|green|lime|maroon|navy|olive|orange|purple|red|silver|teal|white|yellow)\b
        name: support.constant.color.w3c-standard-color-name.css.hitori
      - match: (?x)\b(aliceblue|antiquewhite|aquamarine|azure|beige|bisque|blanchedalmond|blueviolet|brown|burlywood|cadetblue|chartreuse|chocolate|coral|cornflowerblue|cornsilk|crimson|cyan|darkblue|darkcyan|darkgoldenrod|darkgray|darkgreen|darkgrey|darkkhaki|darkmagenta|darkolivegreen|darkorange|darkorchid|darkred|darksalmon|darkseagreen|darkslateblue|darkslategray|darkslategrey|darkturquoise|darkviolet|deeppink|deepskyblue|dimgray|dimgrey|dodgerblue|firebrick|floralwhite|forestgreen|gainsboro|ghostwhite|gold|goldenrod|greenyellow|grey|honeydew|hotpink|indianred|indigo|ivory|khaki|lavender|lavenderblush|lawngreen|lemonchiffon|lightblue|lightcoral|lightcyan|lightgoldenrodyellow|lightgray|lightgreen|lightgrey|lightpink|lightsalmon|lightseagreen|lightskyblue|lightslategray|lightslategrey|lightsteelblue|lightyellow|limegreen|linen|magenta|mediumaquamarine|mediumblue|mediumorchid|mediumpurple|mediumseagreen|mediumslateblue|mediumspringgreen|mediumturquoise|mediumvioletred|midnightblue|mintcream|mistyrose|moccasin|navajowhite|oldlace|olivedrab|orangered|orchid|palegoldenrod|palegreen|paleturquoise|palevioletred|papayawhip|peachpuff|peru|pink|plum|powderblue|rebeccapurple|rosybrown|royalblue|saddlebrown|salmon|sandybrown|seagreen|seashell|sienna|skyblue|slateblue|slategray|slategrey|snow|springgreen|steelblue|tan|thistle|tomato|transparent|turquoise|violet|wheat|whitesmoke|yellowgreen)\b
        name: support.constant.color.w3c-extended-color-name.css.hitori
      - match: (?x)\b(currentColor)\b
        name: support.constant.color.current.css.hitori
      - match: (?x)\b(ActiveBorder|ActiveCaption|AppWorkspace|Background|ButtonFace|ButtonHighlight|ButtonShadow|ButtonText|CaptionText|GrayText|Highlight|HighlightText|InactiveBorder|InactiveCaption|InactiveCaptionText|InfoBackground|InfoText|Menu|MenuText|Scrollbar|ThreeDDarkShadow|ThreeDFace|ThreeDHighlight|ThreeDLightShadow|ThreeDShadow|Window|WindowFrame|WindowText)\b
        name: support.constant.color.system.css.hitori
      - match: (?x)\b(above|absolute|active|add|additive|afterEdge|alias|all|allPetiteCaps|allScroll|allSmallCaps|alpha|alphabetic|alternate|alternateReverse|always|antialiased|auto|autoPos|available|avoid|avoidColumn|avoidPage|avoidRegion|backwards|balance|baseline|beforeEdge|below|bevel|bidiOverride|blink|block|blockAxis|blockStart|blockEnd|bold|bolder|border|borderBox|both|bottom|bottomOutside|breakAll|breakWord|bullets|butt|capitalize|caption|cell|center|central|char|circle|clip|clone|closeQuote|closestCorner|closestSide|colResize|collapse|color|colorBurn|colorDodge|column|columnReverse|commonLigatures|compact|condensed|contain|content|contentBox|contents|contextMenu|contextual|copy|cover|crispEdges|crispEdges|crosshair|cyclic|darken|dashed|decimal|default|dense|diagonalFractions|difference|digits|disabled|disc|discretionaryLigatures|distribute|distributeAllLines|distributeLetter|distributeSpace|dot|dotted|double|doubleCircle|downleft|downright|eResize|eachLine|ease|easeIn|easeInOut|easeOut|economy|ellipse|ellipsis|embed|end|evenodd|ewResize|exact|exclude|exclusion|expanded|extends|extraCondensed|extraExpanded|fallback|farthestCorner|farthestSide|fill|fillAvailable|fillBox|filled|fitContent|fixed|flat|flex|flexEnd|flexStart|flip|flowRoot|forwards|freeze|fromImage|fullWidth|geometricPrecision|georgian|grab|grabbing|grayscale|grid|groove|hand|hanging|hardLight|help|hidden|hide|historicalForms|historicalLigatures|horizontal|horizontalTb|hue|icon|ideographAlpha|ideographNumeric|ideographParenthesis|ideographSpace|ideographic|inactive|infinite|inherit|initial|inline|inlineAxis|inlineBlock|inlineEnd|inlineFlex|inlineGrid|inlineListItem|inlineStart|inlineTable|inset|inside|interCharacter|interIdeograph|interWord|intersect|invert|isolate|isolateOverride|italic|jis04|jis78|jis83|jis90|justify|justifyAll|kannada|keepAll|landscape|large|larger|left|lighten|lighter|line|lineEdge|lineThrough|linear|linearRGB|liningNums|listItem|local|loose|lowercase|lr|lrTb|ltr|luminance|luminosity|mainSize|mandatory|manipulation|manual|marginBox|matchParent|matchSource|mathematical|maxContent|medium|menu|messageBox|middle|minContent|miter|mixed|move|multiply|nResize|narrower|neResize|nearestNeighbor|neswResize|newspaper|noChange|noClip|noCloseQuote|noCommonLigatures|noContextual|noDiscretionaryLigatures|noDrop|noHistoricalLigatures|noOpenQuote|noRepeat|none|nonzero|normal|notAllowed|nowrap|nsResize|numbers|numeric|nwResize|nwseResize|oblique|oldstyleNums|open|openQuote|optimizeLegibility|optimizeQuality|optimizeSpeed|optional|ordinal|outset|outside|over|overlay|overline|padding|paddingBox|page|painted|panDown|panLeft|panRight|panUp|panX|panY|paused|petiteCaps|pixelated|plaintext|pointer|portrait|pre|preLine|preWrap|preserve3d|progress|progressive|proportionalNums|proportionalWidth|proximity|radial|recto|region|relative|remove|repeat|repeat-[xy]|resetSize|reverse|revert|ridge|right|rl|rlTb|round|row|rowResize|rowReverse|rowSeverse|rtl|ruby|rubyBase|rubyBaseContainer|rubyText|rubyTextContainer|runIn|running|sResize|saturation|scaleDown|screen|scroll|scrollPosition|seResize|semiCondensed|semiExpanded|separate|sesame|show|sideways|sidewaysLeft|sidewaysLr|sidewaysRight|sidewaysRl|simplified|slashedZero|slice|small|smallCaps|smallCaption|smaller|smooth|softLight|solid|space|spaceAround|spaceBetween|spaceEvenly|spellOut|square|sRGB|stackedFractions|start|stat|statusBar|swap|stepEnd|stepStart|sticky|stretch|strict|stroke|strokeBox|style|sub|subgrid|subpixelAntialiased|subtract|super|swResize|symbolic|table|tableCaption|tableCell|tableColumn|tableColumnGroup|tableFooterGroup|tableHeaderGroup|tableRow|tableRowGroup|tabularNums|tb|tbRl|text|textAfterEdge|textBeforeEdge|textBottom|textTop|thick|thin|titlingCaps|top|topOutside|touch|traditional|transparent|triangle|ultraCondensed|ultraExpanded|under|underline|unicase|unset|upleft|uppercase|upright|useGlyphOrientation|useScript|verso|vertical|verticalIdeographic|verticalLr|verticalRl|verticalText|viewBox|visible|visibleFill|visiblePainted|visibleStroke|wResize|wait|wavy|weight|whitespace|wider|words|wrap|wrapReverse|x|xLarge|xSmall|xxLarge|xxSmall|y|zero|zoomIn|zoomOut)\b
        name: support.constant.property-value.css.hitori
      - match: (?x)\b(arabicIndic|armenian|bengali|cambodian|circle|cjkDecimal|cjkEarthlyBranch|cjkHeavenlyStem|cjkIdeographic|decimal|decimalLeadingZero|devanagari|disc|disclosureClosed|disclosureOpen|ethiopicHalehameAm|ethiopicHalehameTiE[rt]|ethiopicNumeric|georgian|gujarati|gurmukhi|hangul|hangulConsonant|hebrew|hiragana|hiraganaIroha|japaneseFormal|japaneseInformal|kannada|katakana|katakanaIroha|khmer|koreanHangulFormal|koreanHanjaFormal|koreanHanjaInformal|lao|lowerAlpha|lowerArmenian|lowerGreek|lowerLatin|lowerRoman|malayalam|mongolian|myanmar|oriya|persian|simpChineseFormal|simpChineseInformal|square|tamil|telugu|thai|tibetan|tradChineseFormal|tradChineseInformal|upperAlpha|upperArmenian|upperLatin|upperRoman|urdu)\b
        name: support.constant.property-value.list-style-type.css.hitori
      - match: (?x)\b(arial|century|comic|courier|garamond|georgia|helvetica|impact|lucida|symbol|systemUi|system|tahoma|times|trebuchet|uiMonospace|uiRounded|uiSansSerif|uiSerif|utopia|verdana|webdings|sansSerif|serif|monospace)\b
        name: support.constant.font-name.css.hitori

  html-tag-names:
    patterns:
      - match: (?x)\b(all|print|screen|speech|aural|braille|embossed|handheld|projection|tty|tv)\b
        name: support.constant.media.css.hitori
      - match: (?x)\b(a|abbr|acronym|address|altGlyph|altGlyphDef|altGlyphItem|animate|animateColor|animateMotion|animateTransform|annotation|annotationXml|applet|area|article|aside|audio|b|base|basefont|bdi|bdo|bgsound|big|blink|blockquote|body|br|button|canvas|caption|center|circle|cite|clipPath|code|col|colgroup|colorProfile|command|content|cursor|data|datalist|dd|defs|del|desc|details|dfn|dialog|dir|discard|div|dl|dt|elem|ellipse|em|embed|feBlend|feColorMatrix|feComponentTransfer|feComposite|feConvolveMatrix|feDiffuseLighting|feDisplacementMap|feDistantLight|feDropShadow|feFlood|feFuncA|feFuncB|feFuncG|feFuncR|feGaussianBlur|feImage|feMerge|feMergeNode|feMorphology|feOffset|fePointLight|feSpecularLighting|feSpotLight|feTile|feTurbulence|fieldset|figcaption|figure|filter|font|fontFace|fontFaceFormat|fontFaceName|fontFaceSrc|fontFaceUri|footer|foreignObject|form|frame|frameset|g|glyph|glyphRef|hatch|hatchpath|hd|head|header|hgroup|hkern|hr|html|h[1-6]|i|iframe|image|img|input|ins|isindex|kbd|keygen|label|legend|li|line|linearGradient|link|listing|maction|main|maligngroup|malignmark|map|mark|marker|marquee|mask|math|menclose|menu|menuitem|merror|mesh|meshgradient|meshpatch|meshrow|meta|metadata|meter|mfenced|mfrac|mglyph|mi|missingGlyph|mlabeledtr|mlongdiv|mmultiscripts|mn|mo|mover|mpadded|mpath|mphantom|mroot|mrow|ms|mscarries|mscarry|msgroup|msline|mspace|msqrt|msrow|mstack|mstyle|msub|msubsup|msup|mtable|mtd|mtext|mtr|multicol|munder|munderover|nav|nextid|nobr|noembed|noframes|noscript|object|ol|optgroup|option|output|p|param|path|pattern|picture|plaintext|polygon|polyline|pre|progress|q|radialGradient|rb|rect|rp|rt|rtc|ruby|s|samp|script|section|select|semantics|set|shadow|slot|small|solidcolor|source|spacer|span|stop|strike|strong|style|sub|summary|sup|svg|switch|symbol|table|tbody|td|template|text|textarea|textPath|tfoot|th|thead|time|title|tr|track|tref|tspan|tt|u|ul|use|var|video|view|vkern|wbr|xmp)\b
        name: entity.name.tag.css.hitori

  entities:
    patterns:
      - include: '#function-names'
      - include: '#constant-names'
      - include: '#type-names'
      - include: '#variable-names'

  type-names:
    comment: Names for built-in types
    patterns:
      - comment: Primitive classes
        match: |
          (?x)\s*(?<![?!]?\.|[?!:]:)\b(
            # upper flat case
            Bool|Char|Rune|Str|Sym
            |(Big)?(Num|Int|Float|Frac|Real|Imag|Complex)
            # lower flat case
            |bool|char|rune|str|sym
            |num|int|float|frac|real|imag|complex
            |(big)?(Num|Int|Float|Frac|Real|Imag|Complex)
            # upper flat case
            |[iucjf](8|16|32|64|128|256|512|1024)
            |[IUCJF](8|16|32|64|128|256|512|1024)
          )\b
        name: support.type.builtin.primitive.hitori
      - comment: Data query classes
        match: |
          (?x)\s*(?<![?!]?\.|[?!:]:)\b(
            Array|Tuple|Set|Map|Object|Seq|Record|Dict
            |Process|Range|Stack|Heap|Queue|Tree|Trie|Graph
            |Future|Stream|RegExp|Func|Buffer|FrozenSe[tq]
            # lower flat case
            |array|tuple|set|map|object|seq|record|dict
            |process|range|stack|heap|queue|tree|trie|graph
            |future|stream|regexp|func|buffer|frozense[tq]
          )\b
        name: support.type.builtin.hitori
      - comment: Constant/algebraic classes
        match: |
          (?x)\s*(?<![?!]?\.|[?!:]:)\b(
            True|False|Null|Void|NaN|Inf|Empty|Unit|Object
            |Any|Mixed|Just|Some|None|Never|(Im)?pure|Const|Undef
            # lower flat case
            |true|false|null|void|nan|inf|empty|unit|obj
            |any|mixed|just|some|none|never|(im)?pure|const|undef
          )\b
        name: support.type.primitive.hitori
      - comment: Error classes | BaseError, etc
        match: \s*\b((\p{Lu}[\w&&\P{Lu}]*)+)?(Error|Exception)\b
        name: support.class.error.hitori
      - comment: Interface classes | IEnumerable, etc
        match: \s*\bI((\p{Lu}[\w&&\P{Lu}]*)+)\b
        name: entity.name.interface.hitori
      - comment: Namespace classes | NSString, etc
        match: \s*\bNS((\p{Lu}[\w&&\P{Lu}]*)+)\b
        name: entity.name.namespace.hitori
      - comment: Trait classes | Serializable, Loggable etc
        match: \s*\b((\p{Lu}[\w&&\P{Lu}]*)+)able\b
        name: support.class.trait.hitori

  support-functions:
    comment: |
      Names for general support functions in Hitori standard library
      organized by naming conventions for maintainability
    patterns:
      - comment: predicate functions
        match: \s*\b(i|ha)s(\p{Lu}[\w&&\P{Lu}]*)+\b\s*
        name: support.function.predicate.hitori
      - comment: conversion functions
        match: \s*\b(to|from)(\p{Lu}[\w&&\P{Lu}]*)+\b\s*
        name: support.function.type.hitori
      - comment: magic functions like __init__, __str__, etc
        match: \s*\b\p{Pc}+([\p{Pc}\p{L}]\w*)+\p{Pc}+\b\s*
        name: support.function.magic.hitori
      - match: \s*\b[gs]et(\p{Lu}[\w&&\P{Lu}]*)+\b\s*
        comment: accessor functions
        name: support.function.accessor.hitori
      - match: \s*\b(add|append|insert|remove|delete|clear|push|pop|enqueue|dequeue|shift|unshift)(\p{Lu}[\w&&\P{Lu}]*)*\b\s*
        comment: mutator functions
        name: support.function.mutator.hitori
      - match: \s*\b(create|build|make|new|init|initialize|construct|setup)(\p{Lu}[\w&&\P{Lu}]*)*\b\s*
        comment: constructor functions
        name: support.function.constructor.hitori
      - match: \s*\b(update|set|reset|clear|refresh|reload|rebuild|reinitialize|reconstruct)(\p{Lu}[\w&&\P{Lu}]*)*\b\s*
        comment: updater functions
        name: support.function.updater.hitori
      - match: \s*\b(get|fetch|retrieve|load|find|search|lookup|query|read)(\p{Lu}[\w&&\P{Lu}]*)*\b\s*
        comment: retriever functions
        name: support.function.retriever.hitori
      - match: \s*\b(calc(ulate)?|compute|determine|measure|evaluate|process|transform|convert)(\p{Lu}[\w&&\P{Lu}]*)*\b\s*
        comment: processor functions
        name: support.function.processor.hitori
      - match: \s*\b(handle|manage|control|administer|orchestrate|coordinate)(\p{Lu}[\w&&\P{Lu}]*)*\b\s*
        comment: manager functions
        name: support.function.manager.hitori
      - match: \s*\b(send|receive|transmit|broadcast|communicate|connect|disconnect)(\p{Lu}[\w&&\P{Lu}]*)*\b\s*
        comment: communicator functions
        name: support.function.communicator.hitori
      - match: \s*\b(log|trace|debug|info|warn(ing)?|error|fatal|report|audit)(\p{Lu}[\w&&\P{Lu}]*)*\b\s*
        comment: logger functions
        name: support.function.logger.hitori
      - include: '#support-functions-core'

  support-functions-core:
    comment: core utility + stdlib + extended functional sets across major langs and hitori core.
    match: |
      (?x)\s*\b(
        # python core
        print|input|len|type|id|isinstance|hasattr|getattr|setattr|delattr|dir|sorted|reversed|enumerate|range|zip|map|filter|reduce|all|any|min|max|sum|abs|round|pow|divmod|eval|exec|format|hash|help|is|ord|chr|bin|oct|hex|slice|super|vars|globals|locals|callable|compile|memoryview|next|object|property|repr|staticmethod|classmethod|size|length|count|append|extend|insert|remove|pop|clear|copy|update|keys|values|items|get|setdefault|fromkeys|join|split|replace|find|index|upper|lower|strip|lstrip|rstrip|startswith|endswith|formatmap|capitalize|title|swapcase|isdigit|isalpha|isalnum|isnumeric|isdecimal|isspace|iter|reversed|ziplongest|chain|accumulate|groupby|permutations|combinations|combinations_replacement|
        # string ops
        upper|lower|title|capitalize|swapcase|trim|strip|replace|find|split|join|startswith|endswith|substring|substr|reverse|stringify|escape|unescape|padleft|padright|format|encode|decode|charat|charcodeat|concat|match|repeat|template|truncate|
        # collections + iterators
        map|filter|reduce|fold|flatten|groupby|sort|unique|chain|zip|enumerate|collect|insert|remove|pop|push|extend|concat|merge|update|difference|intersection|union|isdisjoint|copy|deepcopy|clear|stack|queue|deque|defaultdict|counter|namedtuple|dataclass|append|prepend|slice|splice|find|index|count|length|size|keys|values|items|get|set|has|contains|insert|delete|reverse|rotate|shuffle|sort|sorted|reverse|toarray|tolist|todict|toset|fromarray|fromlist|fromdict|fromset|lookup|observe|subscribe|iterate|next|peek|foreach|nextvalue|hasnext|haskey|hasvalue|lookupkey|lookupvalue|observekey|observevalue|publish|unpublish|join|split|group|partition|keyby|valueby|lookupby|keyof|valueof|
        # io + file
        open|close|read|write|seek|flush|tell|truncate|isatty|readline|readlines|writelines|input|print|load|save|dump|append|pipe|redirect|tee|buffer|stream|stdout|stderr|stdin|
        # system
        exit|quit|abort|system|exec|execv|execvp|fork|wait|waitpid|getpid|getppid|getuid|getgid|setuid|setgid|getenv|setenv|unsetenv|pwd|cd|ls|ps|kill|sleep|time|clock|gettimeofday|uname|hostname|whoami|uptime|platform|machine|version|architecture|cpu_count|getpriority|setpriority|daemonize|
        # async
        async|await|future|promise|then|catch|finally|resolve|reject|coroutine|task|eventloop|run_until_complete|gather|as_completed|sleep|timeout|defer|schedule|
        # network
        socket|connect|bind|listen|accept|send|recv|sendto|recvfrom|shutdown|getaddrinfo|gethostname|gethostbyname|getpeername|setsockopt|getsockopt|httprequest|httpresponse|download|upload|post|get|put|delete|fetch|openurl|parseurl|quote|unquote|ping|resolve|dnslookup|urlencode|urldecode|websocket|handshake|proxy|sendfile|
        # datetime
        now|today|utcnow|fromtimestamp|totimestamp|strftime|strptime|sleep|time|clock|gettime|localtime|gmtime|mktime|asctime|ctime|timezone|tzoffset|timedelta|addtime|subtime|parseiso|formatdate|dateadd|datesub|dateparse|timestamp|year|month|day|hour|minute|second|microsecond|weekday|isoformat|fromisoformat|timeit|
        # filesystem
        open|close|read|write|seek|flush|rename|remove|mkdir|rmdir|chmod|chown|stat|lstat|access|exists|isfile|isdir|abspath|basename|dirname|joinpath|splitpath|expanduser|expandvars|walk|scandir|listdir|copy|move|link|unlink|symlink|realpath|touch|chdir|fstat|fsync|truncate|tempfile|mktemp|fdopen|
        # regex
        match|search|findall|finditer|split|sub|compile|escape|replace|group|fullmatch|scanner|tokenize|parse|scan|lex|syntax|ast|walk|visit|pattern|captures|replaceall|
        # serialization
        json|yaml|toml|pickle|marshal|unmarshal|dumps|loads|dump|load|save|serialize|deserialize|encode|decode|from_json|to_json|from_yaml|to_yaml|from_toml|to_toml|savefile|readfile|
        # conversion
        int|float|str|bool|complex|bytes|bytearray|ord|chr|hex|oct|bin|repr|ascii|format|toint|tofloat|tostring|tobytes|tolist|todict|tonumpy|topandas|tocsv|fromcsv|tojson|fromjson|
        # reflection
        getattr|setattr|hasattr|delattr|dir|vars|locals|globals|callable|isinstance|issubclass|type|id|repr|help|super|inspect|signature|getmembers|getmodule|getsource|getdoc|getfile|getclasstree|getargspec|getfullargspec|arguments|walk|typeof|varscope|scopechain|fields|methods|props|kindof|ownedattr|walkattrs|attrs|objvars|objfields|objmethods|objprops|self|classof|
        # functional
        map|filter|reduce|fold|lambda|partial|compose|curry|uncurry|identity|constant|apply|pipe|chain|zip|unzip|flatmap|foreach|every|some|none|find|findindex|groupby|partition|take|drop|takewhile|dropwhile|memoize|throttle|debounce|
        # algorithms
        sort|sorted|search|binarysearch|quicksort|mergesort|heapsort|bubblesort|insertionsort|selectionsort|shuffle|randomize|min|max|argmin|argmax|sum|product|accumulate|scan|permute|combinations|permutations|
        # crypto
        md5|sha1|sha224|sha256|sha384|sha512|sha3|shake128|shake256|hmac|blake2b|blake2s|pbkdf2|scrypt|bcrypt|argon2|aes|rsa|dsa|ecdsa|sign|verify|encrypt|decrypt|encode|decode|b64encode|b64decode|hexencode|hexdecode|urandom|randbytes|keygen|hash|digest|hexdigest|salt|cipher|decipher|seal|unseal|mac|pad|unpad|xor|nonce|iv|derivekey|cert|loadpem|savepem|
        # testing
        assert|expect|check|verify|test|suite|case|mock|stub|spy|patch|fixture|setup|teardown|unittest|pytest|benchmark|fuzz|coverage|assertequal|assertraises|asserttrue|assertfalse|
        # graphics
        draw|render|fill|stroke|translate|rotate|scale|pushmatrix|popmatrix|beginpath|closepath|moveto|lineto|curveto|rect|ellipse|arc|image|pixel|getpixel|setpixel|blend|loadimage|saveimage|filter|grayscale|blur|invert|threshold|resize|crop|flip|mirror|gamma|contrast|brightness|saturation|rotateimage|drawtext|drawline|drawrect|drawcircle|drawellipse|drawpolygon|clear|updatecanvas|createcanvas|getcontext|setcontext|renderframe|endframe|waitframe|exportimage|zoom|pan|tilt|orbit|light|shadow|texture|material|shader|depthtest|cullface|zbuffer|antialiasing|gammacorrection|shadows|
        # audio
        play|pause|stop|record|volume|pan|mix|fadein|fadeout|loadsound|savesound|readwav|writewav|fft|ifft|spectrogram|resample|normalize|compress|equalize|filter|echo|reverb|
        # database
        connect|disconnect|cursor|execute|commit|rollback|fetchone|fetchall|fetchmany|query|insert|update|delete|select|join|where|orderby|limit|transaction|begin|end|prepare|bind|closecursor|opendb|closedb|loaddb|savedb|readrow|writerow|migratedb|createdb|dropdb|backupdb|restoredb|index|schema|column|table|vacuum|
        # logging
        log|debug|info|warn|warning|error|fatal|critical|trace|exception|configure|logger|formatter|handler|filter|addhandler|removehandler|setlevel|
        # compression
        zip|unzip|tar|untar|gzip|gunzip|bz2|bzip2|lzma|xz|compress|decompress|pack|unpack|archive|extract|bundle|encodezip|decodezip|deflate|inflate|rar|unrar|zlib|snappy|brotli|
        # errors
        raise|throw|try|except|catch|finally|error|panic|fail|assert|trap|recover|onerror|retry|logerror|warnerror|
        # ml + ai
        fit|predict|train|evaluate|score|compile|transform|inversetransform|fittransform|loadmodel|savemodel|sequential|model|dense|conv2d|flatten|relu|sigmoid|softmax|dropout|batchnorm|tensor|variable|grad|autograd|backward|optimizer|loss|criterion|forward|backward|dataloader|dataset|trainonbatch|predictonbatch|fitgenerator|argmax|argmin|reshape|flatten|squeeze|unsqueeze|stack|concat|expanddims|permute|transpose|lstm|gru|rnn|cnn|embedding|attention|layernorm|
        # data science
        dataframe|series|read_csv|read_excel|read_json|read_sql|to_csv|to_json|to_excel|groupby|pivot|melt|agg|apply|map|filter|sort_values|dropna|fillna|merge|join|concat|stack|unstack|describe|corr|cov|plot|hist|bar|scatter|heatmap|normalize|standardize|scale|
        # web
        fetch|ajax|get|post|put|delete|head|request|response|json|formdata|queryselector|getelementbyid|getelementsbyclass|getelementsbytag|addeventlistener|removeeventlistener|dispatchevent|preventdefault|stoppropagation|createelement|appendchild|removechild|replacechild|innerhtml|outerhtml|textcontent|classlist|style|encodeuri|decodeuri|encodeuricomponent|decodeuricomponent|settimeout|setinterval|cleartimeout|clearinterval|storage|cookie|session|localstorage|addclass|removeclass|toggleclass|
        # css
        color|background|margin|padding|border|font|text|display|position|top|bottom|left|right|width|height|maxwidth|minwidth|maxheight|minheight|float|clear|zindex|overflow|visibility|opacity|align|justify|flex|grid|animation|transition|boxshadow|textshadow|transform|rotate|scale|skew|translate|hex|rgb|rgba|hsl|hsla|vw|vh|em|rem|pt|pc|in|cm|mm|px|percent|auto|none|solid|dashed|dotted|double|groove|ridge|inset|outset|hidden|visible|scroll|clip|contain|cover|repeat|no-repeat|fixed|absolute|relative|sticky|static|flexbox|gridlayout|
        # image
        loadimage|saveimage|resize|crop|rotate|flip|mirror|grayscale|blur|sharpen|contrast|brightness|saturation|gamma|threshold|blend|compose|drawtext|watermark|histogram|resizecanvas|
        # audio-processing
        readwav|writewav|mp3encode|mp3decode|normalize|compress|expand|eq|reverb|chorus|delay|mix|fft|ifft|spectrogram|noisegate|denoise|
        # video
        loadvideo|savevideo|capture|frame|seekframe|readframe|writeframe|fps|resize|crop|rotate|merge|overlay|render|encode|decode|stream|compress|decompress|thumbnail|
        # graphics-3d
        mesh|vertex|normal|uv|texture|shader|render|draw|transform|translate|rotate|scale|projection|camera|light|ray|trace|loadobj|saveobj|loadfbx|savefbx|scene|material|bake|animate|interpolate|
        # physics
        force|mass|velocity|acceleration|momentum|impulse|friction|gravity|collision|simulate|integrate|step|energy|potential|kinetic|torque|spring|rigidbody|particle|fluid|field|attractor|repulsor|constraint|joint|solver|dynamics|kinematics|softbody|raycast|broadphase|narrowphase|contact|transform
      )\b\s*
    name: support.function.core.hitori
